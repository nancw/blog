<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络编程 | NANC</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="月遇丛云 花遇和风">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.e842a6eb.css" as="style"><link rel="preload" href="/assets/js/app.4a086806.js" as="script"><link rel="preload" href="/assets/js/6.bd5416f2.js" as="script"><link rel="preload" href="/assets/js/1.01911418.js" as="script"><link rel="preload" href="/assets/js/3.29f4e629.js" as="script"><link rel="prefetch" href="/assets/js/10.177c36f6.js"><link rel="prefetch" href="/assets/js/11.357b3744.js"><link rel="prefetch" href="/assets/js/12.e7b94fcd.js"><link rel="prefetch" href="/assets/js/13.0e37d2e9.js"><link rel="prefetch" href="/assets/js/14.859c0de5.js"><link rel="prefetch" href="/assets/js/15.ce68e052.js"><link rel="prefetch" href="/assets/js/16.ecee5d2f.js"><link rel="prefetch" href="/assets/js/17.fc7f4db0.js"><link rel="prefetch" href="/assets/js/18.64095822.js"><link rel="prefetch" href="/assets/js/19.91209630.js"><link rel="prefetch" href="/assets/js/20.7dddee11.js"><link rel="prefetch" href="/assets/js/21.b3e66267.js"><link rel="prefetch" href="/assets/js/22.80b12622.js"><link rel="prefetch" href="/assets/js/23.1061cbe1.js"><link rel="prefetch" href="/assets/js/24.847b82d0.js"><link rel="prefetch" href="/assets/js/25.e9197e3f.js"><link rel="prefetch" href="/assets/js/26.949f4e2b.js"><link rel="prefetch" href="/assets/js/27.b07154fe.js"><link rel="prefetch" href="/assets/js/28.6e68cc58.js"><link rel="prefetch" href="/assets/js/29.cf228bf2.js"><link rel="prefetch" href="/assets/js/30.680fc9bc.js"><link rel="prefetch" href="/assets/js/31.f00f9a6e.js"><link rel="prefetch" href="/assets/js/32.343207ba.js"><link rel="prefetch" href="/assets/js/33.2fba0807.js"><link rel="prefetch" href="/assets/js/34.3c1270c6.js"><link rel="prefetch" href="/assets/js/35.8c79ec85.js"><link rel="prefetch" href="/assets/js/36.993f3ab2.js"><link rel="prefetch" href="/assets/js/37.ffaa9a91.js"><link rel="prefetch" href="/assets/js/38.b1063472.js"><link rel="prefetch" href="/assets/js/39.d2a6438f.js"><link rel="prefetch" href="/assets/js/4.2777d27d.js"><link rel="prefetch" href="/assets/js/40.62c8dccc.js"><link rel="prefetch" href="/assets/js/41.af615c49.js"><link rel="prefetch" href="/assets/js/42.b759e61a.js"><link rel="prefetch" href="/assets/js/5.61258adc.js"><link rel="prefetch" href="/assets/js/7.a5a22873.js"><link rel="prefetch" href="/assets/js/8.501169a5.js"><link rel="prefetch" href="/assets/js/9.6772c949.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e842a6eb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>NANC</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>月遇丛云 花遇和风</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>nanc</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="NANC" class="logo"> <span class="site-name">NANC</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/docs/" class="nav-link router-link-active"><i class="iconfont reco-document"></i>
  文档
</a></div><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="iconfont reco-blog"></i>
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-other"></i>
      关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  参考主题
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    nanc
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>29</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>17</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/docs/" class="nav-link router-link-active"><i class="iconfont reco-document"></i>
  文档
</a></div><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="iconfont reco-blog"></i>
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-other"></i>
      关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  参考主题
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/docs/" aria-current="page" class="sidebar-link">文档首页</a></li><li><section class="sidebar-group depth-0"><a href="/docs/intermediate-soft-test/1_computer_system" class="sidebar-heading clickable"><span>软件设计师</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/intermediate-soft-test/1_computer_system.html" class="sidebar-link">计算机系统</a></li><li><a href="/docs/intermediate-soft-test/2_data_structure.html" class="sidebar-link">数据结构</a></li><li><a href="/docs/intermediate-soft-test/3_operating_system.html" class="sidebar-link">操作系统</a></li><li><a href="/docs/intermediate-soft-test/4_software_engineering.html" class="sidebar-link">软件工程</a></li><li><a href="/docs/intermediate-soft-test/5_structured_development.html" class="sidebar-link">结构化开发</a></li><li><a href="/docs/intermediate-soft-test/6_network_basic.html" class="sidebar-link">网络基础</a></li><li><a href="/docs/intermediate-soft-test/7_programming_language.html" class="sidebar-link">程序设计语言</a></li><li><a href="/docs/intermediate-soft-test/8_database_design.html" class="sidebar-link">数据库</a></li><li><a href="/docs/intermediate-soft-test/9_standardized.html" class="sidebar-link">标准化与软件知识产权</a></li><li><a href="/docs/intermediate-soft-test/10_algorithm_design.html" class="sidebar-link">算法设计</a></li><li><a href="/docs/intermediate-soft-test/11_the_afternoon_of_test.html" class="sidebar-link">下午考题</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>网络编程</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>nanc</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">网络编程</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>nanc</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>9/1/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>学习</span><span class="tag-item" data-v-1ff7123e>网络编程</span></i></div></div> <div class="theme-reco-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#字节序">字节序？</a></li><li><a href="#tcp">TCP</a></li><li><a href="#udp">UDP</a></li><li><a href="#ping-icmp">Ping / ICMP</a></li><li><a href="#http">HTTP</a></li><li><a href="#其他">其他</a></li></ul></div><p></p> <h1 id="网络编程"><a href="#网络编程" class="header-anchor">#</a> 网络编程</h1> <h2 id="字节序"><a href="#字节序" class="header-anchor">#</a> 字节序？</h2> <h3 id="什么是大端字节-什么是小端字节"><a href="#什么是大端字节-什么是小端字节" class="header-anchor">#</a> 什么是大端字节，什么是小端字节？</h3> <ul><li><p>大端序（<code>Big-Endian</code>）网络字节序，<font color="cornflowerblue">将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址</font>。这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。</p></li> <li><p>小端序（<code>Little-Endian</code>）主机字节序，<font color="cornflowerblue">将多位数的低位放在较小的地址处，高位放在较大的地址处</font>。小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。</p></li></ul> <h3 id="为何要有字节序"><a href="#为何要有字节序" class="header-anchor">#</a> 为何要有字节序？</h3> <p>很多人会问，为什么会有字节序，统一用大端序不行吗？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，<font color="cornflowerblue">计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序</font>。</p> <h3 id="如何判断字节序"><a href="#如何判断字节序" class="header-anchor">#</a> 如何判断字节序？</h3> <p><strong>① 通过强转的方式, 判断返回值</strong></p> <p>int型强制转化成char型，int型是4字节，char型是1字节，于是int型数据的高3字节被截断。</p> <p><img src="/assets/img/image-20211008095936408-16372870051021.a8ff12a0.png" alt="image-20211008095936408"></p> <p><strong>② 通过使用联合( 共用体 )的方式判断</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">//方法一</span>
<span class="token keyword">int</span> <span class="token function">check_sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//大端返回0，小端返回1.</span>
<span class="token punctuation">}</span>

<span class="token comment">//方法二</span>
<span class="token keyword">int</span> <span class="token function">check_sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">union</span><span class="token punctuation">{</span>
         <span class="token keyword">int</span> i<span class="token punctuation">;</span>
         <span class="token keyword">char</span> c<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>un<span class="token punctuation">;</span>
    un<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> un<span class="token punctuation">.</span>c<span class="token punctuation">;</span><span class="token comment">//大端返回0，小端返回1.</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">check_sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;小端&quot;</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;大端&quot;</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// Linux提供了4个函数来完成主机字节序和网络字节序之间的转换</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜netinet<span class="token operator">/</span>in<span class="token punctuation">.</span>h＞</span></span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">htonl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> hostlong<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> hostshort<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">ntohl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> netlong<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token function">ntohs</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> netshort<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>网络分层模型</p> <p>七层</p> <p>交换机在哪一层</p> <p>四层</p> <p>网络编程连接方式</p> <p>怎么保证客户端与服务端在突然断网的情况下保证另一端知道</p> <p>饱和机制、心跳机制、看门狗机制</p> <p>以太网的了解</p> <p>在局域网中怎么连接两台电脑</p> <p>socket 阻塞和非阻塞的区别</p> <h2 id="tcp"><a href="#tcp" class="header-anchor">#</a> TCP</h2> <p><strong>参考：</strong></p> <ul><li><a href="https://mp.weixin.qq.com/s/fQ7xfnCUVRyw1JCgQ1zASQ" target="_blank" rel="noopener noreferrer">Linux性能优化实践 - 传输层基本原理及故障分析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247484005&amp;idx=1&amp;sn=cb07ee1c891a7bdd0af3859543190202&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">TCP 三次握手和四次挥手面试题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA" target="_blank" rel="noopener noreferrer">TCP 重传、滑动窗口、流量控制、拥塞控制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="tcp基本认识"><a href="#tcp基本认识" class="header-anchor">#</a> TCP基本认识</h3> <h4 id="头部格式"><a href="#头部格式" class="header-anchor">#</a> 头部格式</h4> <ul><li>序列号
<ul><li>在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题</strong>。</li></ul></li> <li>确定应答号
<ul><li>指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决不丢包的问题</strong>。</li></ul></li> <li>控制位
<ul><li>ACK：该位为1时，「确认应答」的字段变为有效，TCP规定除最初建立连接时的SYN包之外该位必须设置为1 。</li> <li>RST：该位为1时，表示TCP连接中出现异常必须强制断开连接。</li> <li>SYC：该位为1时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。</li> <li>FIN：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li></ul></li> <li><img src="/assets/img/image-20220121154742967.4c0c5fcf.png" alt="image-20220121154742967"></li></ul> <h4 id="为什么需要tcp协议-tcp工作在哪一层"><a href="#为什么需要tcp协议-tcp工作在哪一层" class="header-anchor">#</a> 为什么需要TCP协议？TCP工作在哪一层？</h4> <ul><li>IP层是不可靠的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</li> <li>因为TCP是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。</li></ul> <h4 id="什么是tcp"><a href="#什么是tcp" class="header-anchor">#</a> 什么是TCP ？</h4> <ul><li>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。
<ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li> <li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li> <li><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li></ul></li></ul> <h4 id="什么是tcp连接"><a href="#什么是tcp连接" class="header-anchor">#</a> 什么是TCP连接？</h4> <ul><li>简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</li> <li>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。
<ul><li><strong>Socket</strong>：由 IP 地址和端口号组成；</li> <li><strong>序列号</strong>：用来解决乱序问题等；</li> <li><strong>窗口大小</strong>：用来做流量控制；</li></ul></li></ul> <h4 id="如何唯一确定一个tcp连接呢"><a href="#如何唯一确定一个tcp连接呢" class="header-anchor">#</a> 如何唯一确定一个TCP连接呢？</h4> <ul><li>TCP 四元组可以唯一的确定一个连接，四元组包括如下：
<ul><li>源地址</li> <li>源端口</li> <li>目的地址</li> <li>目的端口</li></ul></li> <li>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</li> <li>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</li></ul> <h4 id="有一个-ip-的服务器监听了一个端口-它的-tcp-的最大连接数是多少"><a href="#有一个-ip-的服务器监听了一个端口-它的-tcp-的最大连接数是多少" class="header-anchor">#</a> 有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</h4> <ul><li>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此，客户端 IP 和 端口是可变的，其理论值计算公式如下：
<ul><li><strong>最大TCP连接数 = 客户端的IP数 x 客户端的端口数</strong></li></ul></li> <li>当然，服务端最大并发 TCP 连接数远不能达到理论上限。
<ul><li>首先主要是<strong>文件描述符限制</strong>，Socket 都是文件，所以首先要通过 <code>ulimit</code> 配置文件描述符的数目；</li> <li>另一个是<strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统是有限的。</li></ul></li></ul> <h4 id="udp和tcp有什么区别呢-分别的应用场景是"><a href="#udp和tcp有什么区别呢-分别的应用场景是" class="header-anchor">#</a> UDP和TCP有什么区别呢？分别的应用场景是？</h4> <ul><li><strong>区别</strong> <ul><li>连接
<ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li> <li>UDP 是不需要连接，即刻传输数据。</li></ul></li> <li>服务对象
<ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li> <li>UDP 支持一对一、一对多、多对多的交互通信。</li></ul></li> <li>可靠性
<ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li> <li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul></li> <li>拥塞控制、流量控制
<ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li> <li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul></li> <li>首部开销
<ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li> <li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul></li></ul></li> <li><strong>应用场景</strong> <ul><li>TCP，面向连接，保证数据可靠性交付，如FTP、HTTP/HTTPS。</li> <li>UDP，面向无连接，随时发送数据，简单高效，用于包总量较少的通信，如DNS 、SNMP、音视频多媒体通信、广播通信。</li></ul></li></ul> <h4 id="为什么udp头部没有「首部长度」字段-而-tcp-头部有「首部长度」字段呢"><a href="#为什么udp头部没有「首部长度」字段-而-tcp-头部有「首部长度」字段呢" class="header-anchor">#</a> 为什么UDP头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h4> <ul><li>原因是TCP有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</li></ul> <h4 id="为什么-udp-头部有「包长度」字段-而-tcp-头部则没有「包长度」字段呢"><a href="#为什么-udp-头部有「包长度」字段-而-tcp-头部则没有「包长度」字段呢" class="header-anchor">#</a> 为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</h4> <ul><li>TCP的负载数据长度：
<ul><li>TCP数据的长度 = IP总长度 - IP首部长度 -TCP首部长度</li></ul></li> <li>因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code>字节的整数倍。可能是为了补全UDP首部长度是 <code>4</code> 字节的整数倍，才补充了「包长度」字段。</li></ul> <h3 id="tcp连接建立"><a href="#tcp连接建立" class="header-anchor">#</a> TCP连接建立</h3> <h4 id="tcp三次握手过程和状态变迁"><a href="#tcp三次握手过程和状态变迁" class="header-anchor">#</a> TCP三次握手过程和状态变迁</h4> <ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li> <li><img src="/assets/img/image-20220121163249494.3308a272.png" alt="image-20220121163249494"></li> <li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li> <li><img src="/assets/img/image-20220121164159485.521b2e0c.png" alt="image-20220121164159485"></li> <li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li> <li><img src="/assets/img/image-20220121164240990.c3cf322d.png" alt="image-20220121164240990"></li> <li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li> <li><img src="/assets/img/image-20220121164259606.46586c09.png" alt="image-20220121164259606"></li> <li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li> <li>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</li></ul> <h4 id="如何在-linux-系统中查看-tcp-状态"><a href="#如何在-linux-系统中查看-tcp-状态" class="header-anchor">#</a> 如何在 Linux 系统中查看 TCP 状态？</h4> <ul><li>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</li></ul> <h4 id="为什么是三次握手-不是两次、四次"><a href="#为什么是三次握手-不是两次、四次" class="header-anchor">#</a> 为什么是三次握手？不是两次、四次？</h4> <ul><li>因为三次握手才能保证双方具有接收和发送的能力。此回答正确但比较片面。</li> <li>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。
<ul><li><strong>三次握手才可以阻止历史重复连接的初始化（主要原因）</strong>。
<ul><li>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下，如果是两次握手连接，客户端不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</li> <li><img src="/assets/img/image-20220201212310911.c12d3241.png" alt="image-20220201212310911"></li></ul></li> <li><strong>三次握手才可以同步双方的初始序列号</strong>。
<ul><li>两次握手只保证了一方的初始序列号能被对方成功接收，无法保证双方的初始序列号都能被确认接收。</li></ul></li> <li><strong>三次握手才可以避免资源浪费</strong>。
<ul><li>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</li></ul></li></ul></li> <li><font color="red">总结</font>：TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。
<ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li> <li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数；</li></ul></li></ul> <h4 id="为什么客户端和服务端的初始序列号-isn-是不相同的"><a href="#为什么客户端和服务端的初始序列号-isn-是不相同的" class="header-anchor">#</a> 为什么客户端和服务端的初始序列号 ISN 是不相同的？</h4> <ul><li>因为网络中的报文<strong>会延迟、会复制重发、也有可能丢失</strong>，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</li></ul> <h4 id="初始序列号-isn-是如何随机产生的"><a href="#初始序列号-isn-是如何随机产生的" class="header-anchor">#</a> 初始序列号 ISN 是如何随机产生的？</h4> <ul><li>ISN = M + F (localhost, localport, remotehost, remoteport)</li> <li>M是一个计时器，这个计时器每隔 4 毫秒加 1。</li> <li>F是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul> <h4 id="既然-ip-层会分片-为什么-tcp-层还需要-mss-呢"><a href="#既然-ip-层会分片-为什么-tcp-层还需要-mss-呢" class="header-anchor">#</a> 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4> <ul><li>MTU、MSS
<ul><li>MTU，一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li> <li>MSS，除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li> <li><img src="/assets/img/image-20220121172609816.663e4328.png" alt="image-20220121172609816"></li></ul></li> <li><strong>如果TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</strong> <ul><li>当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。</li> <li>这看起来井然有序，但这存在隐患的，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</li> <li>因为 I<strong>P 层本身没有超时重传机制</strong>，它由传输层的 TCP 来负责超时和重传。</li> <li>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</li> <li>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</li> <li>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</li> <li>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</li></ul></li></ul> <h4 id="linux-内核的-syn-未完成连接建立-队列与-accpet-已完成连接建立-队列是如何工作的"><a href="#linux-内核的-syn-未完成连接建立-队列与-accpet-已完成连接建立-队列是如何工作的" class="header-anchor">#</a> Linux 内核的 <code>SYN</code> （未完成连接建立）队列与 <code>Accpet</code> （已完成连接建立）队列是如何工作的？</h4> <ul><li><strong>正常流程</strong>：
<ul><li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</li> <li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li> <li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</li> <li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</li></ul></li> <li><strong>应用程序过慢</strong>：
<ul><li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li></ul></li> <li><strong>受到 SYN 攻击</strong>：
<ul><li>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。</li></ul></li></ul> <h4 id="什么是-syn-攻击-如何避免-syn-攻击"><a href="#什么是-syn-攻击-如何避免-syn-攻击" class="header-anchor">#</a> 什么是 <a id="SYN 攻击">SYN 攻击</a>？如何避免 SYN 攻击？</h4> <ul><li>TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</li> <li>避免 SYN 攻击方式
<ul><li>通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</li></ul> <blockquote><ul><li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：net.core.netdev_max_backlog；</li> <li>SYN_RCVD 状态连接的最大个数：net.ipv4.tcp_max_syn_backlog；</li> <li>超出处理能时，对新的 SYN 直接回 RST，丢弃连接：net.ipv4.tcp_abort_on_overflow；</li></ul></blockquote> <ul><li><code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：net.ipv4.tcp_syncookies = 1；
<ul><li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li> <li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端，</li> <li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</li> <li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</li></ul></li></ul></li></ul> <h3 id="tcp连接断开"><a href="#tcp连接断开" class="header-anchor">#</a> TCP连接断开</h3> <h4 id="tcp四次挥手过程和状态变迁"><a href="#tcp四次挥手过程和状态变迁" class="header-anchor">#</a> TCP四次挥手过程和状态变迁</h4> <ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li> <li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li> <li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li> <li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li> <li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态。</li> <li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li> <li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li> <li>注意：：<strong>主动关闭连接的，才有 TIME_WAIT 状态</strong>。</li></ul> <p><img src="/assets/img/image-20220124115057071.fd02f92e.png" alt="image-20220124115057071"></p> <h4 id="为什么挥手需要四次"><a href="#为什么挥手需要四次" class="header-anchor">#</a> 为什么挥手需要四次？</h4> <ul><li>回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。
<ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li> <li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul></li> <li>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</li></ul> <h4 id="为什么-time-wait-等待的时间是-2msl"><a href="#为什么-time-wait-等待的时间是-2msl" class="header-anchor">#</a> 为什么 TIME_WAIT 等待的时间是 2MSL？</h4> <ul><li><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</li> <li>MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</li> <li>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</li> <li>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发FIN报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</li> <li><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</li> <li>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</li></ul> <h4 id="为什么需要-time-wait-状态"><a href="#为什么需要-time-wait-状态" class="header-anchor">#</a> 为什么需要 TIME_WAIT 状态？</h4> <ul><li>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</li> <li>需要 TIME-WAIT 状态，主要是两个原因：
<ul><li>防止具有相同「四元组」的「旧」数据包被收到；</li> <li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li></ul> <blockquote><ul><li><p><strong>原因一：防止旧连接的数据包</strong></p></li> <li><p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p></li> <li><p><img src="/assets/img/image-20220124145818810.f5cacb01.png" alt="image-20220124145818810"></p></li> <li><p>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</p></li> <li><p>这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</p></li> <li><p>所以，TCP 就设计出了这么一个机制，经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</strong>。</p></li> <li><p><strong>原因二：保证连接正确关闭</strong></p></li> <li><p>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</strong>。</p></li> <li><p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p></li> <li><p><img src="/assets/img/image-20220124150127910.5add96fa.png" alt="image-20220124150127910"></p></li> <li><p>如上图红色框框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。</p></li> <li><p>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</p></li> <li><p>如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：</p> <ul><li>服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</li> <li>服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</li></ul></li> <li><p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以<strong>保证双方的连接都可以正常的关闭。</strong></p></li></ul></blockquote></li></ul> <h4 id="time-wait-过多有什么危害"><a href="#time-wait-过多有什么危害" class="header-anchor">#</a> TIME_WAIT 过多有什么危害？</h4> <ul><li>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。</li> <li>过多的 TIME-WAIT 状态主要的危害有两种：
<ul><li>第一是内存资源占用；</li> <li>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；
<ul><li>如果服务端 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</li></ul></li></ul></li></ul> <h4 id="如何优化-time-wait"><a href="#如何优化-time-wait" class="header-anchor">#</a> 如何优化 TIME_WAIT？</h4> <ul><li><p>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</p> <ul><li><code>net.ipv4.tcp_tw_reuse</code>要慎用，因为使用了它就必然要打开时间戳的支持 <code>net.ipv4.tcp_timestamps</code>，<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong>。</li></ul></li> <li><p>net.ipv4.tcp_max_tw_buckets</p> <ul><li>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接<strong>一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置</strong>。</li> <li>这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</li></ul></li> <li><p>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</p> <ul><li><p>通过设置 socket 选项，来设置调用 close 关闭连接行为。</p></li> <li><p>为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p></li> <li><div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">linger</span> so_linger<span class="token punctuation">;</span>
so_linger<span class="token punctuation">.</span>l_onoff <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
so_linger<span class="token punctuation">.</span>l_linger <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_LINGER<span class="token punctuation">,</span> <span class="token operator">&amp;</span>so_linger<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>so_linger<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，
该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。*/</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul></li></ul> <h4 id="如果已经建立了连接-但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接-但是客户端突然出现故障了怎么办" class="header-anchor">#</a> 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4> <ul><li><p>TCP 有一个机制是<strong>保活机制</strong>。即定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">//在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</span>
<span class="token comment">//也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒（7200+（75*9））才发现一个「死亡」连接。</span>

<span class="token comment">//表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</span>
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_keepalive_time<span class="token operator">=</span><span class="token number">7200</span>
    
<span class="token comment">//表示每次检测间隔 75 秒  </span>
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_keepalive_intvl<span class="token operator">=</span><span class="token number">75</span>  
    
<span class="token comment">//表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接    </span>
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_keepalive_probes<span class="token operator">=</span><span class="token number">9</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ul> <h4 id="如果开启了-tcp-保活-需要考虑以下几种情况"><a href="#如果开启了-tcp-保活-需要考虑以下几种情况" class="header-anchor">#</a> 如果开启了 TCP 保活，需要考虑以下几种情况</h4> <ul><li>对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li> <li>对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li> <li>对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li></ul> <h3 id="socket编程"><a href="#socket编程" class="header-anchor">#</a> SOCKET编程</h3> <h4 id="tcp-应该如何-socket-编程"><a href="#tcp-应该如何-socket-编程" class="header-anchor">#</a> TCP 应该如何 Socket 编程？</h4> <ul><li>需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</li> <li>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</li></ul> <p><img src="/assets/img/image-20220124155002288.d601945f.png" alt="image-20220124155002288"></p> <h4 id="listen-时候参数-backlog-的意义"><a href="#listen-时候参数-backlog-的意义" class="header-anchor">#</a> listen 时候参数 backlog 的意义？</h4> <ul><li>Linux内核中会维护两个队列：
<ul><li>未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li> <li>已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</li> <li>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列</strong>。</li></ul></li></ul> <h4 id="accept-发送在三次握手的哪一步"><a href="#accept-发送在三次握手的哪一步" class="header-anchor">#</a> accept 发送在三次握手的哪一步？</h4> <ul><li>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</li> <li><img src="/assets/img/image-20220124160652469.da96e18b.png" alt="image-20220124160652469"></li></ul> <h4 id="客户端调用-close-了-连接是断开的流程是什么"><a href="#客户端调用-close-了-连接是断开的流程是什么" class="header-anchor">#</a> 客户端调用 close 了，连接是断开的流程是什么？</h4> <ul><li>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li> <li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</li> <li>接着，当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得会发出一个 FIN 包，之后处于 LAST_ACK 状态；</li> <li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li> <li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</li> <li>客户端进过 <code>2MSL</code> 时间之后，也进入 CLOSED 状态；</li> <li><img src="/assets/img/image-20220124160837677.35548088.png" alt="image-20220124160837677"></li></ul> <h3 id="tcp状态转移"><a href="#tcp状态转移" class="header-anchor">#</a> TCP状态转移</h3> <ul><li><img src="/assets/img/image-20220121154321476.b2bd86a4.png" alt="image-20220121154321476"></li></ul> <h3 id="重传机制"><a href="#重传机制" class="header-anchor">#</a> 重传机制</h3> <h4 id="超时重传"><a href="#超时重传" class="header-anchor">#</a> <strong>超时重传</strong></h4> <h4 id="什么情况下发生超时重传"><a href="#什么情况下发生超时重传" class="header-anchor">#</a> 什么情况下发生超时重传？</h4> <ul><li>数据包丢失；</li> <li>确认应答丢失；</li></ul> <h4 id="超时时间应该设置为多少呢"><a href="#超时时间应该设置为多少呢" class="header-anchor">#</a> 超时时间应该设置为多少呢</h4> <ul><li><code>RTT</code> 就是<strong>数据从网络一端传送到另一端所需的时间</strong>，也就是包的往返时间。</li> <li>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。
<ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li> <li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul></li> <li><font color="cornflowerblue">超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</font>。</li> <li>估计往返时间，通常需要采样以下两个:
<ul><li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li> <li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li> <li>RFC6289 建议使用以下的公式计算 RTO，其中 <code>SRTT</code> 是计算平滑的RTT ，<code>DevRTR</code> 是计算平滑的RTT 与 最新 RTT 的差距。在 Linux 下，<strong>α = 0.125，β = 0.25， μ = 1，∂ = 4</strong>。别问怎么来的，问就是大量实验中调出来的。</li> <li><img src="/assets/img/image-20220125131832278.eea88467.png" alt="image-20220125131832278"></li> <li>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍</strong>。也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</strong>。</li></ul></li></ul> <h4 id="超时触发重传存在的问题"><a href="#超时触发重传存在的问题" class="header-anchor">#</a> 超时触发重传存在的问题</h4> <ul><li>超时周期可能相对较长，可以用「快速重传」机制来解决超时重发的时间等待。</li></ul> <h4 id="快速重传"><a href="#快速重传" class="header-anchor">#</a> <strong>快速重传</strong></h4> <ul><li>不以时间为驱动，而是以数据驱动重传。</li> <li>如下图，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。但是，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。</li> <li><font color="cornflowerblue">为了解决不知道该重传哪些 TCP 报文，于是就有SACK方法</font>。</li> <li><img src="/assets/img/image-20220125132547639.765e64cf.png" alt="image-20220125132547639"></li></ul> <h4 id="sack"><a href="#sack" class="header-anchor">#</a> <strong>SACK</strong></h4> <ul><li>Selective Acknowledgment 选择性确认。</li> <li>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</li> <li>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</li> <li><img src="/assets/img/image-20220125133547538.571bc1d1.png" alt="image-20220125133547538"></li> <li>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</li></ul> <h4 id="d-sack"><a href="#d-sack" class="header-anchor">#</a> <strong>D-SACK</strong></h4> <ul><li>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</strong>。</li> <li>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启/关闭这个功能（Linux 2.4 后默认打开）。</li> <li>下面举例两个栗子，来说明 <code>D-SACK</code> 的作用。
<ul><li><strong>ACK 丢包</strong> <ul><li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）。</li> <li><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500</strong>，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code>D-SACK</code>。</li> <li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li> <li><img src="/assets/img/image-20220125134059057.cf12bc8a.png" alt="image-20220125134059057"></li></ul></li> <li><strong>网络延迟</strong> <ul><li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li> <li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li> <li><strong>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包</strong>。</li> <li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li> <li><img src="/assets/img/image-20220125135017862.b6292f2d.png" alt="image-20220125135017862"></li></ul></li></ul></li></ul> <h4 id="d-sack好处"><a href="#d-sack好处" class="header-anchor">#</a> D-SACK好处</h4> <ul><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li> <li>可以知道是不是「发送方」的数据包被网络延迟了;</li> <li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ul> <h3 id="滑动窗口"><a href="#滑动窗口" class="header-anchor">#</a> 滑动窗口</h3> <ul><li><p><strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是滑动窗口的由来。</strong></p></li> <li><p>TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p></li> <li><p>有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p></li> <li><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p></li> <li><p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通话下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p></li> <li><p><img src="/assets/img/image-20220125144032383.68d60661.png" alt="image-20220125144032383"></p></li></ul> <h4 id="窗口大小由哪一方决定"><a href="#窗口大小由哪一方决定" class="header-anchor">#</a> 窗口大小由哪一方决定？</h4> <ul><li>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</li> <li>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</li> <li>所以，通常窗口的大小是由接收方的决定的。</li> <li>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</li></ul> <h4 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="header-anchor">#</a> 发送方的滑动窗口</h4> <ul><li><p>#1 是已发送并收到 ACK确认的数据：1~31 字节</p></li> <li><p>#2 是已发送但未收到 ACK确认的数据：32~45 字节</p></li> <li><p>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</p></li> <li><p>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</p></li> <li><p>程序是如何表示发送方的四个部分的呢？</p> <ul><li>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。</li> <li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li> <li><code>SND.UNA</code>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li> <li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li> <li>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul></li> <li><p><strong>可用窗口大 = SND.WND -（SND.NXT - SND.UNA）</strong></p></li></ul> <h4 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="header-anchor">#</a> 接收方的滑动窗口</h4> <ul><li><p>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</p></li> <li><p>#3 是未收到数据但可以接收的数据；</p></li> <li><p>#4 未收到数据并不可以接收的数据；</p></li> <li><p>其中三个接收部分，使用两个指针进行划分:</p> <ul><li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li> <li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li> <li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul></li></ul> <h4 id="接收窗口和发送窗口的大小是相等的吗"><a href="#接收窗口和发送窗口的大小是相等的吗" class="header-anchor">#</a> 接收窗口和发送窗口的大小是相等的吗？</h4> <ul><li>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</li> <li>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</li></ul> <h4 id="扩充窗口的方法"><a href="#扩充窗口的方法" class="header-anchor">#</a> 扩充窗口的方法？</h4> <ul><li>在 TCP 选项字段定义了窗口扩大因子，用于扩大TCP通告窗口，使 TCP 的窗口大小从 2 个字节（16 位） 扩大为 30 位，所以此时窗口的最大值可以达到 1GB（2^30）。</li> <li>Linux 中打开这一功能，需要把 tcp_window_scaling 配置设为 1（默认打开）：
<ul><li><img src="/assets/img/image-20220130002500126.e6a49534.png" alt="image-20220130002500126"></li></ul></li> <li><strong>因为网络的传输能力是有限的，当发送方依据发送窗口，发送超过网络处理能力的报文时，路由器会直接丢弃这些报文。因此，缓冲区的内存并不是越大越好。</strong></li></ul> <h4 id="如果确定最大传输速度"><a href="#如果确定最大传输速度" class="header-anchor">#</a> 如果确定最大传输速度？</h4> <ul><li>TCP 的传输速度，受制于发送窗口与接收窗口，以及网络设备传输能力。其中，窗口大小由内核缓冲区大小决定。如果缓冲区与网络传输能力匹配，那么缓冲区的利用率就达到了最大化。</li> <li>带宽时延积，它决定网络中飞行报文的大小，它的计算方式：
<ul><li>比如最大带宽是 100 MB/s，网络时延（RTT）是 10ms 时，意味着客户端到服务端的网络一共可以存放 100MB/s * 0.01s = 1MB 的字节。这 1MB 就是带宽时延积，也表示「飞行中」的 TCP 报文大小，它们就在网络线路、路由器等网络设备上。如果飞行报文超过了 1 MB，就会导致网络过载，容易丢包。</li> <li><img src="/assets/img/image-20220130002911230.aa55f4db.png" alt="image-20220130002911230"></li></ul></li> <li><strong>由于发送缓冲区大小决定了发送窗口的上限，而发送窗口又决定了「已发送未确认」的飞行报文的上限。因此，发送缓冲区不能超过「带宽时延积」。</strong> <ul><li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的网络传输，同时导致网络过载，容易丢包；</li> <li>如果发送缓冲区「小于」带宽时延积，就不能很好的发挥出网络的传输效率。</li></ul></li></ul> <h4 id="怎么调整发送缓冲区大小"><a href="#怎么调整发送缓冲区大小" class="header-anchor">#</a> 怎么调整发送缓冲区大小？</h4> <ul><li>发送缓冲区的范围通过 tcp_wmem 参数配置；
<ul><li>第一个数值是动态范围的最小值，4096 byte = 4K；</li> <li>第二个数值是初始默认值，87380 byte ≈ 86K；</li> <li>第三个数值是动态范围的最大值，4194304 byte = 4096K（4M）；</li> <li><img src="/assets/img/image-20220130003328475.7dc4deef.png" alt="image-20220130003328475"></li></ul></li> <li><strong>发送缓冲区是自行调节的</strong>，当发送方发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉</li></ul> <h4 id="调节接收缓冲区范围"><a href="#调节接收缓冲区范围" class="header-anchor">#</a> 调节接收缓冲区范围</h4> <ul><li>设置接收缓冲区范围的 tcp_rmem 参数：
<ul><li>第一个数值是动态范围的最小值，表示即使在内存压力下也可以保证的最小接收缓冲区大小，4096 byte = 4K；</li> <li>第二个数值是初始默认值，87380 byte ≈ 86K；</li> <li>第三个数值是动态范围的最大值，6291456 byte = 6144K（6M）；</li> <li><img src="/assets/img/image-20220130003645870.6775ff31.png" alt="image-20220130003645870"></li></ul></li> <li><strong>接收缓冲区可以根据系统空闲内存的大小来调节接收窗口</strong>：
<ul><li>如果系统的空闲内存很多，就可以自动把缓冲区增大一些，这样传给对方的接收窗口也会变大，因而提升发送方发送的传输数据数量；</li> <li>反正，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连接正常工作；</li></ul></li> <li>发送缓冲区的调节功能是自动开启的，<strong>而接收缓冲区则需要配置 tcp_moderate_rcvbuf 为 1 来开启调节功能</strong>：
<ul><li><img src="/assets/img/image-20220130003751707.47d00d7e.png" alt="image-20220130003751707"></li></ul></li></ul> <h4 id="调节-tcp-内存范围"><a href="#调节-tcp-内存范围" class="header-anchor">#</a> 调节 TCP 内存范围</h4> <ul><li>接收缓冲区调节时，怎么知道当前内存是否紧张或充分呢？这是通过 tcp_mem 配置完成的：
<ul><li>下面三个数字单位不是字节，而是「页面大小」，1 页表示 4KB，它们分别表示：
<ul><li>当 TCP 内存小于第 1 个值时，不需要进行自动调节；</li> <li>在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的大小；</li> <li>大于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是无法建立的；</li></ul></li> <li><img src="/assets/img/image-20220130003911225.0a593a98.png" alt="image-20220130003911225"></li> <li>一般情况下这些值是在系统启动时根据系统内存数量计算得到的。根据当前 tcp_mem 最大内存页面数是 177120，当内存为 (177120 * 4) / 1024K ≈ 692M 时，系统将无法为新的 TCP 连接分配内存，即 TCP 连接将被拒绝。</li></ul></li></ul> <h4 id="根据实际场景调节的策略"><a href="#根据实际场景调节的策略" class="header-anchor">#</a> 根据实际场景调节的策略</h4> <ul><li>在高并发服务器中，为了兼顾网速与大量的并发连接，<strong>我们应当保证缓冲区的动态调整的最大值达到带宽时延积，而最小值保持默认的 4K 不变即可。而对于内存紧张的服务而言，调低默认值是提高并发的有效手段</strong>。</li> <li>同时，如果这是网络 IO 型服务器，那么，<strong>调大 tcp_mem 的上限可以让 TCP 连接使用更多的系统内存，这有利于提升并发能力</strong>。需要注意的是，tcp_wmem 和 tcp_rmem 的单位是字节，而 tcp_mem 的单位是页面大小。而且，<strong>千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态调整功能</strong>。</li></ul> <h3 id="流量控制"><a href="#流量控制" class="header-anchor">#</a> 流量控制</h3> <ul><li>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制</strong>。</li> <li>当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。<strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间在减少缓存，这样就可以避免了丢包情况</strong>。</li></ul> <h4 id="窗口关闭"><a href="#窗口关闭" class="header-anchor">#</a> 窗口关闭</h4> <ul><li>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</li> <li>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</li> <li>窗口关闭潜在的危险：
<ul><li>如果这个通告窗口的 <code>ACK</code> 报文在网络中丢失了，那麻烦就大了。</li> <li>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不不采取措施，这种相互等待的过程，会造成了死锁的现象。</li></ul></li> <li>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？
<ul><li>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器</strong>。如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</li> <li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li> <li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li> <li>窗口探查探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</li></ul></li></ul> <h4 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="header-anchor">#</a> 糊涂窗口综合症</h4> <ul><li>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</li> <li>糊涂窗口综合症的现象是可以发生在发送方和接收方：
<ul><li>接收方可以通告一个小的窗口；</li> <li>而发送方可以发送小数据；</li></ul></li> <li>要解决糊涂窗口综合症，就解决上面两个问题就可以了：
<ul><li>让接收方不通告小窗口给发送方；</li> <li>让发送方避免发送小数据；</li></ul></li></ul> <h4 id="怎么让接收方不通告小窗口"><a href="#怎么让接收方不通告小窗口" class="header-anchor">#</a> 怎么让接收方不通告小窗口？</h4> <ul><li>当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 <code>0</code>，也就阻止了发送方再发数据过来。</li> <li>等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</li></ul> <h4 id="怎么让发送方避免发送小数据"><a href="#怎么让发送方避免发送小数据" class="header-anchor">#</a> 怎么让发送方避免发送小数据？</h4> <ul><li>使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：
<ul><li>要等到窗口大小 &gt;= <code>MSS</code> 或是 数据大小 &gt;= <code>MSS</code>；</li> <li>收到之前发送数据的 <code>ack</code> 回包。</li></ul></li> <li>Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</li> <li>可以在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</li></ul> <h3 id="拥塞控制"><a href="#拥塞控制" class="header-anchor">#</a> 拥塞控制</h3> <h4 id="为什么要有拥塞控制呀-不是有流量控制了吗"><a href="#为什么要有拥塞控制呀-不是有流量控制了吗" class="header-anchor">#</a> 为什么要有拥塞控制呀，不是有流量控制了吗？</h4> <ul><li>流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</li> <li>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大。</li> <li><strong>拥塞控制</strong>，目的就是<strong>避免「发送方」的数据填满整个网络。</strong></li></ul> <h4 id="什么是拥塞窗口-和发送窗口有什么关系呢"><a href="#什么是拥塞窗口-和发送窗口有什么关系呢" class="header-anchor">#</a> 什么是拥塞窗口？和发送窗口有什么关系呢？</h4> <ul><li><strong>拥塞窗口 cwnd</strong>是发送方维护的一个 的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</li> <li>发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</li></ul> <h4 id="拥塞窗口-cwnd-变化的规则"><a href="#拥塞窗口-cwnd-变化的规则" class="header-anchor">#</a> 拥塞窗口 <code>cwnd</code> 变化的规则</h4> <ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li> <li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul> <h4 id="怎么知道当前网络是否出现了拥塞呢"><a href="#怎么知道当前网络是否出现了拥塞呢" class="header-anchor">#</a> 怎么知道当前网络是否出现了拥塞呢？</h4> <ul><li>只要「发送方」没有在规定时间内接收到 <code>ACK</code> 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞</strong>。</li></ul> <h4 id="拥塞控制有哪些控制算法"><a href="#拥塞控制有哪些控制算法" class="header-anchor">#</a> 拥塞控制有哪些控制算法？</h4> <ul><li><strong>慢启动</strong> <ul><li>慢启动的意思就是一点一点的提高发送数据包的数量。</li> <li>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会加 1</strong>。发包的个数是<strong>指数性的增长</strong>。</li> <li>慢启动门限  <code>ssthresh</code> （slow start threshold）状态变量。
<ul><li>当 <code>cwnd &lt; ssthresh</code> 时，使用慢启动算法。</li> <li>当 <code>cwnd &gt;= ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul></li> <li><img src="/assets/img/F71O4.a4ad24a6.png" alt="img"></li></ul></li> <li><strong>拥塞避免</strong> <ul><li>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</li> <li>拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</li> <li>但一直增长后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。当触发了重传机制，也就进入了「拥塞发生算法」。</li> <li><img src="/assets/img/image-20220203133101960.25081bb3.png" alt="image-20220203133101960"></li></ul></li> <li><strong>拥塞发生</strong> <ul><li>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：
<ul><li>超时重传，则发生超时重传的拥塞发生算法。
<ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，cwnd<code>重置为</code>1；</li> <li>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</li> <li><img src="/assets/img/image-20220203133830656.636999fa.png" alt="image-20220203133830656"></li></ul></li> <li>快速重传，发生快速重传的拥塞发生算法。
<ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半，<code>ssthresh = cwnd</code>，进入快速恢复算法；</li> <li>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</li></ul></li></ul></li></ul></li> <li><strong>快速恢复</strong> <ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li> <li>重传丢失的数据包；</li> <li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li> <li>如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法。</li> <li>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</li> <li><img src="/assets/img/image-20220203133939668.561bd5e2.png" alt="image-20220203133939668"></li></ul></li></ul> <h3 id="tcp半连接与全连接"><a href="#tcp半连接与全连接" class="header-anchor">#</a> TCP半连接与全连接</h3> <h4 id="什么是tcp半连接队列和全连接队列"><a href="#什么是tcp半连接队列和全连接队列" class="header-anchor">#</a> 什么是TCP半连接队列和全连接队列？</h4> <ul><li>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：
<ul><li>半连接队列，也称 SYN 队列；</li> <li>全连接队列，也称 accepet 队列；</li></ul></li> <li>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></li> <li>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。</li> <li><img src="/assets/img/image-20220126094907885.18602bcf.png" alt="image-20220126094907885"></li></ul> <h4 id="如何知道应用程序的-tcp-全连接队列大小"><a href="#如何知道应用程序的-tcp-全连接队列大小" class="header-anchor">#</a> 如何知道应用程序的 TCP 全连接队列大小？</h4> <ul><li>在服务端可以使用 <code>ss</code> 命令，来查看 TCP 全连接队列的情况。但取的 <code>Recv-Q/Send-Q</code> 在「LISTEN 状态」和「非 LISTEN 状态」所表达的含义是不同的。</li> <li><strong>在「LISTEN 状态」时，<code>Recv-Q/Send-Q</code> 表示的含义如下图</strong>：
<ul><li>Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 <code>accept()</code> 的 TCP 连接个数；</li> <li>Send-Q：当前全连接最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务进程，最大全连接长度为 128；</li> <li><img src="/assets/img/image-20220126105723901.9d4db0bc.png" alt="image-20220126105723901"></li></ul></li> <li><strong>在「非 LISTEN 状态」时，<code>Recv-Q/Send-Q</code> 表示的含义如下图</strong>：
<ul><li>Recv-Q：已收到但未被应用进程读取的字节数；</li> <li>Send-Q：已发送但未收到确认的字节数；</li> <li><img src="/assets/img/image-20220126111755789.8202f2d9.png" alt="image-20220126111755789"></li></ul></li></ul> <h4 id="如何模拟-tcp-全连接队列溢出的场景"><a href="#如何模拟-tcp-全连接队列溢出的场景" class="header-anchor">#</a> 如何模拟 TCP 全连接队列溢出的场景？</h4> <ul><li>压测工具：<code>wrk</code>，一款简单的 HTTP 压测工具，能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，通过多线程和事件模式，对目标机器产生大量的负载。
<ul><li><img src="/assets/img/image-20220126112410338.9d4db0bc.png" alt="image-20220126112410338"></li></ul></li> <li>在服务端可以使用 <code>ss</code> 命令，来查看当前 TCP 全连接队列的情况：
<ul><li><img src="/assets/img/image-20220126112755321.0b618554.png" alt="image-20220126112755321"></li></ul></li> <li><strong>当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接</strong>，丢掉的 TCP 连接的个数会被统计起来，我们可以使用 netstat -s 命令来查看：可看到的 41150 times ，表示全连接队列溢出的次数，注意这个是累计值。可以隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。
<ul><li><img src="/assets/img/image-20220126112835869.ec3bde6a.png" alt="image-20220126112835869"></li></ul></li> <li><strong>当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。</strong></li></ul> <h4 id="全连接队列满了-就只会丢弃连接吗"><a href="#全连接队列满了-就只会丢弃连接吗" class="header-anchor">#</a> 全连接队列满了，就只会丢弃连接吗？</h4> <ul><li>实际上，丢弃连接只是 Linux 的默认行为，我们还可以选择向客户端发送 RST 复位报文，告诉客户端连接已经建立失败。
<ul><li>tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：
<ul><li>0 ：表示如果全连接队列满了，那么 server 扔掉 client  发过来的 ack ；</li> <li>1 ：表示如果全连接队列满了，那么 server 发送一个 <code>reset</code> 包给 client，表示废掉这个握手过程和这个连接；</li></ul></li></ul></li> <li>想知道客户端连接不上服务端，是不是服务端 TCP 全连接队列满的原因，那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 <code>connection reset by peer</code> 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。</li> <li>通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。
<ul><li>举个例子，当 TCP 全连接队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，进程就在建立好的连接上发送请求。只要服务器没有为请求回复 ACK，请求就会被多次<strong>重发</strong>。如果服务器上的进程只是<strong>短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接。</strong></li> <li>所以，tcp_abort_on_overflow 设为 0 可以提高连接建立的成功率，只有你非常肯定 TCP 全连接队列会长期溢出时，才能设置为 1 以尽快通知客户端。</li></ul></li></ul> <h4 id="如何增大-tcp-全连接队列呢"><a href="#如何增大-tcp-全连接队列呢" class="header-anchor">#</a> 如何增大 TCP 全连接队列呢？</h4> <ul><li>当发现 TCP 全连接队列发生溢出的时候，我们就需要增大该队列的大小，以便可以应对客户端大量的请求。</li> <li><strong>TCP 全连接队列足最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)</strong>。
<ul><li><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值；</li> <li><code>backlog</code> 是 <code>listen(int sockfd, int backlog)</code> 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；</li></ul></li> <li>如果持续不断地有连接因为 TCP 全连接队列溢出被丢弃，应调大 backlog 以及 somaxconn 参数。</li></ul> <h4 id="如何查看-tcp-半连接队列长度"><a href="#如何查看-tcp-半连接队列长度" class="header-anchor">#</a> 如何查看 TCP 半连接队列长度？</h4> <ul><li>可抓住 TCP 半连接的特点，就是服务端处于 <code>SYN_RECV</code> 状态的TCP连接，就是在 TCP 半连接队列。</li> <li><img src="/assets/img/image-20220127230742897.cca6863b.png" alt="image-20220127230742897"></li></ul> <h4 id="如何模拟-tcp-半连接队列溢出场景"><a href="#如何模拟-tcp-半连接队列溢出场景" class="header-anchor">#</a> 如何模拟 TCP 半连接队列溢出场景？</h4> <ul><li>对服务端一直发送 TCP SYN 包，但是不回第三次握手 ACK，这样就会使得服务端有大量的处于 <code>SYN_RECV</code> 状态的 TCP 连接。</li> <li>也就是所谓的 SYN 洪泛、SYN 攻击、DDos 攻击。</li> <li>实验使用 <code>hping3</code> 工具模拟 SYN 攻击。
<ul><li><img src="/assets/img/image-20220127231255350.8a5bf9e1.png" alt="image-20220127231255350"></li> <li>当服务端受到 SYN 攻击后，连接服务端 ssh 就会断开了，无法再连上。只能在服务端主机上执行查看当前 TCP 半连接队列大小：</li> <li><img src="/assets/img/image-20220127231328708.3a91f52f.png" alt="image-20220127231328708"></li> <li>同时，还可以通过 netstat -s 观察半连接队列溢出的情况：如果下面输出的数值是<strong>累计值</strong>，表示共有多少个 TCP 连接因为半连接队列溢出而被丢弃。<strong>隔几秒执行几次，如果有上升的趋势，说明当前存在半连接队列溢出的现象</strong>。</li> <li><img src="/assets/img/image-20220127231353364.eccd781c.png" alt="image-20220127231353364"></li></ul></li></ul> <h4 id="tcp-半连接队列的最大值是如何决定"><a href="#tcp-半连接队列的最大值是如何决定" class="header-anchor">#</a> TCP 半连接队列的最大值是如何决定</h4> <ul><li>半连接队列的大小并不单单只跟 <code>tcp_max_syn_backlog</code> 有关系。</li> <li>上面模拟 SYN 攻击场景时，服务端的 tcp_max_syn_backlog 的默认值如下：但是在测试的时候发现，服务端最多只有 256 个半连接队列，而不是 512，所以<strong>半连接队列的最大长度不一定由 tcp_max_syn_backlog 值决定的</strong>。</li> <li><img src="/assets/img/image-20220127233411703.3206d8a4.png" alt="image-20220127233411703"></li> <li><strong>半连接队列最大值不是单单由 max_syn_backlog 决定，还跟 somaxconn 和 backlog 有关系</strong>。
<ul><li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = min(somaxconn, backlog) * 2;</li> <li>当 max_syn_backlog &lt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = max_syn_backlog * 2;</li></ul></li> <li>每个 Linux 内核版本「理论」半连接最大值计算方式会不同。</li></ul> <h4 id="如果-syn-半连接队列已满-只能丢弃连接吗"><a href="#如果-syn-半连接队列已满-只能丢弃连接吗" class="header-anchor">#</a> 如果 SYN 半连接队列已满，只能丢弃连接吗？</h4> <ul><li>并不是只丢弃，<strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong>。</li> <li>syncookies 参数主要有以下三个值：
<ul><li>0 值，表示关闭该功能；</li> <li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li> <li>2 值，表示无条件开启功能；</li></ul></li> <li><img src="/assets/img/image-20220127234622593.f26c7122.png" alt="image-20220127234622593"></li></ul> <h4 id="如何防御-syn-攻击-syn-攻击"><a href="#如何防御-syn-攻击-syn-攻击" class="header-anchor">#</a> 如何防御[SYN 攻击](#SYN 攻击)？</h4> <ul><li>增大半连接队列；
<ul><li><strong>不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列</strong>。否则，只单纯增大 tcp_max_syn_backlog 是无效的。</li> <li>增大 tcp_max_syn_backlog 和 somaxconn 的方法是修改 Linux 内核参数：
<ul><li><img src="/assets/img/image-20220128000329047.73af1a93.png" alt="image-20220128000329047"></li></ul></li> <li>增大 backlog 的方式，每个 Web 服务都不同，比如 Nginx 增大 backlog 的方法如下：
<ul><li><img src="/assets/img/image-20220128000403415.883f314b.png" alt="image-20220128000403415"></li></ul></li> <li>最后，改变了如上这些参数后，要重启 Nginx 服务，因为半连接队列和全连接队列都是在 listen() 初始化的。</li></ul></li> <li>开启 tcp_syncookies 功能；
<ul><li>开启 tcp_syncookies 功能的方式也很简单，修改 Linux 内核参数：
<ul><li><img src="/assets/img/image-20220128000440120.f26c7122.png" alt="image-20220128000440120"></li></ul></li></ul></li> <li>减少 SYN+ACK 重传次数；
<ul><li>可以减少 SYN+ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</li> <li><img src="/assets/img/image-20220128000733541.9828bc5b.png" alt="image-20220128000733541"></li></ul></li></ul> <h3 id="tcp参数"><a href="#tcp参数" class="header-anchor">#</a> <a href="https://mp.weixin.qq.com/s/fjnChU3MKNc_x-Wk7evLhg" target="_blank" rel="noopener noreferrer">TCP参数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <h4 id="tcp三次握手性能提升"><a href="#tcp三次握手性能提升" class="header-anchor">#</a> TCP三次握手性能提升</h4> <ul><li><p><img src="/assets/img/image-20220129230432308.0bcdc607.png" alt="image-20220129230432308"></p></li> <li><p><img src="/assets/img/image-20220129231851972.ae8113b1.png" alt="image-20220129231851972"></p></li> <li><p><strong>客户端优化</strong></p> <ul><li>SYN超时重传，1+2+4+8+16+32=63 秒，大约 1 分钟左右。
<ul><li>可以根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限。比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序。</li> <li><img src="/assets/img/image-20220129225825121.1125090d.png" alt="image-20220129225825121"></li></ul></li></ul></li> <li><p><strong>服务端优化</strong></p> <ul><li>……</li></ul></li> <li><h4 id="如何绕过三次握手"><a href="#如何绕过三次握手" class="header-anchor">#</a> 如何绕过三次握手？</h4> <ul><li>在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。如下图连接建立后，这之后发起 HTTP GET 请求的时候，可以绕过三次握手，这就减少了握手带来的 1 个 RTT 的时间消耗。</li> <li><img src="/assets/img/image-20220129231552125.5864c8eb.png" alt="image-20220129231552125"></li> <li>在 Linux 系统中，可以通过<strong>设置 tcp_fastopn 内核参数，来打开 Fast Open 功能</strong>：
<ul><li>0 关闭；</li> <li>1 作为客户端使用 Fast Open 功能；</li> <li>2 作为服务端使用 Fast Open 功能；</li> <li>3 无论作为客户端还是服务器，都可以使用 Fast Open 功能；</li> <li><img src="/assets/img/image-20220129231750390.77f4137d.png" alt="image-20220129231750390"></li></ul></li></ul></li></ul> <h4 id="tcp四次挥手性能提升"><a href="#tcp四次挥手性能提升" class="header-anchor">#</a> TCP四次挥手性能提升</h4> <ul><li>客户端和服务端双方都可以主动断开连接，<strong>通常先关闭连接的一方称为主动方，后关闭连接的一方称为被动方</strong>。</li> <li><img src="/assets/img/image-20220130000933923.ee185434.png" alt="image-20220130000933923"></li> <li><strong>主动方优化</strong></li> <li><strong>被动方优化</strong></li></ul> <h4 id="tcp数据传输的性能提升"><a href="#tcp数据传输的性能提升" class="header-anchor">#</a> TCP数据传输的性能提升</h4> <ul><li><img src="/assets/img/640tcp.107e2d3d.png" alt="img"></li></ul> <h3 id="为什么弱网环境不能用tcp"><a href="#为什么弱网环境不能用tcp" class="header-anchor">#</a> 为什么弱网环境不能用tcp？</h3> <ul><li>TCP 的拥塞控制算法会在丢包时主动降低吞吐量；</li> <li>TCP 的三次握手增加了数据传输的延迟和额外开销；</li> <li>TCP 的累计应答机制导致了数据段的传输；</li></ul> <h3 id="如何在不杀掉进程前提-关闭一个-tcp-连接"><a href="#如何在不杀掉进程前提-关闭一个-tcp-连接" class="header-anchor">#</a> <a href="https://mp.weixin.qq.com/s/BVaReBOHm1vOQXsKgZ8ZSQ" target="_blank" rel="noopener noreferrer">如何在不杀掉进程前提，关闭一个 TCP 连接？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <ul><li><p>可以伪造一个四元组相同的 SYN 报文，来拿到“合法”的序列号。</p></li> <li><p>d./killcx &lt;IP地址&gt;:&lt;端口号&gt;</p></li></ul> <p><a href="https://draveness.me/whys-the-design-tcp-performance/" target="_blank" rel="noopener noreferrer">为什么TCP协议有性能问题？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>timewait是什么</p> <p>i/o多路复用是什么</p> <p>tcp/ip的连接和断开过程</p> <p>tcp 连接过程中客户端与服务端使用什么函数实现连接</p> <p>tcp怎么保证可靠传输</p> <p>tcp粘包、丢包</p> <p>tcp中间连接的时候断开会发生什么（重传、超时、等待状态、tcp可靠连接原理）</p> <p>tcp怎么传递消息</p> <p>为何tcp没有udp快？</p> <p>udp怎么实现可靠传输？</p> <p>OSI七层模型</p> <p>TCP/IP五层模型</p> <p>TCP/IP协议总结</p> <p>TCP、UDP区别</p> <p>TCP三次握手、四次挥手</p> <p>TCP状态转换</p> <p>TCP状态中TIME_WAIT</p> <p>TCP第三次握手失败会出现什么</p> <p>TCP长连接和短链接及优缺点</p> <p>TCP如何保证可靠性传输</p> <p>TCP如何解决粘包、拆包问题</p> <p>TCP为什么可靠</p> <p>Nagle算法</p> <h2 id="udp"><a href="#udp" class="header-anchor">#</a> UDP</h2> <h3 id="udp头部格式"><a href="#udp头部格式" class="header-anchor">#</a> UDP头部格式</h3> <ul><li>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（ 64 位），UDP 的头部格式如下：</li> <li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li> <li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li> <li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</li> <li><img src="/assets/img/image-20220121162000820.b8975079.png" alt="image-20220121162000820"></li></ul> <h3 id="udp中一个包的大小最大能多大"><a href="#udp中一个包的大小最大能多大" class="header-anchor">#</a> <a href="http://www.52im.net/thread-29-1-1.html" target="_blank" rel="noopener noreferrer">UDP中一个包的大小最大能多大<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <ul><li>局域网环境下，建议将UDP数据控制在1472字节以下。
<ul><li>1500(MTU)-20(IP头部大小)-8(UDP头部大小)</li></ul></li> <li>Internet编程时，建议将UDP数据控制在548字节以下。
<ul><li>鉴于Internet上的标准MTU值为576字节，所以我建议在进行Internet的UDP编程时， 最好将UDP的数据长度控件在548字节(576-8-20)以内。</li></ul></li></ul> <h3 id="什么情况会导致-udp-丢包"><a href="#什么情况会导致-udp-丢包" class="header-anchor">#</a> 什么情况会导致 UDP 丢包？</h3> <ul><li>数据报分片重组丢失：
<ul><li>UDP 协议本身规定的大小是 64kb，但是在数据链路层有 MTU 的限制，大小大概在 5kb，所以当你发送一个很大的 UDP 包的时候，这个包会在 IP 层进行分片，然后重组。这个过程就有可能导致分片的包丢失。UDP 本身有 CRC 检测机制，会抛弃掉丢失的 UDP 包；</li></ul></li> <li>UDP 缓冲区填满：
<ul><li>UDP 的缓冲区已经被填满的时候，接收方还没有处理这部分的 UDP 数据报，这个时候再过来的数据报就没有地方可以存了，自然就都被丢弃了。</li></ul></li></ul> <h3 id="可靠传输的原理"><a href="#可靠传输的原理" class="header-anchor">#</a> 可靠传输的原理</h3> <ul><li>一是基于ARQ（Automatic Repeat reQuest）的确认和重传机制。
<ul><li>ARQ包括停等式、回退N帧、选择重传等机制。由于停等式的效率太低，TCP和可靠UDP协议一般使用的是基于回退N帧机制和滑动窗口协议的连续式ARQ，TCP后来也引入了SACK，以提高性能。</li></ul></li> <li>二是使用前向纠错（FEC）。</li></ul> <h3 id="udp如何实现tcp可靠传输"><a href="#udp如何实现tcp可靠传输" class="header-anchor">#</a> UDP如何实现TCP可靠传输</h3> <ul><li><p><strong>参考：</strong></p> <ul><li><a href="https://juejin.cn/post/6844904089218711559" target="_blank" rel="noopener noreferrer">那些能替代TCP的RUDP方案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s/rCvWZwqxMBU2Z8YpaiYLrA" target="_blank" rel="noopener noreferrer">UDP如何实现TCP可靠传输<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p><font color="cornflowerblue">可靠UDP传输主要还是依靠重传机制，个别协议会用FEC作为辅助手段</font>。</p></li> <li><p>UDT(UDP-based Data Transfer Protocol)</p> <ul><li>UDT的主要目的是支持高速广域网上的海量数据传输，所以除了在UDP之上实现类似TCP的协议和算法之外，UDT还对TCP的拥塞算法做了一些细节上的调整，包括Negative-ACK(NAK)、ACK to ACK(ACK2)、基于对数的动态AIMD等。不过UDT的重传效率较低，无效报文，实际效果并不理想。</li> <li><a href="ttps://git.dorkbox.com/dorkbox/UDT/src/branch/master/src">参考实现</a></li></ul></li> <li><p>KCP</p> <ul><li>KCP是一个很简单的ARQ的实现，包括选择重传和快重传等机制，对上层提供一个可靠的字节流。应用层可以使用多流复用的框架来实现对多个流的支持。另外，KCP增加了可配置启用的加密和FEC选项，FEC用的是Reed-Solomon纠删码，例如可以配置发送10%的冗余数据，来减少丢包时需要的重传，从而降低数据传输的延时。</li> <li><a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener noreferrer">参考实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>QUIC</p> <ul><li>QUIC是Google实现的一种可靠UDP传输协议，并且已经被选择作为HTTP/3的基础。特点内建安全性，集成TLS，集成多种拥塞算法，包括最新的BBR，多流支持，连接迁移。</li> <li><a href="https://www.chromium.org/quic/playing-with-quic" target="_blank" rel="noopener noreferrer">参考实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>uTP</p> <ul><li>uTP是BitTorrent中新增加的一种UDP传输协议，主要特点是使用了LEDBAT（Low Extra Delay Background Transport）拥塞算法。这种算法基于延时来检测网络拥塞，可以更早的探测到拥塞和更早的以及更大幅度的进行避让，从而避免影响用户上网操作的进行，保持后台下载跟前台操作的和平共处。</li> <li><a href="https://github.com/bittorrent/libutp" target="_blank" rel="noopener noreferrer">参考实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>SCTP（StreamControl Transmission Protocol，流控制传输协议）</p> <ul><li>准确的说，SCTP不是一种可靠UDP协议，而是一种跟TCP/UDP平级的传输层协议，是IETF在2000年指定的标准协议。目前Linux和部分UNIX已经集成，Windows和Mac需要使用第三方包来实现。特点有跟TCP一样面向连接，提供可靠传输，跟UDP一样面向消息，多流支持，每个流可以配置成接受有序或无序的消息，可以配置多个地址，利用多条网络传输通道，更好的安全性：要求四次握手，避免TCP的SYN Flooding攻击。</li> <li>注意：webrtc的SCTP不是跟TCP和UDP平级的传输层协议，它是基于UDP的开发实现。</li> <li><a href="https://github.com/sctplab/usrsctp" target="_blank" rel="noopener noreferrer">详见webrtc代码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul> <h2 id="ping-icmp"><a href="#ping-icmp" class="header-anchor">#</a> Ping / ICMP</h2> <p><strong>参考：</strong></p> <p><a href="https://mp.weixin.qq.com/s/leE2DgDOl5z90hG2gG1Urw" target="_blank" rel="noopener noreferrer">图解Ping工作原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>ping 是基于 <code>ICMP</code> 协议工作的，所以要明白 ping 的工作，首先我们先来熟悉<strong>ICMP 协议</strong>（互联网控制报文协议）。</p> <h3 id="icmp-功能都有什么"><a href="#icmp-功能都有什么" class="header-anchor">#</a> ICMP 功能都有什么？</h3> <ul><li><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等</strong>。</li></ul> <h3 id="icmp-包头格式"><a href="#icmp-包头格式" class="header-anchor">#</a> ICMP 包头格式</h3> <ul><li>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</li> <li><img src="/assets/img/image-20220124161610624.621cb98d.png" alt="image-20220124161610624"></li> <li>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：
<ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」。
<ul><li>向对端主机发送<strong>回送请求</strong>的消息（<code>ICMP Echo Request Message</code>，类型 <code>8</code>）。</li> <li>接收对端主机发回来的<strong>回送应答</strong>消息（<code>ICMP Echo Reply Message</code>，类型 <code>0</code>）。</li></ul></li> <li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」。
<ul><li>目标不可达消息 —— 类型 为 <code>3</code>（主要有网络、主机、协议、端口不可达和需要进行分片但设置了不分片位代码为 <code>4</code>）；</li> <li>原点抑制消息 —— 类型 <code>4</code>，为了缓和在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题；</li> <li>重定向消息 —— 类型 <code>5</code>；</li> <li>超时消息 —— 类型 <code>11</code>，设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。；</li></ul></li> <li><img src="/assets/img/image-20220124161736005.13c33f65.png" alt="image-20220124161736005"></li></ul></li></ul> <h3 id="traceroute"><a href="#traceroute" class="header-anchor">#</a> traceroute</h3> <p>充分利用 ICMP <strong>差错报文类型</strong>的应用叫做 <code>traceroute</code>（在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。</p> <h4 id="traceroute-作用"><a href="#traceroute-作用" class="header-anchor">#</a> traceroute 作用</h4> <ul><li><p>通过故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</p> <blockquote><ul><li>traceroute 192.168.1.100
它的原理就是利用 IP 包的生存期限 从1开始按照顺序递增的同时发送UDP包，强制接收ICMP超时消息的一种方法。
比如，将 TTL 设置 为 1，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是时间超时。
接下来将 TTL 设置为 2，第一个路由器过了，遇到第二个路由器也牺牲了，也同意返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。
这样的过程，traceroute 就可以拿到了所有的路由器 IP。
当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。</li> <li>发送方如何知道发出的 UDP 包是否到达了目的主机呢？
taceroute 在发送 UDP 包时，会填入一个不可能的端口号值作为 UDP 目标端口号（大于 3000 ）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型「端口不可达」。
所以，当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</li></ul></blockquote></li> <li><p>通过故意设置不分片，从而确定路径的 MTU。</p> <blockquote><ul><li><p>首先在发送端主机发送 <code>IP</code> 数据报时，将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</p> <p>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</p> <p>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</p></li></ul></blockquote></li></ul> <h2 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h2> <h3 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h3> <h4 id="http-是什么-描述一下"><a href="#http-是什么-描述一下" class="header-anchor">#</a> HTTP 是什么？描述一下</h4> <ul><li>超文本传输协议；</li> <li>即HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</li></ul> <h4 id="http-的状态码-有哪些"><a href="#http-的状态码-有哪些" class="header-anchor">#</a> HTTP 的状态码，有哪些？</h4> <ul><li><em>1xx</em> <ul><li><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</li></ul></li> <li><em>2xx</em> <ul><li><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求。</li> <li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li> <li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li> <li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul></li> <li><em>3xx</em> <ul><li><code>3xx</code> 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</li> <li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li> <li>「<strong>302 Moved Permanently</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li> <li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</li></ul></li> <li><em>4xx</em> <ul><li><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</li></ul></li> <li><em>5xx</em> <ul><li><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</li></ul></li></ul> <h4 id="http常见字段有哪些"><a href="#http常见字段有哪些" class="header-anchor">#</a> HTTP常见字段有哪些？</h4> <ul><li><em>Host</em> <ul><li>客户端发送请求时，用来指定服务器的域名。</li></ul></li> <li><em>Content-Length 字段</em> <ul><li>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</li></ul></li> <li><em>Connection 字段</em> <ul><li>最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</li> <li>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</li></ul></li> <li><em>Content-Type 字段</em> <ul><li><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</li></ul></li> <li><em>Content-Encoding 字段</em> <ul><li><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</li></ul></li></ul> <h4 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> GET 和 POST 的区别？</h4> <ul><li>Get
<ul><li><code>Get</code> 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。</li></ul></li> <li>Post
<ul><li>向 <code>URI</code> 指定的资源提交数据，数据就放在报文的 body 里。</li></ul></li></ul> <h4 id="get-和-post-方法都是安全和幂等的吗"><a href="#get-和-post-方法都是安全和幂等的吗" class="header-anchor">#</a> GET 和 POST 方法都是安全和幂等的吗？</h4> <ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li> <li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li> <li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</li> <li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</li></ul> <h3 id="http特性"><a href="#http特性" class="header-anchor">#</a> HTTP特性</h3> <h4 id="http-1-1-的优点有哪些-怎么体现的"><a href="#http-1-1-的优点有哪些-怎么体现的" class="header-anchor">#</a> HTTP/1.1 的优点有哪些，怎么体现的</h4> <ul><li>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</li></ul> <h4 id="http-1-1-的缺点呢"><a href="#http-1-1-的缺点呢" class="header-anchor">#</a> HTTP/1.1 的缺点呢？</h4> <ul><li>HTTP 协议里有优缺点一体的<strong>双刃剑</strong>，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</li> <li>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</li> <li>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</li></ul> <h4 id="http-1-1-的性能如何"><a href="#http-1-1-的性能如何" class="header-anchor">#</a> HTTP/1.1 的性能如何？</h4> <ul><li>长连接
<ul><li>HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</li></ul></li> <li>管道网络传输
<ul><li>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</li> <li>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul></li> <li>队头阻塞
<ul><li>请求 - 应答」的模式加剧了 HTTP 的性能问题。</li> <li>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」。<strong>好比上班的路上塞车</strong>。</li></ul></li></ul> <h3 id="http与https"><a href="#http与https" class="header-anchor">#</a> HTTP与HTTPS</h3> <h4 id="http-与-https-有哪些区别"><a href="#http-与-https-有哪些区别" class="header-anchor">#</a> HTTP 与 HTTPS 有哪些区别？</h4> <ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li> <li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li> <li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li> <li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul> <h4 id="https-解决了-http-的哪些问题"><a href="#https-解决了-http-的哪些问题" class="header-anchor">#</a> HTTPS 解决了 HTTP 的哪些问题？</h4> <ul><li>HTTP 由于是明文传输，所以安全上存在以下三个风险：
<ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li> <li><strong>篡改风险</strong>，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li> <li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul></li> <li>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议。
<ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li> <li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li> <li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul></li></ul> <h4 id="https-是如何解决上面的三个风险的"><a href="#https-是如何解决上面的三个风险的" class="header-anchor">#</a> HTTPS 是如何解决上面的三个风险的？</h4> <ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li> <li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li> <li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul> <h4 id="https-是如何建立连接的-其间交互了什么"><a href="#https-是如何建立连接的-其间交互了什么" class="header-anchor">#</a> HTTPS  是如何建立连接的？其间交互了什么？</h4> <ul><li>SSL/TLS 协议，前两步是 SSL/TLS 的建立过程，也就是握手阶段。SSL/TLS 的「握手阶段」涉及<strong>四次</strong>通信：
<ul><li>客户端向服务器索要并验证服务器的公钥。</li> <li>双方协商生产「会话秘钥」。</li> <li>双方采用「会话秘钥」进行加密通信。</li></ul></li></ul> <h4 id="https加密过程"><a href="#https加密过程" class="header-anchor">#</a> HTTPS加密过程</h4> <h3 id="http-1-1、http-2、http-3-演变"><a href="#http-1-1、http-2、http-3-演变" class="header-anchor">#</a> HTTP/1.1、HTTP/2、HTTP/3 演变</h3> <h4 id="说说-http-1-1-相比-http-1-0-提高了什么性能"><a href="#说说-http-1-1-相比-http-1-0-提高了什么性能" class="header-anchor">#</a> 说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h4> <ul><li>HTTP/1.1 相比 HTTP/1.0 性能上的改进：
<ul><li>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li> <li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul></li> <li>但 HTTP/1.1 还是有性能瓶颈：
<ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li> <li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li> <li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li> <li>没有请求优先级控制；</li> <li>请求只能从客户端开始，服务器只能被动响应。</li></ul></li></ul> <h4 id="上面的-http-1-1-的性能瓶颈-http-2-做了什么优化"><a href="#上面的-http-1-1-的性能瓶颈-http-2-做了什么优化" class="header-anchor">#</a> 上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</h4> <ul><li>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</li> <li>那 HTTP/2 相比 HTTP/1.1 性能上的改进：
<ul><li>头部压缩。HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的分</strong>。</li> <li>二进制格式。HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，增加了数据传输的效率。头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧和数据帧</strong>。</li> <li>数据流。HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li> <li>多路复用。HTTP/2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</li> <li>服务器推送。HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</li> <li><img src="/assets/img/image-20220125111752767.99516c4e.png" alt="image-20220125111752767"></li></ul></li></ul> <h4 id="http-2-有哪些缺陷-http-3-做了哪些优化"><a href="#http-2-有哪些缺陷-http-3-做了哪些优化" class="header-anchor">#</a> HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</h4> <ul><li>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</li> <li>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。
<ul><li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li> <li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li></ul></li> <li>这都是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong>！</li> <li><img src="/assets/img/image-20220125111536844.c76a04e6.png" alt="image-20220125111536844"></li> <li>UDP 是不可靠传输的，但<font color="red">基于 UDP 的 QUIC 协议可以实现类似 TCP 的可靠性传输</font>。
<ul><li>QUIC 有一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不受到影响。</li> <li>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li> <li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code> 的三次握手。QUIC 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li> <li>QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议。QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</li> <li><img src="/assets/img/image-20220125112314477.80b7cb0f.png" alt="image-20220125112314477"></li></ul></li></ul> <h2 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h2> <p>非对称加密和对称加密算法</p> <p>IP地址和子网掩码</p> <p>ARP解析过程</p> <p>DNS原理</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/8/2022, 10:06:55 PM</span></div></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/docs/ready/4_network.html#字节序" class="sidebar-link reco-side-字节序" data-v-70334359>字节序？</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#什么是大端字节-什么是小端字节" class="sidebar-link reco-side-什么是大端字节-什么是小端字节" data-v-70334359>什么是大端字节，什么是小端字节？</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#为何要有字节序" class="sidebar-link reco-side-为何要有字节序" data-v-70334359>为何要有字节序？</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#如何判断字节序" class="sidebar-link reco-side-如何判断字节序" data-v-70334359>如何判断字节序？</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/4_network.html#tcp" class="sidebar-link reco-side-tcp" data-v-70334359>TCP</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#tcp基本认识" class="sidebar-link reco-side-tcp基本认识" data-v-70334359>TCP基本认识</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#tcp连接建立" class="sidebar-link reco-side-tcp连接建立" data-v-70334359>TCP连接建立</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#tcp连接断开" class="sidebar-link reco-side-tcp连接断开" data-v-70334359>TCP连接断开</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#socket编程" class="sidebar-link reco-side-socket编程" data-v-70334359>SOCKET编程</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#tcp状态转移" class="sidebar-link reco-side-tcp状态转移" data-v-70334359>TCP状态转移</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#重传机制" class="sidebar-link reco-side-重传机制" data-v-70334359>重传机制</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#滑动窗口" class="sidebar-link reco-side-滑动窗口" data-v-70334359>滑动窗口</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#流量控制" class="sidebar-link reco-side-流量控制" data-v-70334359>流量控制</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#拥塞控制" class="sidebar-link reco-side-拥塞控制" data-v-70334359>拥塞控制</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#tcp半连接与全连接" class="sidebar-link reco-side-tcp半连接与全连接" data-v-70334359>TCP半连接与全连接</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#tcp参数" class="sidebar-link reco-side-tcp参数" data-v-70334359>TCP参数</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#为什么弱网环境不能用tcp" class="sidebar-link reco-side-为什么弱网环境不能用tcp" data-v-70334359>为什么弱网环境不能用tcp？</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#如何在不杀掉进程前提-关闭一个-tcp-连接" class="sidebar-link reco-side-如何在不杀掉进程前提-关闭一个-tcp-连接" data-v-70334359>如何在不杀掉进程前提，关闭一个 TCP 连接？</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/4_network.html#udp" class="sidebar-link reco-side-udp" data-v-70334359>UDP</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#udp头部格式" class="sidebar-link reco-side-udp头部格式" data-v-70334359>UDP头部格式</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#udp中一个包的大小最大能多大" class="sidebar-link reco-side-udp中一个包的大小最大能多大" data-v-70334359>UDP中一个包的大小最大能多大</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#什么情况会导致-udp-丢包" class="sidebar-link reco-side-什么情况会导致-udp-丢包" data-v-70334359>什么情况会导致 UDP 丢包？</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#可靠传输的原理" class="sidebar-link reco-side-可靠传输的原理" data-v-70334359>可靠传输的原理</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#udp如何实现tcp可靠传输" class="sidebar-link reco-side-udp如何实现tcp可靠传输" data-v-70334359>UDP如何实现TCP可靠传输</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/4_network.html#ping-icmp" class="sidebar-link reco-side-ping-icmp" data-v-70334359>Ping / ICMP</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#icmp-功能都有什么" class="sidebar-link reco-side-icmp-功能都有什么" data-v-70334359>ICMP 功能都有什么？</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#icmp-包头格式" class="sidebar-link reco-side-icmp-包头格式" data-v-70334359>ICMP 包头格式</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#traceroute" class="sidebar-link reco-side-traceroute" data-v-70334359>traceroute</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/4_network.html#http" class="sidebar-link reco-side-http" data-v-70334359>HTTP</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#基本概念" class="sidebar-link reco-side-基本概念" data-v-70334359>基本概念</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#http特性" class="sidebar-link reco-side-http特性" data-v-70334359>HTTP特性</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#http与https" class="sidebar-link reco-side-http与https" data-v-70334359>HTTP与HTTPS</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/4_network.html#http-1-1、http-2、http-3-演变" class="sidebar-link reco-side-http-1-1、http-2、http-3-演变" data-v-70334359>HTTP/1.1、HTTP/2、HTTP/3 演变</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/4_network.html#其他" class="sidebar-link reco-side-其他" data-v-70334359>其他</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.4a086806.js" defer></script><script src="/assets/js/6.bd5416f2.js" defer></script><script src="/assets/js/1.01911418.js" defer></script><script src="/assets/js/3.29f4e629.js" defer></script>
  </body>
</html>
