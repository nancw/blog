<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>音视频 | NANC</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="月遇丛云 花遇和风">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.e842a6eb.css" as="style"><link rel="preload" href="/assets/js/app.4a086806.js" as="script"><link rel="preload" href="/assets/js/6.bd5416f2.js" as="script"><link rel="preload" href="/assets/js/1.01911418.js" as="script"><link rel="preload" href="/assets/js/5.61258adc.js" as="script"><link rel="prefetch" href="/assets/js/10.177c36f6.js"><link rel="prefetch" href="/assets/js/11.357b3744.js"><link rel="prefetch" href="/assets/js/12.e7b94fcd.js"><link rel="prefetch" href="/assets/js/13.0e37d2e9.js"><link rel="prefetch" href="/assets/js/14.859c0de5.js"><link rel="prefetch" href="/assets/js/15.ce68e052.js"><link rel="prefetch" href="/assets/js/16.ecee5d2f.js"><link rel="prefetch" href="/assets/js/17.fc7f4db0.js"><link rel="prefetch" href="/assets/js/18.64095822.js"><link rel="prefetch" href="/assets/js/19.91209630.js"><link rel="prefetch" href="/assets/js/20.7dddee11.js"><link rel="prefetch" href="/assets/js/21.b3e66267.js"><link rel="prefetch" href="/assets/js/22.80b12622.js"><link rel="prefetch" href="/assets/js/23.1061cbe1.js"><link rel="prefetch" href="/assets/js/24.847b82d0.js"><link rel="prefetch" href="/assets/js/25.e9197e3f.js"><link rel="prefetch" href="/assets/js/26.949f4e2b.js"><link rel="prefetch" href="/assets/js/27.b07154fe.js"><link rel="prefetch" href="/assets/js/28.6e68cc58.js"><link rel="prefetch" href="/assets/js/29.cf228bf2.js"><link rel="prefetch" href="/assets/js/3.29f4e629.js"><link rel="prefetch" href="/assets/js/30.680fc9bc.js"><link rel="prefetch" href="/assets/js/31.f00f9a6e.js"><link rel="prefetch" href="/assets/js/32.343207ba.js"><link rel="prefetch" href="/assets/js/33.2fba0807.js"><link rel="prefetch" href="/assets/js/34.3c1270c6.js"><link rel="prefetch" href="/assets/js/35.8c79ec85.js"><link rel="prefetch" href="/assets/js/36.993f3ab2.js"><link rel="prefetch" href="/assets/js/37.ffaa9a91.js"><link rel="prefetch" href="/assets/js/38.b1063472.js"><link rel="prefetch" href="/assets/js/39.d2a6438f.js"><link rel="prefetch" href="/assets/js/4.2777d27d.js"><link rel="prefetch" href="/assets/js/40.62c8dccc.js"><link rel="prefetch" href="/assets/js/41.af615c49.js"><link rel="prefetch" href="/assets/js/42.b759e61a.js"><link rel="prefetch" href="/assets/js/7.a5a22873.js"><link rel="prefetch" href="/assets/js/8.501169a5.js"><link rel="prefetch" href="/assets/js/9.6772c949.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e842a6eb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>NANC</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>月遇丛云 花遇和风</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>nanc</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="NANC" class="logo"> <span class="site-name">NANC</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/docs/" class="nav-link router-link-active"><i class="iconfont reco-document"></i>
  文档
</a></div><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="iconfont reco-blog"></i>
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-other"></i>
      关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  参考主题
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    nanc
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>29</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>17</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/docs/" class="nav-link router-link-active"><i class="iconfont reco-document"></i>
  文档
</a></div><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="iconfont reco-blog"></i>
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-other"></i>
      关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  参考主题
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/docs/" aria-current="page" class="sidebar-link">文档首页</a></li><li><section class="sidebar-group depth-0"><a href="/docs/intermediate-soft-test/1_computer_system" class="sidebar-heading clickable"><span>软件设计师</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/intermediate-soft-test/1_computer_system.html" class="sidebar-link">计算机系统</a></li><li><a href="/docs/intermediate-soft-test/2_data_structure.html" class="sidebar-link">数据结构</a></li><li><a href="/docs/intermediate-soft-test/3_operating_system.html" class="sidebar-link">操作系统</a></li><li><a href="/docs/intermediate-soft-test/4_software_engineering.html" class="sidebar-link">软件工程</a></li><li><a href="/docs/intermediate-soft-test/5_structured_development.html" class="sidebar-link">结构化开发</a></li><li><a href="/docs/intermediate-soft-test/6_network_basic.html" class="sidebar-link">网络基础</a></li><li><a href="/docs/intermediate-soft-test/7_programming_language.html" class="sidebar-link">程序设计语言</a></li><li><a href="/docs/intermediate-soft-test/8_database_design.html" class="sidebar-link">数据库</a></li><li><a href="/docs/intermediate-soft-test/9_standardized.html" class="sidebar-link">标准化与软件知识产权</a></li><li><a href="/docs/intermediate-soft-test/10_algorithm_design.html" class="sidebar-link">算法设计</a></li><li><a href="/docs/intermediate-soft-test/11_the_afternoon_of_test.html" class="sidebar-link">下午考题</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>音视频</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>nanc</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">音视频</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>nanc</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>9/1/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>学习</span><span class="tag-item" data-v-1ff7123e>音视频</span></i></div></div> <div class="theme-reco-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#流媒体相关">流媒体相关</a></li><li><a href="#传输网络">传输网络</a></li><li><a href="#网络协议">网络协议</a></li><li><a href="#封装格式">封装格式</a></li><li><a href="#编码格式">编码格式</a></li><li><a href="#opengl">opengl</a></li></ul></div><p></p> <h1 id="音视频"><a href="#音视频" class="header-anchor">#</a> 音视频</h1> <p><strong>参考：</strong></p> <ul><li><a href="https://blog.csdn.net/matrix_laboratory/article/details/71757493" target="_blank" rel="noopener noreferrer">视频花屏分析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://bbs.huaweicloud.com/blogs/138621" target="_blank" rel="noopener noreferrer">直播疑难杂症排查<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="流媒体相关"><a href="#流媒体相关" class="header-anchor">#</a> 流媒体相关</h2> <h3 id="相关术语"><a href="#相关术语" class="header-anchor">#</a> 相关术语</h3> <ul><li><strong>I帧、P帧、B帧、IDR</strong> <ul><li>一般 H.264 码流有 I、B、P 三种帧类型，I 帧是关键帧，B 帧是双向预测内插编码帧，P 帧是前向预测编码帧。</li> <li>I 帧由于是帧内压缩，因此可以独立解码播放，而 B 帧，一旦丢失了 I 帧或者后面的 P 帧，则会解码失败，而 P 帧一旦丢失了前面的 I/B/P 帧，也会导致解码失败。</li> <li>IDR（Instantaneous Decoding Refresh），即时解码刷新。</li></ul></li> <li><strong>GOP</strong> <ul><li>决定了视频的延时，**GOP 越小，延时就越小，但 GOP 小带来的问题是关键帧数量多，数据量变大，**因此，同等码率下压缩出来的视频质量就会越差。</li></ul></li> <li><strong>帧率（FPS）</strong> <ul><li>决定了视频的流畅性，帧率越高，视频越流畅，但每秒钟编码器要处理的数据量也就越大，同等码率下压缩出来的视频质量就越差。</li></ul></li> <li><strong>码率</strong> <ul><li>决定了视频被压缩的程度，码率越低，丢失的信息也就越多，画质也就越差。但是，带来的好处是占用的网络带宽会比较小，容易在互联网上传输，不容易出现卡顿。</li></ul></li> <li><strong>分辨率</strong></li> <li><strong>DTS/PTS</strong></li> <li><strong>画质</strong> <ul><li>H.264 有四种画质级别Baseline profile，Extended profile，Main profile，High profile。级别越高，压缩的效果越好，但算法复杂度更高，导致功耗也更高。</li></ul></li> <li><strong>码控方式（CBR、VBR）</strong> <ul><li>一般编码器都有固定码率（CBR） 和 动态码率（VBR） 两种码控方式，前者是指码率优先，为了保证码率尽可能稳定，会主动降低画质，因此容易出现马赛克，后者是指画质优先，会优先保证画质，减少马赛克，但码率会浮动很大。</li></ul></li> <li><strong>时间戳</strong></li> <li><strong>音频采集</strong> <ul><li>采样率。采样频率越高，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。</li> <li>位宽。每一个采样点都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit 等等，位数越多，表示得就越精细，声音质量自然就越好，而数据量也会成倍增大。我们在音频采样过程中常用的位宽是 8bit 或者 16bit。</li> <li>声道数。声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。声道数为 1 和 2 分别称为单声道和双声道。</li> <li>音频帧。为了音频算法处理/传输的方便，一般约定俗成取 2.5ms~60ms 为单位的数据量为一帧音频。这个时间被称之为「采样时间」，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的。</li></ul></li> <li><strong>冗余</strong> <ul><li>空间冗余：图像相邻像素之间有较强的相关性；</li> <li>时间冗余：视频序列的相邻图像之间内容相似；</li> <li>编码冗余：不同像素值出现的概率不同；</li> <li>视觉冗余：人的视觉系统对某些细节不敏感；</li> <li>知识冗余：规律性的结构可由先验知识和背景知识得到；</li></ul></li> <li><strong>CAVLC 和 CABAC</strong> <ul><li>两种不同的熵编码（一种无损，变长编码数据压缩方案）形式，CAVLC 效率高压缩比低，CABAC 反之；</li></ul></li> <li><strong>编码器主要流程</strong> <ul><li><img src="/assets/img/image-20220119170849237.c503b05c.png" alt="image-20220119170849237"></li></ul></li></ul> <h3 id="视频花屏的原因"><a href="#视频花屏的原因" class="header-anchor">#</a> 视频花屏的原因？</h3> <p>有以下三种原因造成的：渲染脏数据、丢帧、图像格式转换。</p> <ul><li><p><strong>渲染脏数据</strong></p> <ul><li>视频帧渲染到一半时就被送到编码器编码，此问题<strong>发生在视频渲染阶段</strong>。</li> <li>特征：
<ul><li>图像具有明显的撕裂或者错位特征；</li> <li>渲染脏数据通常不会造成持续性花屏现象；</li></ul></li> <li>产生原因与解决办法：
<ul><li>通过glReadPixels等类似方法从OpenGL获取数据，在draw和glReadPixels中间没有等待绘制完
解决方法是：在draw和glReadPixels中间调用glFinish方法。</li> <li>如果多个渲染线程通过共享纹理的方式串型工作，确认该纹理在多个线程中工作是否互斥行为。如前文提到的开辟一个渲染线程专门进行glReadPixels操作，如有这样类似行为尽量采用<strong>多缓冲机制</strong>。</li></ul></li> <li>解决此问题方法是等该帧渲染完成后在捕获渲染后的数据，同时需注意性能问题。具体方法有多缓冲：
<ul><li>加锁，最简单的方法，但是慎用会影响渲染效率</li> <li>多缓冲，这是必须的</li> <li>glFlush/glFinish，笔者的经验是普通绘制完毕后调用glFlush，在glReadPixels方法前调用glFinish。</li></ul></li> <li>一般脏数据的渲染结果不一定像下图中那么规则：
<ul><li><img src="/assets/img/image-20220118101226901.bbeaed51.png" alt="image-20220118101226901"></li></ul></li></ul></li> <li><p><strong>丢帧</strong></p> <ul><li><p>丢帧丢弃的是视频编码后的视频帧，通常发生在复用阶段。由于视频编码后帧之间存在依赖关系，丢帧会带来及其严重花屏效果，并且具有持续性影响。此问题<strong>发生在视频编码阶段</strong>。</p></li> <li><p>特征：</p> <ul><li>存粹的花屏，且花屏效果没有明显的规则型（比如撕裂、错位）；</li> <li>连续多帧存在花屏现象；</li></ul></li> <li><p>产生原因与解决办法：</p> <ul><li>视频帧时间戳（PTS）不对，由于大部分复用器都严格要求视频帧PTS是严格递增的，比如ffmpeg中mp4的Muxer如果当前帧的PTS小于或等于前一帧的PTS，那么该帧就不会被写入文件，ffmpeg会报”Invalid pts”错误。</li> <li>视频向音频同步引发丢帧。</li> <li>缓冲队列溢出。</li></ul></li> <li><p>引发此问题的原因众多，具体案例具体分析。关键是确认花屏是由于丢帧引起的，以及什么原因引发丢帧。</p></li> <li><p>常用的视频分析工具：</p> <ul><li><p>ffprobe、VideoEye。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code> ffprobe -show_frames 1_000.mp4 <span class="token operator">&gt;</span> frame.info
 <span class="token comment">#统计I帧数量</span>
 <span class="token function">cat</span> frames.info <span class="token operator">|</span> <span class="token function">grep</span> “pict_type<span class="token operator">=</span>I” <span class="token operator">|</span><span class="token function">wc</span> -l
 <span class="token comment">#统计视频帧数量</span>
 <span class="token function">cat</span> frames.info <span class="token operator">|</span> <span class="token function">grep</span> “media_type<span class="token operator">=</span>video” <span class="token operator">|</span><span class="token function">wc</span> -l
 ffprobe -show_format -show_streams filename
 
 ffmpeg -i VID20160412102008.mp4 -c:v rawvideo -pix_fmt yuv420p out.yuv
 
 <span class="token comment"># YUV &lt;-&gt; RGB</span>
 ffmpeg  -i a.bmp -pix_fmt yuv420p -y a.yuv
 ffmpeg -pix_fmt yuv420p -video_size 352x288 -i a.yuv  -y b.bmp
 
 <span class="token comment"># 预览YUV</span>
 ffplay -f rawvideo -video_size 640x480 test.yuv
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li></ul></li> <li><p><img src="/assets/img/image-20220118103926480.0722f7bd.png" alt="image-20220118103926480"></p></li></ul></li> <li><p><strong>图像格式转换</strong></p> <ul><li>在视频编解码中必然会涉及到YUV和RGB图像格式的转换，并且YUV还有多种格式。如果转换格式或者算法不正确也会引发视频花屏问题。此问题<strong>发生在视频渲染或者播放阶段。</strong></li> <li>特征：
<ul><li>由YUV与RGB图像格式转换引发的花屏现象有很多无法判断，但是有一种情况基本可以判定是由于此原因引发的：</li> <li>像的黑白数据是正常的，但是色彩不正常，比如色彩偏色、甚至错乱。</li> <li>图像整体依然处于可识别的状态，但是存在明显的彩色斑块。</li></ul></li> <li>产生原因与解决办法：
<ul><li>YUV格式错误，YUV有很多种格式，任意两种之间都都会造成转换出来的图像存在巨大差异。</li> <li>图片大小，给格式转换算法设置的宽高和图像本身存在微小差异。</li> <li>图像转换算法，不同的图像制式对应RGB与YUV转换矩阵不同，其转换的色彩也存在偏差。目前大部分采用硬件加速的技术（GPU）实现图像格式转换，不同平台可能存在差异。</li></ul></li> <li>首先把YUV数据保存下来，然后用专门的工具对其进行转换，查看转换效果，然后做进一步的分析。
<ul><li>图像的黑白数据是基本正常的，色彩混乱。可能是由于错误的图像大小引发，亦可能是由于算法不支持该图像的分辨率引起的。</li> <li>图像整体依然处于可识别的状态，但是存在明显的彩色斑块。基本确认是由于错误地识别YUV格式引起的（我很确定地告诉你，你把YUV420P和NV12搞混了）。</li></ul></li> <li><img src="/assets/img/image-20220118103223353.dab5883d.png" alt="image-20220118103223353"></li></ul></li></ul> <h3 id="播放黑屏"><a href="#播放黑屏" class="header-anchor">#</a> 播放黑屏</h3> <ul><li>现象：画面黑的，没有图像，但有声音</li> <li>从采集、编码、解码这几个模块进行排查；如播放器不支持此视频格式，具体问题具体分析。</li></ul> <h3 id="播放花屏、绿屏"><a href="#播放花屏、绿屏" class="header-anchor">#</a> 播放花屏、绿屏</h3> <ul><li>现象：播放画面出现紊乱，大面积一场颜色的方块图或者绿屏现象。</li> <li><strong>① 丢失参考帧导致的</strong> <ul><li>对于丢失了参考帧而导致的解码失败，一般就会出现花屏的现象，花屏的严重程度依赖于丢失的参考帧对即将解码的帧的重要程度。</li> <li><strong>什么情况下会丢失参考帧呢</strong> ？首先，推流/播放的代码层面，需要注意，不要丢弃编码后、解码前的视频帧数据，不过实际场景中，遇到下面的情况，难免还是会产生丢帧： 网络不好，编码后的数据发不出去系统低内存，队列里面无法承受更多的帧数据。</li> <li>因此，在这些极端的情况下，不得不丢帧的话，最合理的策略就应该是一次丢一整个 GOP，即：一旦开始丢了一个 I 帧，那么在遇到下一个 I 帧之前的所有视频帧，均丢弃掉，这样即可有效避免播放器端产生解码花屏。</li></ul></li> <li><strong>② 播放器没有从关键帧开始解码</strong> <ul><li>如果不从关键帧开始解码，则必然会由于丢失了参考信息而导致解码花屏。因此，播放器，无论是首播，还是断网重连后，都应该判断第一帧视频是否是关键帧，如果不是，则应该等到第一个关键帧到达之后再送入解码器。</li></ul></li> <li><strong>③ 码流中视频尺寸发生变化</strong> <ul><li>播放器需要实时检测，如果发现视频尺寸发生了变化，则需要重置解码器以及相关逻辑，否则容易出现解码花屏或者出现内存越界等异常。</li></ul></li> <li><strong>④ 硬编硬解的兼容性问题</strong> <ul><li>如果使用的是 Android 硬编硬解，则难免会遇到一些比较坑爹的手机，硬编硬解没有失败报错，但是输出的图像确实异常的情况。Android 硬编硬解的兼容性问题，代码上小心仔细，充分考虑机型的兼容性，不轻易写死任何参数，剩下能做的就是靠白名单/黑名单了。</li></ul></li> <li><strong>⑤ 推流端图像尺寸和格式处理不当</strong> <ul><li>图像的格式和尺寸，都是非常重要的参数，一定要严格配置正确。</li> <li>比如：如果采集到的视频是 NV21 ，编码器只支持 I420，那么编码出来的图像自然会出现颜色问题。</li> <li>比如：在一些场景切换的过程中，前后摄像头切换，视频的尺寸可能发生了变化，但是剪裁、处理、编码模块没有相应的修改尺寸，那么，也会出现各种视频错乱的现象。</li></ul></li></ul> <h3 id="播放闪屏"><a href="#播放闪屏" class="header-anchor">#</a> 播放闪屏</h3> <ul><li>闪屏问题，从根源来看，就是播放的过程中，出现了两种不同的画面来回切换，从而看起来像闪屏，比如，黑白两张图片交替渲染。</li> <li><strong>① 播放器缓冲机制原因</strong> <ul><li>网络不好的时候，播放器会频繁缓冲，曾遇到过一种案例，就是某直播 App 应用，在缓冲的时候，使用了一张广告图片，在某种极端弱网情况下，由于频繁缓冲，导致真实的播放画面和广告图片来回快速切换，导致闪屏现象。</li> <li>这个情况是完全可以从播放器的缓冲策略上避免的，每次缓冲后，不要收到一帧后就立即渲染，而是适当地多缓冲一些数据，再发送缓冲结束的消息，从而可以频繁 ms 级别的缓冲切换产生的闪屏。</li></ul></li> <li><strong>② 推流端原因</strong> <ul><li>推流端产生闪屏的流，往往发生在有画面合成的代码模块，如：叠加水印、摄像头/图片切换推流、连麦合流等等。画面的合成，一定要铭记一点，任何情况下，都要避免出现，有合成/没有合成两种画面的交替。</li></ul></li></ul> <h3 id="播放卡顿"><a href="#播放卡顿" class="header-anchor">#</a> 播放卡顿</h3> <p>现象：频繁出现缓冲；播放不够流畅，画面一卡一卡的。从代码层面来看，什么是卡顿？其实是指<strong>播放器渲染的帧率太低</strong>，比如：1s 显示 3～5 帧，或者渲染完一帧后，过很久才渲染下一帧。</p> <ul><li><strong>① 网络带宽不足</strong> <ul><li><a href="http://www.speedtest.net/" target="_blank" rel="noopener noreferrer">带宽测试工具<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、还有一些更加专业的网络性能测试工具，如 iperf。</li></ul></li> <li><strong>② 播放设备性能不足</strong> <ul><li>硬件跟不上，导致实际解码播放的帧率远小于视频码流的实际帧率，从而产生卡顿。</li> <li>尽可能选择使用硬解，充分利用 GPU 加速；如果有多种码流，尽可能在低端机上选择非高清码流；增大缓冲区，有助于缓解解码不稳定带来的卡顿。</li></ul></li> <li><strong>③ 视频流时间戳问题</strong> <ul><li>码流中的音视频时间戳出现错误，肯定会影响到播放画面的渲染时机。</li> <li>播放器一般 master 主时钟是单调递增的，当后来的视频帧小于了当前的主时钟，播放器就会做丢帧处理，从而导致播放的视频帧率远低于实际码流中的视频帧率，从而产生卡顿现象。</li></ul></li></ul> <h3 id="首开慢"><a href="#首开慢" class="header-anchor">#</a> 首开慢</h3> <ul><li>现象：点击播放后，需要好几秒才能显示播放画面。</li> <li><strong>① 点击播放后才从服务器取播放地址</strong> <ul><li>什么时候去「拿」 这个播放地址，显得至关重要，常见的做法有如下两种：App 拉取正在视频列表的时候或用户点击某个视频，跳转到播放界面之后。显然，后者的用户体验明显会比前者差，因为通过 HTTP GET 请求播放地址的过程，无形增加了首开时间，特别是在弱网下，会更慢。</li></ul></li> <li><strong>② DNS 解析慢</strong> <ul><li>不同的播放域名，DNS 解析有快有慢，再加上 DNS 解析服务的缓存策略，在本地没有该域名缓存的情况下，会逐级向更高级的域名服务器查询域名，因此，播放域名解析的耗时，会对首开产生不小的影响。</li> <li>为了有效降低 DNS 解析对首开的影响，我们可以提前完成播放域名-&gt;IP 地址的解析，并缓存起来，播放的时候，直接传入带 IP 地址的播放地址，从而省去了 DNS 解析的耗时。</li></ul></li> <li><strong>③ 播放策略原因</strong> <ul><li>很多侧重点播的播放器，为了减少卡顿，会有一些缓冲策略，当缓冲足够多的数据之后 ，再送入解码播放。而为了加快首开效果，需要对播放的缓冲策略做一些调整，如果第一帧还没有渲染出来的情况下，不要做任何缓冲，直接送入解码器解码播放，这样就可以保证没有任何因为「主动」缓冲带来的首开延时。</li></ul></li> <li><strong>④ 播放参数配置</strong> <ul><li>所有基于 ffmpeg 的播放器，都会遇到 <code>avformat_find_stream_info</code> 这个函数耗时比较久，从而增大了首开时间，该函数主要作用是通过读取一定字节的码流数据，来分析码流的基本信息，如编码信息、时长、码率、帧率等等，它由两个参数来控制其读取的数据量大小和时长，一个是 probesize，一个是 analyzeduration。</li> <li>减少 probesize 和 analyzeduration 可以有效地减少 <code>avformat_find_stream_info</code> 的函数耗时，从而加快首开，但是需要注意的是，设置地太小可能会导致读取的数据量不足，从而无法解析出码流信息，导致播放失败，或者出现只有音频没有视频，只有视频没有音频的问题。</li></ul></li> <li><strong>⑤ 服务端线路原因</strong> <ul><li>服务端的线路主要有哪些方面会影响首开呢？
<ul><li><strong>冷热流</strong>，当你去附近的边缘服务器节点拉取某个流的时候，如果最近没有任何人从该服务器拉过这个流，那么这台服务器就需要逐级向源头拉流，而且该服务器也没有任何 GOP 缓存，从而产生比较大的首开延时。</li> <li><strong>边缘节点的 TTL</strong>，同等大小的数据，客户端距离服务器越近，ttl 越小，那么传输速度也就越快，首开也会越快。</li> <li><strong>服务器的响应速度</strong>，影响服务器响应速度的因素，一个是跟服务器的协议层优化有关，另一个就是服务端的负载和性能了，服务器当前负载越大，响应自然越慢。</li></ul></li></ul></li></ul> <h3 id="延时高"><a href="#延时高" class="header-anchor">#</a> 延时高</h3> <ul><li><strong>延时测量</strong> <ul><li>一般测量延时最简单的方法，就是推流端和播放端对着同一个时钟，然后用播放端显示的时间减去推流端显示的时间，就得到了粗略的直播延时。</li></ul></li> <li><strong>延时高问题分析与优化</strong> <ul><li>一般图像处理、数据拷贝、编解码带来的延时，都是 ms 级别的，真正会产生比较大延时的地方，一个是互联网上的网络传输延时，另一个就是业务代码中的缓冲区了。
<ul><li>①  图像处理延时，比如画面剪裁、美颜、特效处理</li> <li>② <strong>视频编码/解码延时</strong> <ul><li>编码优化。确保 Codec 开启了最低延迟的设置。如果你的视频不是使用 H.264 来编码压缩的，确保没有使用到 B 帧，它对延迟也会有较大的影响，因为视频中 B 帧的解码依赖于前后的视频帧，会增加延迟。不要使用视频 MJPEG 的视频压缩格式，至少使用不带 B 帧的 MPEG4 视频压缩格式（Simple profile），甚至最好使用 H.264 baseline profile（X264 还有一个「-tune zerolatency」的优化开关）。</li> <li>编码器一般都会有码控造成的延迟，一般也叫做<strong>初始化延迟或者视频缓存检验器 VBV 的缓存大小</strong>，把它当成编码器和解码器比特流之间的缓存，在不影响视频质量的情况下可以将其设置得尽可能小也可以降低延迟。</li> <li>仅仅优化首开延迟，可以在视频帧间插入较多的关键帧，这样客户端收到视频流之后可以尽快解码。但如果需要优化传输过程中的累计延迟，尽可能少使用关键帧也就是 I 帧（GOP 变大）。在保证同等视频质量的情况下，I 帧越多，码率越大，传输所需的网络带宽越多，也就意味着累计延迟可能越大。</li> <li>尽量使用 ACC-LC Codec 来编码音频，HE-ACC 或者 HE-ACC 2 虽然编码效率高，但是编码所需时间更长，而产生更大体积的音频造成的传输延迟对于视频流的传输来说影响更小。</li> <li>如果使用了 FFmpeg，降低「-probesize 」和「 -analyze duration」参数的值，这两个值用于视频帧信息监测和用于监测的时长，这两个值越大对编码延迟的影响越大，在直播场景下对于视频流来说 analyzeduration 参数甚至没有必要设定。</li> <li>固定码率编码 CBR 可以一定程度上消除网络抖动影响，如果能够使用可变码率编码 VBR 可以节省一些不必要的网络带宽，降低一定的延迟。因此建议尽量使用 VBR 进行编码。</li></ul></li> <li>③ 网络传输延时
<ul><li>播放端离推流端或者边缘服务器节点的物理距离越近，延时会越小。</li> <li>在服务端节点中缓存当前 GOP，配合播放器端优化视频首开时间。</li> <li>服务端实时记录每个视频流流向每个环节时的秒级帧率和码率，实时监控码率和帧率的波动。</li> <li>客户端（推流和播放）通过查询服务端准实时获取当前最优节点（5 秒一次），准实时下线当前故障节点和线路。</li></ul></li> <li>④ <strong>业务代码中的缓冲区</strong> <ul><li>业务代码中的缓冲区，主要是推流端的缓冲区和播放端的缓冲区，那么，是怎么产生缓冲数据的呢？
<ul><li><strong>推流端的数据怎么「积累」起来的呢</strong> ？
<ul><li>采集 -&gt; 编码 -&gt; 数据发送 -&gt; [服务器]。</li> <li>当网络产生抖动的时候，「数据发送」会因此减慢，产生一定的阻塞，从而导致这些数据会被 「积累」在了推流端的发送缓冲区中。</li></ul></li> <li><strong>播放端的数据怎么 「积累」起来的呢</strong> ？
<ul><li>[服务器]-&gt; 数据接收 -&gt; 解码 -&gt; 渲染。</li> <li>当网络产生抖动的时候，服务器的数据无法「及时」地传输到播放端，而由于 TCP 协议的可靠性，所有的数据都会被服务端积累起来，在网络恢复良好的时候，会快速传输到播放端，这些数据会被动地 「积累」在接收缓冲区中。</li></ul></li> <li><strong>怎么消除业务缓冲区的累计延时呢</strong> ？
<ul><li>推流端的发送缓冲区，可以在网络恢复良好的时候，快送发送出去，从而消除掉这个累计延时。</li> <li>播放端的接收缓冲区，可以通过丢帧或者加速播放的方式快速消费掉缓冲区中的数据，从而消除累计延时。</li> <li><strong>在直播的稳定性和首开延迟优化上找到平衡，调整优化缓冲区大小这个值。</strong></li></ul></li></ul></li></ul></li> <li><strong>优化</strong> <ul><li>考察发送端系统自带的网络 buffer 大小，系统可能在发送数据之前缓存数据，这个参数的调优也需要找到一个平衡点。</li> <li>需要在直播的稳定性和首开延迟优化上找到平衡，调整优化缓冲区大小这个值。</li> <li>选择一个固定大小的缓存，这对亿级的移动互联网终端用户来说并不公平，他们不同的网络状况决定了这个固定大小的缓存并不完全合适。<strong>因此，我们可以考虑一种「动态 buffer 策略」，在播放器开启的时候采用非常小甚至 0 缓存的策略，通过对下载首片视频的耗时来决定下一个时间片的缓存大小，同时在播放过程中实时监测当前网络，实时调整播放过程中缓存的大小</strong>。这样即可做到极低的首开时间，又可能够尽量消除网络抖动造成的影响。</li></ul></li></ul></li></ul></li> <li><strong>协议延时</strong> <ul><li>通常标准的直播协议有 RTMP，HLV，HLS 三种，一般 RTMP/HLV 协议的延时在 1～3s，HLS 协议的直播延时则会更大，注重延时的直播应用，大都会选择 RTMP/HLV 协议，这些协议均是基于 tcp 的协议，tcp 协议的多个特性导致其延时明显要高于基于 udp 的私有协议，，主要有如下方面：
<ul><li>建立连接的三次握手</li> <li>ACK 机制</li> <li>丢包重传</li></ul></li> <li>**如果想从本质上解决直播延时问题，还是要换成基于 udp 的私有协议来传输数据。**省去弱网环节下的丢包重传可以降低延迟。它的主要缺点在于，基于 UDP 协议进行定制的协议的视频流的传输和分发不够通用，CDN 厂商支持的是标准的传输协议。另一个缺点在于可能出现丢包导致的花屏或者模糊（缺少关键帧的解码参考），这就要求协议定制方在 UDP 基础之上做好丢包控制。</li></ul></li></ul> <h3 id="音画不同步"><a href="#音画不同步" class="header-anchor">#</a> 音画不同步</h3> <ul><li>现象：画面与声音的不匹配。</li> <li>如果内容的生产端给音视频数据打的时间戳本身就有问题的话，播放器也往往无能为力了，因此，音画不同步问题，更多的时候，应该从生产端去排查原因。</li> <li><strong>采集源距离太远</strong> <ul><li>音频源离麦克风距离太远，声音传播到麦克风的速度远小于画面（光速），那么，摄像头采集到画面后给出的时间戳，肯定要远小于麦克风采集到同一时刻音频给出的时间戳，因此会产生音画不同步问题。</li> <li>解决方案：音频源尽可能离麦克风设备近一点。</li></ul></li> <li><strong>采集设备内部问题</strong> <ul><li>摄像头和麦克风采集音视频，在硬件上都会经过一些信号处理模块，如果处理延时不稳定，则会导致输出数据的时间不稳定，从而导致应用层获取时间戳的时候产生误差，带来音画不同步问题。</li> <li>解决方案：极少数硬件/机型才会有，需要根据采集参数（如采样率）做一些 Jitter 抖动的矫正。</li></ul></li> <li><strong>时间戳没有在采集的时候获取</strong> <ul><li>如果音视频帧的时间戳不是在采集的时候获取，而是在后续的某个环节再获取，则非常大概率地会出现音视频不同步问题。</li> <li>一般大家会「不慎」在哪些地方更改了采集的时间戳？
<ul><li>音视频算法处理模块。视频经过美颜、编码后，重新更新为了处理后的的时间戳。</li> <li>缓冲区导致的不同步。多线程程序中，往往会在不同线程之间共享一些帧缓冲区，缓冲区会导致音视频对应关系发生变化，如果从缓冲区取数据后，抛弃掉了原有的时间戳，重新使用新的当前时间，那么，肯定会出现问题。</li> <li>网络传输导致的不同步。由于网络的传输的延时、丢包等原因，同一时刻的音视频包不会正好同时准确到达，如果在接收到了数据后再打上当前的时间戳，肯定也会出现不同步问题。</li></ul></li></ul></li> <li><strong>时间戳出现回退或者紊乱</strong> <ul><li>码流的时间戳没有单调递增，而是频繁出现了回退，这样的流，会导致播放器出现频繁卡顿，因为播放器的 master 主时钟一般是单调递增的，当出现小于主时钟的视频帧后，一般会做丢弃处理，画面不更新但是音频还是在继续播放，从而导致看起来声音和画面并没有匹配上的问题。</li> <li>解决方案：排查推流端时间戳是否单调线性递增，或者排查服务端是否有对流的时间戳有过修改导致回退。</li></ul></li> <li><strong>播放端性能问题</strong> <ul><li>比如低端机型软解 1080P 的高清码流，会存在解码不够及时的问题，导致部分视频解码完成后，已经远慢于当前的音频时钟，只能丢弃，从而导致画面更新不及时，与正在播放的音频无法匹配上，从而产生音画不同步的现象。</li> <li>解决方案：使用硬解，选择较低清的码流，增大播放缓冲，等等。</li></ul></li></ul> <h3 id="马赛克严重"><a href="#马赛克严重" class="header-anchor">#</a> 马赛克严重</h3> <ul><li>现象：主要是指画面中出现多处类似小方块的图像，导致画面的局部或者整体看不清楚的情况。</li> <li><strong>视频编码参数配置原因</strong> <ul><li><strong>哪些关键因素决定了编码器的压缩质量呢 ？</strong> <ul><li><strong>编码器最重要的五个参数：画质级别、码率、帧率、GOP 大小、码控方式</strong>。</li> <li>当然，还有一个重要的因素，就是编码器本身的实现质量，软编一般可以保证在不同手机上效果一致，而硬编则完全依赖手机所使用的硬件平台了。</li> <li><strong>推荐的编码器参数配置</strong>，一般画质级别采用的是 Baseline profile，GOP 通常设置为 1～3s，帧率一般在 15～24 帧，而码率的配置，则需要根据推流的分辨率来决定。总之，<strong>送入编码器的数据量越大，编码压缩得越「厉害」，丢失的图像信息也就越多，数据解码后的产生马赛克也就越「厉害」。</strong></li> <li><img src="/assets/img/image-20220119153636285.006a2c4d.png" alt="image-20220119153636285"></li></ul></li></ul></li> <li><strong>图像尺寸原因</strong> <ul><li>小尺寸的画面（比如：640 x 480），拉伸到大的尺寸（比如：1280 x 720），则很容易会产生模糊和马赛克，这样的画面再送入编码器中编码，无论怎样配置都无法再改善已经产生的马赛克了。</li> <li>为了降低马赛克，我们必须要保证，摄像头采集的分辨率，一定要大于最终推流的分辨率。</li></ul></li> <li><strong>客观条件原因</strong> <ul><li>在光线非常暗的环境下，本身送入编码器的图像质量也不会特别好，因此，同等条件下马赛克也会相对严重些。如果拍摄的是剧烈晃动的画面，剧烈变化的画面信息量也要大很多，因此，编码的复杂度会明显增大，如果要保证码率不会浮动太大，就必然要降低输出的图像质量，从而产生马赛克现象。</li> <li>为了降低马赛克，可以考虑适当将编码参数配置得「高」 一点（比如：码率高一点，帧率低一点等等），留出充分的 「富余」空间，以抵抗环境因素带来的影响。</li></ul></li> <li><strong>关键帧丢失</strong> <ul><li>于视频流中丢失了关键帧，导致播放器解码后花屏，从现象来看有点像马赛克，但实际上跟上面讨论的不是同一个问题。</li></ul></li></ul> <h3 id="播放杂音、噪声、回声"><a href="#播放杂音、噪声、回声" class="header-anchor">#</a> 播放杂音、噪声、回声</h3> <ul><li>常见的音频问题描述：
<ul><li>电流音，爆音，滋滋声或者嘟嘟声。</li> <li>声音断断续续，听不清楚。</li> <li>回声，能听到自己说话的声音。</li></ul></li> <li>问题排查：
<ul><li>参数配置问题
<ul><li>无论是采集和播放，都要给系统的 API 及第三方的库配置正确参数，如：采样率、位宽、声道数等。</li></ul></li> <li>代码层面原因
<ul><li>音频 buffer 大小不匹配，一段 1024 bytes 的音频，放到了 2048 bytes 的数组，导致尾部有随机数。</li> <li>音频 resample 重采样的算法问题，导致采样出来的数据出了问题。</li> <li>Android 的 ByteBuffer 取出数组，是不能直接用 .array() 方法的，而需要用 .get() 方法</li> <li>iOS 系统，其他 app 通过系统 API 更改了 AudioSession 采样率的配置。</li></ul></li> <li>网络波动
<ul><li>音频是流式的，虽然也被切分为了一个个音频帧，但如果无法按时播放或者连续丢失较多的音频帧，则会明显听到断断续续的声音出现。特别是在弱网、丢包率高等不稳定网络环境下，很容易出现这种情况。</li></ul></li> <li>回音消除
<ul><li>同时有音频的采集和播放的场景，比如：连麦互动、混音返听等等，采集到的音频通过扬声器又播放出来了，同时又被采集了进去，从而产生了回声或者啸叫声。</li> <li>一般需要通过系统的回声消除 API，或者第三方回声消除库（如：speexdsp，webrtc 等）进行处理。</li></ul></li> <li>混音越界
<ul><li>音频的 PCM 数据，通常用 short 数组来存放，当我们做一些多路音频的混音功能的时候，如果不注意处理 short 类型的大小越界，则往往带来爆音的问题。</li></ul></li></ul></li></ul> <h3 id="点播拖动不准"><a href="#点播拖动不准" class="header-anchor">#</a> 点播拖动不准</h3> <ul><li>现象：播放过程中，拖动进度条后，实际播放的位置跟松开拖动时的位置相差很远。</li> <li>问题排查
<ul><li><strong>关键帧间隔太大</strong> <ul><li>为了更准确地支持拖动，建议不要把关键帧间隔设置得太大。</li></ul></li> <li><strong>直播丢帧</strong> <ul><li>丢帧的情况多发生在直播场景，由于主播端的网络抖动或者内存不足，导致不得不被迫丢掉一些视频帧，而为了保证客户端解码后不出现花屏，丢帧往往伴随着一整个 GOP 的丢弃。当 GOP 丢失后，部分关键帧的间隔时间点就会变得更大了，从而导致拖动不准。</li> <li>为了避免这种情况，建议推流端开启动态码率，在网络不好的时候，主动降低码率，快速发送掉缓冲区中累积的视频帧，从而减少丢帧的情况发生。</li></ul></li></ul></li></ul> <h3 id="直播关键性能指标"><a href="#直播关键性能指标" class="header-anchor">#</a> 直播关键性能指标</h3> <ul><li><strong>首开时间</strong>。以映客为例，在视频列表中随意点开某个视频，它的打开时间最好控制在 1 秒内。</li> <li><strong>累计延迟</strong>。视频观看与事件实际发生时间相距不能超过 3 秒，最好控制在1 秒内。</li> <li><strong>卡顿</strong>。在不同的码率和分辨率情况下，都能够做到让用户流畅地观看视频。</li> <li><strong>高可用</strong>。节点和线路是足够冗余的，并且不会有太大浪费；当节点或者线路出现故障时，可以通过快速的切换来恢复，这样不影响终端用户的体验。</li> <li><strong>低成本</strong>。</li></ul> <h3 id="播放性能优化"><a href="#播放性能优化" class="header-anchor">#</a> 播放性能优化</h3> <ul><li><strong>首开延迟优化</strong> <ul><li>通常会在服务端缓存一个 GOP，并且让它的第一帧尽量是 I 帧，这样客户端播放器配合拿到第一个 GOP 数据后即可立即解码播放，不需要等待。</li></ul></li> <li><strong>累计延迟消除优化：网络抖动</strong> <ul><li>播放控制需要通过缓存来消除累计延迟。对于首开延迟来说，缓存越小越好，即拿到数据最好可以直接播放。但是，网络会产生抖动。因此，为了消除网络抖动带来的影响，我们需要在播放器端做一系列 Buffer，尽管 Buffer 会影响首开时间，但存在必要性，因此如何去平衡是优化的关键。</li> <li>此外，视频信息中的 B 帧和 P 帧都是参考帧，它们没有包含视频的全量信息，在解码播放的时候它们都需要参考关键帧中的全量信息进行解码。B 帧是压缩效率最高的数据帧，但它解码时需要同时参考前后的 I 帧，即从拿到数据到正常播放需要等数帧时间，会带来较大延迟。因此，除非网络或者解码性能非常好，否则可以采取直接去掉 B 帧，以加快解码，降低整体的延迟。</li></ul></li> <li><strong>卡顿率优化</strong> <ul><li>产生卡顿感的原因有多种，主要包括由于带宽不足和 I 帧不足带来的卡顿感。其中，带宽不足在推流端、传输端和播放端都可能发生，推流端的带宽不足导致推流 FPS 下降，导致整体用户推流和播放卡顿，传输端带宽不足导致所有播放用户卡顿，播放端带宽不足导致当前观看用户卡顿。而 I 帧不足即 GOP 太大，则会导致解码播放过程中<strong>所需关键帧到达的速度跟不上播放器解码和播放速度</strong>。</li> <li>自适应播放只是卡顿优化的一部分内容。如七牛云采用的HTTP自适应播放的方式。</li></ul></li></ul> <p>ffplay音视频同步的做法</p> <p>流媒体播放器框架</p> <p>音视频切换多线程怎么处理帧切换问题</p> <p>怎么设置压缩码率</p> <p>边下边播用什么协议</p> <p>yuv和rgb格式的区别</p> <p>yuv采用格式</p> <p>视频播放器缓冲机制</p> <p>怎么设计视频播放器暂停，后端如何处理，进度条如何显示</p> <h2 id="传输网络"><a href="#传输网络" class="header-anchor">#</a> 传输网络</h2> <p><strong>参考：</strong></p> <p><a href="https://mp.weixin.qq.com/s/CxInQgq-LeWdzXlgkNG9lg" target="_blank" rel="noopener noreferrer">推流和传输<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="弱网模拟测试工具"><a href="#弱网模拟测试工具" class="header-anchor">#</a> 弱网模拟测试工具</h3> <ul><li>Linux Traffic Control(TC)</li> <li>Augmented Traffic Control（<a href="https://github.com/facebook/augmented-traffic-control" target="_blank" rel="noopener noreferrer">ATC<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</li> <li><a href="https://github.com/jagt/clumsy" target="_blank" rel="noopener noreferrer">clumsy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://iperf.fr/iperf-doc.php" target="_blank" rel="noopener noreferrer">iperf<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li><a href="https://www.cnblogs.com/wuling129/p/4795262.html" target="_blank" rel="noopener noreferrer">网络性能评估工具Iperf详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><a href="https://www.speedtest.cn/" target="_blank" rel="noopener noreferrer">speedTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="传统cdn架构"><a href="#传统cdn架构" class="header-anchor">#</a> 传统CDN架构</h3> <ul><li>节点是 CDN 系统中的最基本部署单元，分为三级部署，中心节点、区域节点和边缘节点，最上面一级是中心节点，中间一级是区域节点，边缘节点地理位置分散，为用户提供就近的内容访问服务。</li> <li><img src="/assets/img/image-20220119172311249.79241dac.png" alt="image-20220119172311249"></li> <li><strong>CDN节点分类</strong> <ul><li>骨干节点，主要负责内容分发和边缘节点未命中时进行回源。
<ul><li>中心节点；</li> <li>区域节点；如果 CDN 网络规模较大，边缘节点直接向中心节点回源会给中间层的核心设备造成的压力过大，在物理上引入区域节点，负责一个地理区域的管理，保存部分热点数据。</li></ul></li> <li>POP节点，主要负责提供给用户就近的内容访问服务。
<ul><li>边缘节点；</li></ul></li></ul></li></ul> <h3 id="直播传输网络"><a href="#直播传输网络" class="header-anchor">#</a> 直播传输网络</h3> <ul><li>要求
<ul><li>去中心化，网状拓扑
<ul><li>网状拓扑结构是设计的根本和基础，只有看清了我们对 Cache 需求降低，网状拓扑结构才更有优势。</li></ul></li> <li>全球全网调度
<ul><li>不在受限于区域网络调度，将调度的范围从区域网络扩展到全球，全网内的节点都可以响应用户的请求，参与链路路由，不再先由人工假设选定一部分节点进行路由，去掉人工干预，让整个系统更智能。</li></ul></li> <li>节点无状态，节点对等</li> <li>智能运维</li></ul></li></ul> <h2 id="网络协议"><a href="#网络协议" class="header-anchor">#</a> 网络协议</h2> <h3 id="webrtc"><a href="#webrtc" class="header-anchor">#</a> webrtc</h3> <p><img src="/assets/img/image-20211122135114042.6fe84e5d.png" alt="image-20211122135114042"></p> <p><strong>参考链接：</strong><a href="https://mp.weixin.qq.com/s/XV0aZLgOeKEOFJ5cOh79Ww" target="_blank" rel="noopener noreferrer">李超：WebRTC传输与服务质量<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="webrtc三种开源方案-架构"><a href="#webrtc三种开源方案-架构" class="header-anchor">#</a> webrtc三种开源方案，架构？</h4> <p>MCU、SFU、Mesh</p> <h4 id="实时通信延时指标"><a href="#实时通信延时指标" class="header-anchor">#</a> 实时通信延时指标？</h4> <p><img src="/assets/img/image-20210923112214745-16372870921511.1405cc86.png" alt="image-20210923112214745"></p> <h4 id="视频服务质量指标"><a href="#视频服务质量指标" class="header-anchor">#</a> 视频服务质量指标？</h4> <p><img src="/assets/img/image-20210923112249972-16372870921522.c6b1267e.png" alt="image-20210923112249972"></p> <h4 id="音频服务质量指标"><a href="#音频服务质量指标" class="header-anchor">#</a> 音频服务质量指标?</h4> <p><img src="/assets/img/image-20210923112232755-16372870921523.3c3a671f.png" alt="image-20210923112232755"></p> <h4 id="保障数据传输的实时性"><a href="#保障数据传输的实时性" class="header-anchor">#</a> 保障数据传输的实时性？</h4> <h5 id="如何保障数据传输的实时性"><a href="#如何保障数据传输的实时性" class="header-anchor">#</a> 如何保障数据传输的实时性？</h5> <ul><li><p>① 一种是传输路径的选择，它首先会选择最佳的传输路径，使得端到端传输时采取最好、最短的传输路径从而保障数据传输的实时性；</p></li> <li><p>② 另一种是传输协议的选择，可以选择TCP或者UDP；</p> <ul><li>在网络比较优质时，TCP/UDP都可以用于实时传输，但大多数情况下，我们首选UDP（后面会介绍UDP的优势）；弱网环境下不能使用TCP；而在进行网络穿越时，使用TCP又有较大的好处，在企业内可以使用TCP访问外网的80端口进行穿透。</li></ul></li></ul> <h5 id="为什么在弱网环境下不能用tcp"><a href="#为什么在弱网环境下不能用tcp" class="header-anchor">#</a> 为什么在弱网环境下不能用TCP？</h5> <ul><li>这是由于TCP的机制所造成的。TCP的机制是发送、确认、丢包、重传。正常情况下，数据从一端传输到另一端是没有任何问题的，但当出现丢包时就会有较大的麻烦。</li> <li>由于TCP有退避机制，以防止频繁发送丢失包，因此会将重发包的超时时间延长到400ms。如果重发包依然没有收到确认消息，则下一次重发的超时时间会延长到800ms。</li></ul> <h5 id="选择udp带来的问题"><a href="#选择udp带来的问题" class="header-anchor">#</a> 选择UDP带来的问题？</h5> <ul><li>由于UDP是不可靠传输，它只能尽力送达，所以出现丢包、乱序是常见的事儿，但对于网络质量来说，丢包是非常严重的事情，这就需要我们自己处理这个问题。</li></ul> <h4 id="如何提高网络质量"><a href="#如何提高网络质量" class="header-anchor">#</a> 如何提高网络质量？</h4> <h5 id="影响网络质量的因素"><a href="#影响网络质量的因素" class="header-anchor">#</a> 影响网络质量的因素？</h5> <ul><li>丢包率；</li> <li>延迟时间；</li> <li>抖动；</li> <li>乱序；</li></ul> <h5 id="丢包"><a href="#丢包" class="header-anchor">#</a> 丢包</h5> <h6 id="造成丢包的原因"><a href="#造成丢包的原因" class="header-anchor">#</a> 造成丢包的原因？</h6> <ul><li>链路质量差、带宽满、主动丢包、光纤被挖断等；</li></ul> <h6 id="减少丢包的方法"><a href="#减少丢包的方法" class="header-anchor">#</a> 减少丢包的方法？</h6> <ul><li>WebRTC主要通过两种方式解决丢包：<code>NACK</code>和<code>FEC</code>。</li></ul> <h6 id="nack的作用"><a href="#nack的作用" class="header-anchor">#</a> NACK的作用？</h6> <ul><li><code>NACK</code>的作用是丢包重传。从图中你可以看到，WebRTC的发送端不停地向接收端发送RTP包，接收端每隔一小段时间，就对这段时间内的丢包情况进行统计。如果发现丢包，它会给发送端回一个<code>NACK</code>消息，<code>NACK</code>消息中记录了这一段时间内哪些包丢失了。发送端收到<code>NACK</code>后，会在之前的发送历史记录中找到丢失的包并重新发送。</li> <li><img src="/assets/img/image-20210923112137580-16372870921524.b7913a03.png" alt="image-20210923112137580"></li></ul> <h6 id="nack适合使用的场景"><a href="#nack适合使用的场景" class="header-anchor">#</a> NACK适合使用的场景?</h6> <ul><li><p><img src="/assets/img/image-20210923112559010-16372870921695.c527126d.png" alt="image-20210923112559010"></p></li> <li><p>当然，通过<code>NACK</code>重传，会产生一定的延时，该延时包括：等待发送<code>NACK</code>的时间（10或20ms），<code>NACK</code>经过网络的时延以及RTP的网络时延和重传RTP包的网络时延，即1.5RTT+10或20ms。通过这个公式我们可以知道，如果RTT时延比较大，比如200ms，那么1.5RTT就是300ms。通过前面讲述的实时传输延时指标我们可以知道，端到端实时传输的时延需要控制在500ms之内，如果仅数据的网络传输就占了300ms，那数据再经过采集、编码、解码、渲染等流程，这些处理时间加在一起很有可能就超过500ms。</p></li> <li><p>所以可以得出结论，<strong>丢包重传仅适用于网络传输时延比较小的情况，如果RTT比较大时，就不适合使用丢包重传来保障网络质量了</strong>。</p></li></ul> <h6 id="fec的作用"><a href="#fec的作用" class="header-anchor">#</a> FEC的作用？</h6> <ul><li><p><img src="/assets/img/image-20210923112809564-16372870921696.e272a66a.png" alt="image-20210923112809564"></p></li> <li><p><code>FEC</code>的作用是通过冗余数据解决丢包。实际上，它就是<strong>一个异或操作</strong>。如图所示，假设传输的数据是Data1和Data2，这两个数据如果在传输的过程中没有FEC进行保护，其中一个数据丢失了，那只能通过<code>NACK</code>重新找回。那么，能否在传输过程中加一些冗余数据，以保证接收时，当某一个数据丢失后，不经过重传就可以将丢失的包找回来呢？这就是<code>FEC</code>。</p></li> <li><p>在图中我们可以看到，Data1和Data2同时发送到对端，在发送时对它们做一下异或操作，即Data1的最后一位0与Data2的最后一位0异或为0，Data1的倒数第二位1与 Data2的倒数第二位1异或为0，依次类推，最后就产生了冗余数据R，同时将三个包从一端传输到另一端。传输过程中，如果Data1丢失，通过Data2和冗余包R就可以将Data1找回来。找回包的算法也是异或操作，即在接收端将Data2的每一位与冗余包中的相同位进行异或操作就算出了Data1。这就保证了不用重新请求，就将丢失包找回的作用。</p></li> <li><p>而且异或具有传递性，A、B、C三个包可以同时异或得到D，如果其中任意一个包丢失，可以通过D和其它包找回丢失的包。</p></li></ul> <h6 id="ulpfec"><a href="#ulpfec" class="header-anchor">#</a> ULPFEC?</h6> <ul><li><p><img src="/assets/img/image-20210923112941643-16372870921697.7d1e509c.png" alt="image-20210923112941643"></p></li> <li><p>对于WebRTC来说，它默认使用的是ULPFEC。其原理是，将要传输的数据包先进行分组，如将三个包分为一组，然后为这一组包产生一个冗余包，如果这一组中某个包丢失了，就可以通过冗余包和其它包的异或操作将其找回。从图中第一行可以看到1和2到了，3丢了，通过R1可以找回3，第三行同样可以找回9。其缺点是，如果连续的两个包都丢失了，这种算法就失效了，比如第二行4和5丢失后，通过6和R2无法找回它们。</p></li></ul> <h6 id="flexfec"><a href="#flexfec" class="header-anchor">#</a> FlexFEC?</h6> <ul><li><p><img src="/assets/img/image-20210923112952126-16372870921698.920f331c.png" alt="image-20210923112952126"></p></li> <li><p>于是就有了改进的FlexFEC，它做了双向冗余处理，不仅横向做了冗余，而且纵向也做了冗余。</p></li> <li><p>此时，当4和5同时丢失时，通过1、7和C1可以找到4，2、8和C2可以找到5，这样就可以找回连续的两个丢包。当然它也有弊端，其弊端是无法处理批量的连续丢包，例如连续丢失了10个包，FlexFEC对这种情况也无能为力。</p></li> <li><p>以上就是WebRTC对于丢包的解决方法，通过<code>NACK+FEC</code>防止丢包。</p></li></ul> <h6 id="ulpfec和flexfec区别是"><a href="#ulpfec和flexfec区别是" class="header-anchor">#</a> ULPFEC和FLEXFEC区别是？</h6> <ul><li><code>ULPFEC</code>只能进行单向冗余处理，而<code>FLEXFEC</code>可以进行双向冗余处理，即可以横向分组还可以纵向分组做冗余，所以它的抗丢包性要比<code>ULPFEC</code>好，同时占的带宽也比<code>ULPFEC</code>多。</li></ul> <h5 id="如何解决抖动和乱序"><a href="#如何解决抖动和乱序" class="header-anchor">#</a> 如何解决抖动和乱序？</h5> <h6 id="抖动"><a href="#抖动" class="header-anchor">#</a> 抖动</h6> <ul><li><p>抖动的意思是，一会儿来了很多包，一会儿又一个没有，包是一波一波的来，包到达的时间很不平均；</p></li> <li><p>WebRTC处理抖动和乱序使用的是**<code>JitterBuffer</code>和<code>NetEQ</code>**。<code>JitterBuffer</code>用于处理视频包，<code>NetEQ</code>用于处理音频包。它们的原理大致相同（<code>NetEQ</code>更为复杂一些），都是通过一个队列（缓存区）对接收到的数据做下缓冲，然后再从队列的另一端将数据包一个个均匀的取出， 这样取出的数据就是平滑的了。</p></li></ul> <h6 id="乱序"><a href="#乱序" class="header-anchor">#</a> 乱序</h6> <ul><li><p>乱序指的是，先发的包后到了，后发的包先到了；</p></li> <li><p>乱序的处理也比较好解决，如图中所示，每个RTP包进来的时候有一个序号（Sequence Number），在数据进入队列时，它会根据序号插到对应的位置上，比如图中104、107包已经到达，并且在对应的位置上，而103、105和106没来，位置就空着，等它们来了再插入对应的位置，这样就可以防止乱序，所以通过<code>JitterBuffer</code>和<code>NetEQ</code>就可以同时解决乱序和抖动了。</p></li> <li><p><strong>总结一下，<code>NACK</code>和<code>FEC</code>解决丢包问题，<code>NACK</code>会增加时延，<code>FEC</code>会占用带宽。<code>JitterBuffer</code>解决视频的乱序与抖动，<code>NetEQ</code>解决音频的乱序与抖动</strong>。</p></li></ul> <h6 id="时延"><a href="#时延" class="header-anchor">#</a> 时延</h6> <ul><li><h6 id="网络延时产生的原因"><a href="#网络延时产生的原因" class="header-anchor">#</a> 网络延时产生的原因？</h6> <ul><li>说到延时，实际上就与带宽评估有密切的关系了。延时的产生有两个原因：
<ul><li><strong>第一是链路问题</strong>，正常的网络上，数据包的传输都是时快时慢的；</li> <li><strong>第二是发生网络拥塞</strong>，当发生拥塞后，数据包会进行缓冲就会造成延时，而当缓冲溢出时，就出现了丢包。</li></ul></li> <li>所以对于延时来说，我们<strong>需要解决的是因拥塞而造成的延时，链路问题无法解决</strong>。</li></ul></li></ul> <h6 id="如何更准确的评估带宽"><a href="#如何更准确的评估带宽" class="header-anchor">#</a> 如何更准确的评估带宽？</h6> <ul><li>WebRTC防止拥塞的根基是有<strong>准确的带宽评估方法</strong>。它提供了两种带宽评估方法**，**</li> <li><strong>一种是基于丢包的带宽评估</strong>。
<ul><li>基于丢包的带宽评估方法比较简单，根据丢包率进行计算。实际上，正常带宽也有一定的丢包，如果丢包率小于2%，属于网络质量不错的正常丢包，说明带宽还没有达到上限，应该增加评估的带宽值。</li> <li>举个例子，比如你家里的带宽是8M，WebRTC最开始是不知道你家里的真实带宽的，它必须一点点测量，所以一开始它先给你的带宽设置一个假设值，即500K，当发现丢包率很低时，它再增加带宽的评估值，如从500K升到1兆，如果丢包率还是很低，就会加到1.5兆、2兆……，带宽评估值增加的速度是每次增加8%；如果丢包率大于10%，说明发生拥塞了，此时应该立即降低带宽，公式如图（loss&gt;0.1时）所示。如果丢包率小于10%，说明现在的带宽评估的比较准确，此时应该保持这个带宽，不增加也不减少；</li> <li><img src="/assets/img/image-20210923114100925-16372870921699.1f09224e.png" alt="image-20210923114100925"></li></ul></li> <li><strong>另一种是基于延时的带宽评估</strong>。而基于延时的评估方法又分为接收端（Goog-REMB）和发送端（Goog-TCC）的带宽评估方法，目前默认采用的是<strong>Goog-TCC</strong>方法，因为其相对来说更为精准。
<ul><li>基于延时的带宽评估方法比基于丢包的评估更好一些，因为它可以提前预估是否发生了拥塞。基于丢包的评估丢包率一旦超过10%就说明可能已经发生拥塞了，而网络一旦拥塞，再想恢复回原来的状态，需要花费一段时间，而这段时间就会影响音视频的服务质量。</li> <li>而基于延时的带宽评估就不会产生这种情况。它的基本原理是，如果接收到的数据包的网络传输时延在持续增长，就说明网络变差了，当达到一定程度时，就要将评估的带宽值降下来，以防止发生网络拥塞。它的计算公式是根据状态机来的（状态机比较复杂，我这里就不讲了），当状态非常好时，需要增加带宽，同丢包增加带宽一样，每次增加8%；如果延时一直累加，则需要降低带宽，带宽降为原来85%，其它情况就保持当前带宽，无增无减。</li> <li><img src="/assets/img/image-20210923114204390-163728709216910.39dcb155.png" alt="image-20210923114204390"></li></ul></li></ul> <h6 id="为什么tcc比remb准确吗"><a href="#为什么tcc比remb准确吗" class="header-anchor">#</a> 为什么TCC比REMB准确吗？</h6> <ul><li>TCC和REMB主要有两个区别。第一是计算的端不同，REMB是在接收端计算的，接收端计算后再将结果返回给发送端进行控制，而在回传结果时，可能网络又发生了新的变化，这就造成了REMB的及时性不够；</li> <li>TCC是将所有数据都交给发送端做计算和控制，因此及时性和准确度会更高。</li> <li>第二是滤波器不同，REMB是卡尔曼滤波器（Kalman），TCC是最小二乘法滤波器（Trend line）。最小二乘法滤波器在网络延时评估这方面比卡尔曼滤波器效果更好一些。</li></ul> <h5 id="媒体数据与带宽平衡"><a href="#媒体数据与带宽平衡" class="header-anchor">#</a> 媒体数据与带宽平衡？</h5> <ul><li>带宽评估方法和网络质量的提升在前面我已经介绍了。在有限的带宽下，如何才能提供更好的音视频服务质量，是人们一直孜孜不倦追求的目标。因此在同等条件下，可以将数<strong>据压缩的更小</strong>，一直是解决服务质量的一种关键方法。目前最常用的视频编码器还是H.264，不过新的编码器已经有了很大突破<code>VP9</code>/<code>H265</code>、<code>AV1/H264</code>提供了更高的压缩率，这使得我们在网络条件有限的情况下，可以传输更多的数据从而保障更好的服务质量。</li> <li>另一方面，在带宽相同且码流无法压缩的情况下，还可以<strong>采用动态码率</strong>。通常，在使用动态码率时，我们可以直接从产品上看出来，你会发现视频一会儿清晰，一会儿模糊。即在带宽小时，编码器压缩码流，此时视频变得模糊；带宽大时，编码器放大了码流，所以视频变得清晰。以上就是通过减少数据量的方法来保障实时通信质量的。</li></ul> <h6 id="simulcast或svc的定义和区别"><a href="#simulcast或svc的定义和区别" class="header-anchor">#</a> Simulcast或SVC的定义和区别？</h6> <ul><li><p><img src="/assets/img/image-20210923114642530-163728709217011.2e8ad84b.png" alt="image-20210923114642530"></p></li> <li><p>可以通过Simulcast或SVC解决质量问题。Simulcast和SVC解决问题的思路是类似的，它们会在发送端增大码流的发送，将数据先传给服务端，然后由服务端根据接收端带宽的不同，选择合适的码流下发。对于网络较差的用户，传输清晰度低的码流，对于网络较好的用户，传输高清晰度的码流。所以这两种技术对于发送方的带宽和质量有非常高的要求。</p></li></ul> <h6 id="svc与simulcast最大的区别"><a href="#svc与simulcast最大的区别" class="header-anchor">#</a> SVC与Simulcast最大的区别</h6> <ul><li>SVC上传的是一路码流，但这一路码流是由多层构成的。服务端会按照不同接收端的带宽大小，选择传输不同的层。如上图所示，手机端带宽小，就传输小的一层数据，PC端带宽大，就将所有层全部传输过去；</li> <li>而Simulcast上传的是多路流，一般分为小、中、大三路。对手机端传输小的一路，对PC端传输最大的一路。</li> <li>Simulcast的好处在于，每一路流都是独立的，所以可以对每一路流使用硬件编解码器，而 SVC的分层方式目前没有硬件支持，所以无法通过硬件加速。</li></ul> <h6 id="流控"><a href="#流控" class="header-anchor">#</a> 流控</h6> <ul><li><p><img src="/assets/img/image-20210923114831904-163728709217012.9d416da8.png" alt="image-20210923114831904"></p></li> <li><p>当带宽评估准确后，如果发送的的码流还是大于带宽大小，此时就需要通过流控来进行控制了。流控的作用是当输出码流大于带宽时，降低发送码率，以防止发生拥塞。当然它会导致时延的增加。实际上，对于流控来说，它需要控制两个点：<strong>第一个点是Pacer，降低发送码率</strong>。当然仅降低发送码率还不够，因为如果编码器仍然输出大量码流给Pacer，那么Pacer 的缓冲区迟早会被撑爆。所以在控制Pacer让它减少发送码率的同时，<strong>一定要降低音视频的编码器的输出码率</strong>，从而保持平衡，进而使数据平缓下行。</p></li> <li><p>正如我前面所说的，流控虽然防止了网络拥塞的发生，但会增加一些延时，增加的延时最终会反应到实时通信的总指标里，总的延时必须控制在500ms以内。比如以前端到端时延是200ms，由于带宽不足，时延增加到300ms、400ms都是可以的，但一定不要超过500ms。</p></li> <li><p>此外，对于编码器的输出码流来说，如果流控通过直接降低码流仍然不能与带宽适配时，还可以通过降低分辨率的方式来降低码流。总之，在带宽不足时，要想尽办法减少数据量。实在不行，也可以关掉视频只保留音频来保障网络的畅通。</p></li></ul> <h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h5> <ul><li><p><img src="/assets/img/image-20210923115320582-163728709217013.521a8467.png" alt="image-20210923115320582"></p></li> <li><p><strong>总结一下</strong>，对于服务质量保障，</p> <ul><li>首先提高网络质量，<code>NACK</code>和<code>FEC</code>解决丢包问题，</li> <li><code>JitterBuffer</code>解决视频的乱序与抖动，<code>NetEQ</code>解决音频的乱序与抖动；</li> <li>带宽评估通过<code>Goog-REMB</code>和<code>Goog-TCC</code>，还有丢包的带宽评估；</li> <li>为了保障实时性，需要选择更优质的线路，比如客户端与服务端通信的时候选择更好的路线节点，保证云端网络带宽等等；</li> <li>从业务上，减少数据量可以用<code>AV1</code>、<code>SVC</code>、<code>Simulcast</code>、动态码率，减少业务；</li> <li>在防拥塞上，通过Pacer进行流控，只要能控制在500ms之内，适当增加时延也是可以接收的。</li></ul></li></ul> <h4 id="在内网环境下p2p想让延时尽可能小-可以做哪些工作-实验室环境最小延时可以达到100ms以下吗"><a href="#在内网环境下p2p想让延时尽可能小-可以做哪些工作-实验室环境最小延时可以达到100ms以下吗" class="header-anchor">#</a> 在内网环境下p2p想让延时尽可能小，可以做哪些工作？实验室环境最小延时可以达到100ms以下吗？</h4> <ul><li>如果在同一个局域网内，实际只有几十毫秒的延迟。有同学可能会疑惑，有的产品在同一局域网内延迟非常小，为什么用WebRTC反而延迟增大了？这就是因为WebRTC为保障网络质量，在内部通过多种机制，各种缓冲，来做到的。所以它必然会产生一定的延迟，也就是拿延迟换质量。而在局域网内，网络基本没有延时，不丢包、不抖动、不乱序。这时什么策略都不采用，网络的传输才是最快的，因此在内网通信时，WebRTC的实时性一定不如什么策略都不加的产品好。</li></ul> <h4 id="可靠性这块-udp上的webrtc做ack是自己封装了seq吗-然后-一样需要ack重传的话-跟tcp-sack有什么区别呢"><a href="#可靠性这块-udp上的webrtc做ack是自己封装了seq吗-然后-一样需要ack重传的话-跟tcp-sack有什么区别呢" class="header-anchor">#</a> 可靠性这块，UDP上的WebRTC做ack是自己封装了seq吗？然后，一样需要ack重传的话，跟TCP SACK有什么区别呢？</h4> <ul><li>WebRTC使用的是RTP协议传输数据。RTP协议中有seq字段。此外，WebRTC用的NACK与TCP的ACK机制不同。TCP每一块数据都需要通过ACK进行确认，如果没收到ACK就重发，直到成功收到ACK或断连；而NACK允许丢包，当重传多次不行时，就不传了。且而即使重传了数据包，在接收端发现它已经过期时，也会将其丢掉。</li></ul> <p>ice，stun，p2p原理</p> <p>sdp协议</p> <p>webrtc中offer/answer流程</p> <p>nack</p> <p>webrtc的nack策略是怎么实现的</p> <p>webrtc的nack请求丢失的帧，请求帧的rtcp包格式是怎样的</p> <p>webrtc的fec策略与nack策略同时开会如何？</p> <p>什么是rtt，rtt有什么作用</p> <p>音频混音、降噪、回声消除算法</p> <p>jitterbuff，fec，nack</p> <p>流控</p> <h3 id="rtsp"><a href="#rtsp" class="header-anchor">#</a> rtsp</h3> <p>rtsp包含哪些方法，rtsp流程</p> <h3 id="rtmp"><a href="#rtmp" class="header-anchor">#</a> rtmp</h3> <p>rtmp是可靠的传输协议吗</p> <p>rtmp一般采用哪种封装格式</p> <p>rtmp握手流程</p> <p>rtmp协议客户端与服务器交互流程</p> <h3 id="rtcp"><a href="#rtcp" class="header-anchor">#</a> rtcp</h3> <p>h264 over rtp如何实现</p> <h2 id="封装格式"><a href="#封装格式" class="header-anchor">#</a> 封装格式</h2> <h3 id="rtp"><a href="#rtp" class="header-anchor">#</a> rtp</h3> <h3 id="mp4"><a href="#mp4" class="header-anchor">#</a> mp4</h3> <p>mp4封装</p> <h3 id="flv"><a href="#flv" class="header-anchor">#</a> flv</h3> <p>flv封装</p> <p>flv组成</p> <p>flv怎么获取sps，pps</p> <h3 id="aac"><a href="#aac" class="header-anchor">#</a> aac</h3> <p>aac封装有哪些规格</p> <p>adts枕头包含哪些字段和含义</p> <h3 id="wav"><a href="#wav" class="header-anchor">#</a> wav</h3> <p>wav格式以什么开头</p> <p>wav的数据头的最小大小和作用</p> <h2 id="编码格式"><a href="#编码格式" class="header-anchor">#</a> 编码格式</h2> <h3 id="h264"><a href="#h264" class="header-anchor">#</a> H264</h3> <h4 id="开源实现"><a href="#开源实现" class="header-anchor">#</a> 开源实现</h4> <ul><li>OpenH264。
<ul><li>OpenH264 CPU 的占用相对 x264低很多。</li> <li>OpenH264 只支持 baseline profile</li></ul></li> <li><a href="http://www.videolan.org/developers/x264.html" target="_blank" rel="noopener noreferrer">x264<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>x264 的主要功能在于进行 H.264/MPEG-4 AVC 的视频编码。</li> <li>主要实现了主流配置（main）。而且它舍去了一些对编码性能贡献较小，但是计算复杂度很高的特性。所以它的编码速度提高很多，但是编码效率并没有明显降低。而且x264主要采用c语言编写，底层模块使用了汇编语言进行优化。</li> <li>x264是一个编码器，它并没有实现解码器的部分。</li></ul></li> <li><a href="http://iphome.hhi.de/suehring/tml/download/" target="_blank" rel="noopener noreferrer">JM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>JM实现了H.264的全部配置。而且它的代码结构比较清晰。</li> <li>编解码速度是比较慢的，编码一帧的图像，就可能会用0.5-1秒的时间。所以JM很少应用在商业软件上，它较多用于学术研究上面。</li></ul></li></ul> <h4 id="简述h264格式"><a href="#简述h264格式" class="header-anchor">#</a> 简述h264格式</h4> <h4 id="h264句法和语义"><a href="#h264句法和语义" class="header-anchor">#</a> H264句法和语义</h4> <ul><li><p>句法，表示句法元素的组织结构。语法，表示编程语言语法。</p></li> <li><h5 id="以往标准句法元素的分层结构的缺点"><a href="#以往标准句法元素的分层结构的缺点" class="header-anchor">#</a> 以往标准句法元素的分层结构的缺点：</h5> <ul><li>在每一层中，数据和它的头部，形成强依赖关系，一旦头部丢失，数据部分也不可能正确被解码。</li> <li>在序列层及图像层，因为数据量过大，不可能将所有的句法元素一次传输，这时假如头部所在的分组丢失，那么该层其他的数据，即使能正确接收也无法解码。</li> <li>图像层内的各个片之间，经常会携带相同的数据，造成码流的浪费。</li> <li><img src="/assets/img/image-20220223160024199.d6b2cf06.png" alt="image-20220223160024199"></li></ul></li> <li><h5 id="h-264的句法元素的分层结构"><a href="#h-264的句法元素的分层结构" class="header-anchor">#</a> H.264的句法元素的分层结构</h5> <ul><li>H.264取消了图像层和序列层，取而代之的，将原本属于图像层和序列层的大部分句法元素，抽取出来形成图像参数集和序列参数集，其余的部分，则放入片层。</li> <li>如图所示，同一个序列参数集可以被多个序列中的图像参数集引用，同一个图像参数集也可以被多个图像引用。</li> <li>H.264的句法元素的分层结构，分别为序列、图像、片、宏块、子宏块这5个层次。</li> <li><img src="/assets/img/image-20220223160521057.031d379a.png" alt="image-20220223160521057"></li> <li><img src="/assets/img/image-20220223160933326.9132518d.png" alt="image-20220223160933326"></li></ul></li> <li><h5 id="h264码流格式"><a href="#h264码流格式" class="header-anchor">#</a> h264码流格式</h5> <ul><li>字节流格式
<ul><li>h264官方协议文档中规定的格式，处于文档附录B（Annex-B Byte stream format）中。所以它也成为了大多数编码器，默认的输出格式。它的基本数据单位为NAL单元，也即NALU。为了从字节流中提取出NALU，协议规定，在每个NALU的前面加上起始码：0x000001或0x00000001（0x代表十六进制）</li></ul></li> <li>RTP包格式
<ul><li>这种格式并没有在h264中规定。在这种格式中，NALU并不需要起始码Start_Code来进行识别，而是在NALU开始的若干字节（1，2，4字节），代表NALU的长度。</li></ul></li> <li>没有经过传输协议封装，所以可以称之为裸流。</li></ul></li> <li><h5 id="h264码流结构的组成-字节流格式"><a href="#h264码流结构的组成-字节流格式" class="header-anchor">#</a> h264码流结构的组成（字节流格式）</h5> <ul><li><strong><code>H264比特流 = Start_Code_Prefix + NALU + Start_Code_Prefix + NALU + …</code></strong></li> <li><strong><code>NALU = NALU Header + RBSP</code></strong>，严格来说为：<strong><code>NALU = NALU Header + EBSP</code></strong></li> <li>NALU Header
<ul><li>NALU Header由三个句法元素组成，分别为：forbidden_zero_bit、nal_ref_idc和nal_unit_type，它们总共占据一个字节，也就是说，NALU Header，在整个NALU中，占据一个字节。</li> <li>nal_unit_type的值为1-5时，表示RBSP里面包含的数据为条带（片/Slice）数据，所以值为1-5的NALU统称为VCL（视像编码层）单元，其他的NALU则称为非VCL NAL单元。</li> <li>当nal_unit_type为7时，代表当前NALU为序列参数集，为8时为图像参数集。这也是我们打开.h264文件后，遇到的前两个NALU，它们位于码流的最前面。</li> <li>当nal_unit_type为14-31时，我们可以不用理睬，目前几乎用不到。</li> <li><img src="/assets/img/image-20220223164700610.71601a04.png" alt="image-20220223164700610"></li></ul></li> <li>EBSP
<ul><li>EBSP完全等价于NALU主体，而且它们三个的结构关系为：<strong>EBSP包含RBSP，RBSP包含SODB</strong>。</li> <li>其中SODB就是最原始的编码数据。</li> <li><strong>EBSP</strong>为扩展字节序列载荷（Encapsulated Byte Sequence Payload），而<strong>RBSP</strong>为原始字节序列载荷（Raw Byte Sequence Payload）。</li> <li>在h264的文档中，并没有EBSP这一名词出现，但是在h264的官方参考软件JM里，却使用了EBSP。</li> <li>EBSP相较于RBSP，多了防止竞争的一个字节：0x03。为了防止NALU内部，原本就有序列为0x000003这样的数据。所以，当我们拿到EBSP时，就需要检测EBSP内是否有序列：0x000003，如果有，则去掉其中的0x03。这样一来，我们就能得到原始字节序列载荷：RBSP。
<ul><li><img src="/assets/img/image-20220223165435737.1d3deb30.png" alt="image-20220223165435737"></li></ul></li></ul></li> <li>RBSP、SODB
<ul><li><strong>RBSP = SODB + RBSP尾部</strong></li> <li>RBSP尾部
<ul><li>rbsp_stop_one_bit 占1个比特位，值为1;</li> <li>rbsp_alignment_zero_bit 值为0，目的是为了进行字节对齐，占据若干比特位;</li></ul></li> <li>条带RBSP尾部
<ul><li>另一种尾部，就是当NALU类型为条带时，也即nal_unit_type等于1~5时。</li></ul></li></ul></li></ul></li></ul> <h4 id="h264解码器框架"><a href="#h264解码器框架" class="header-anchor">#</a> H264解码器框架</h4> <ul><li>h264句法元素的解析：NALU的结构和熵解码，同时熵解码又包括指数哥伦布编码、CAVLC、CABAC。只要掌握了NALU和熵解码，我们就可以从码流中解析出各个句法元素的值。即使完全是个小白，也可以按照h264协议完成这步。</li> <li>数据准备：DCT变换、量化、重排序，和它们相关的句法元素及语义。这个过程是为后面的重建图像做准备，这时我们已经解析出各个句法元素，实现该过程需要配合各步骤所需要的句法元素。</li> <li>重建图像：帧内预测、帧间预测、去块效应滤波器。这时候码流数据已经完全解压缩，就差拿着残差数据、参考图像和预测所需的句法元素，预测出预测数据。预测数据经过去块效应后即可得解码宏块，当前图像的所有宏块解码完成，就可以得到重建图像用于显示。</li> <li><img src="/assets/img/image-20220223170704513.a219e2f5.png" alt="image-20220223170704513"></li></ul> <h4 id="序列参数集sps句法和语义"><a href="#序列参数集sps句法和语义" class="header-anchor">#</a> 序列参数集SPS句法和语义</h4> <ul><li>标记这段视频序列的编码级别、计算图像宽高、解码后的图像剪裁、计算POC这些功能，针对点都在图像和视频序列级别上，这是理解sps的关键。</li> <li><a href="https://mp.weixin.qq.com/s?__biz=MzI5Njc3OTk5NA==&amp;mid=2247483948&amp;idx=1&amp;sn=0e545599e1d47e03af559dff724d832e&amp;chksm=ecbe6b99dbc9e28f2a5c6988fb905b4d8f586673b9678e702393b4e9fa12d3173868da46fb99&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">详细代码解释<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h4 id="图像参数集pps句法和语义"><a href="#图像参数集pps句法和语义" class="header-anchor">#</a> 图像参数集PPS句法和语义</h4> <ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5Njc3OTk5NA==&amp;mid=2247483952&amp;idx=1&amp;sn=f3b5875338d20ff2557c09c1b07c10e4&amp;chksm=ecbe6b85dbc9e2931a88427d40acf0ab5b847146b5dca0c6d9fa6363c3e46abb307ec70cba5f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">详细代码解释<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h4 id="h264-的编码参数"><a href="#h264-的编码参数" class="header-anchor">#</a> H264 的编码参数</h4> <ul><li><strong>H.264 Profiles</strong>，用于确定编码过程中帧间压缩使用的算法，常见的 H264 编码 Profile 有如下 3 种：
<ul><li><img src="/assets/img/image-20220223172321694.3083157b.png" alt="image-20220223172321694"></li></ul></li></ul> <blockquote><ul><li><strong>Baseline Profile (BP)</strong> <ul><li>只支持 I/P 帧，无交错（Progressive）和 CAVLC，主要用于计算能力有限的应用环境，一般用于低阶或需要额外容错的应用，比如视频通话、手机视频等。</li> <li>优势：编解码开销较小，速度快，适用于视频会议等延时敏感的场景或者解码能力不够的环境。</li> <li>不足：同等码率下，Baseline 的画质最差。</li></ul></li> <li><strong>Main Profile (MP)</strong> <ul><li>支持 I/P/B 帧，无交错（Progressive）和交错（Interlaced），同时提供对于 CAVLC 和 CABAC 的支持，用于主流消费类电子产品规格如低解码（相对而言）的 MP4、便携的视频播放器；</li> <li>优势：CABAC 的支持和 B 帧的引入，相同码率下画质相对 Baseline 有 15% 的提升。</li> <li>不足：运算量上和画质相对于 HiP 没有太大优势，绝大部份情况下已经被 HiP 取代。</li></ul></li> <li><strong>High Profile (HiP)</strong> <ul><li>在 Main 的基础上增加了 8x8 内部预测、自定义量化、无损视频编码和更多的 YUV 格式（如 4：4：4）用于广播，高清电视及视频碟片存储（HiP 被采纳为 HD DVD 和蓝光的编码标准）。</li> <li>优势：8x8 内部预测的引入使得 HiP 能够较好的编码快速移动的场景、支持码流之间有效的切换（SP 和 SI 片）、改进误码性能。</li></ul></li> <li>除此之外的类别，如：<strong>High 10 Profile (Hi10P)</strong>、<strong>High 4:2:2 Profile (Hi422P)</strong>、<strong>High 4:4:4 Predictive Profile (Hi444PP)</strong>。</li></ul></blockquote> <ul><li><strong>H.264 Level</strong> <ul><li>Level 是对视频本身特性的一些描述(码率，分辨率，fps 等)，Level 越高，视频的码率、分辨率、fps 越高。Level 也表示了对播放设备的解码性能要求，值越高，代表播放设备解码性能要求越高，相对的输出影片的压缩率也越越高。</li></ul></li> <li><strong>GOP 长度</strong> <ul><li>一个 key frame (IDR) 到下一个 key frame 的范围。表示关键帧的间隔，一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧 图像。当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR 图像之后的图像永远不会使用 IDR 之前的图像的数据来解码。</li></ul></li> <li><strong>Constant Quantizer (QP)</strong> <ul><li>恒定量化值（Constant Quantizer）可以用来控制图像编码的品质。编码器中一般可以这是最大值和最小值。比较低的数值会得到比较高的品质。</li></ul></li> <li><strong>Maximun B-frame</strong> <ul><li>当设定 B 帧时，重复部分比较多/变化较少的 Frames 会被编码为 B 帧此值限制 B 帧的最大连续数量。</li></ul></li> <li><strong>Reference frame (ref)</strong> <ul><li>设定一个 P 帧所能参考的帧的数量，ref 会影响播放相容性。</li></ul></li> <li><strong>码率控制(Bitrate Control)</strong> <ul><li>CBR（恒定码率）、VBR（动态码率）；码率控制实际上是一种编码的优化算法，它用于实现对视频流码流大小的控制。目的在于同样的视频编码格式，码流大，它包含的信息也就越多，那么对应的图像也就越清晰，反之亦然。VBR 码流控制方式可以降低图像动态画面少时候的带宽占用，CBR 控制方式码流稳定，图像状态较稳定。他们为了解决的是不同需求下的不同应用。</li></ul></li></ul> <h4 id="avc-svc"><a href="#avc-svc" class="header-anchor">#</a> AVC/SVC</h4> <ul><li><p>AVC 实际上是 H.264 协议的别名。SVC 是以 H264/AVC 为基础，利用了AVC编解码器的各种高效算法工具，在语法和工具集上进行了扩展，支持分级特性的码流，包括空域（分辨率）可分级、时域（帧率）可分级和质量可分级；从而可产生不同帧速率、分辨率或质量等级的解码视频。</p></li> <li><table><thead><tr><th>项目</th> <th>H264/AVC</th> <th>H264/SVC</th></tr></thead> <tbody><tr><td>视频会议可以容忍的网络丢包率</td> <td>&lt; 2~3 %</td> <td>&lt; 20%</td></tr> <tr><td>对网络的要求</td> <td>专线</td> <td>共享线路</td></tr> <tr><td>视频会议延迟</td> <td>400ms</td> <td>&lt; 200ms</td></tr> <tr><td>视频会议实时性</td> <td>非实时性交互</td> <td>实时性交互</td></tr> <tr><td>HD 会议室终端开销</td> <td>昂贵</td> <td>普及型</td></tr></tbody></table></li></ul> <h4 id="一些问题"><a href="#一些问题" class="header-anchor">#</a> 一些问题</h4> <ul><li><p>h264格式分层的目的</p></li> <li><p>nalu结构</p></li> <li><p>nalu类型</p></li> <li><p>h264编码一帧数据流程</p></li> <li><p>列举几种profile</p></li> <li><p>解释GOP，帧，如何通过sps内部的pic_width_in_mbs_minus1/pic_height_in_map_units_minus1计算宽高</p></li> <li><p>运动补偿</p></li> <li><p>熵编码</p></li> <li><p>有几种nal，如果在视频中存放信息存放在哪个帧</p></li></ul> <h4 id="参考链接"><a href="#参考链接" class="header-anchor">#</a> 参考链接</h4> <ul><li><a href="http://www.enkichen.com/2017/11/26/image-h264-encode/" target="_blank" rel="noopener noreferrer">图像编码与 H264 基础知识<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.itu.int/rec/T-REC-H.264-200503-S/en" target="_blank" rel="noopener noreferrer">H.264的协议文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>新一代视频压缩编码标准--H.264/AVC 毕厚杰</li> <li><a href="https://mp.weixin.qq.com/s/cDFB33Nzz6OyPKESRJNrvg" target="_blank" rel="noopener noreferrer">H264系列文章，规划学习的方向很详细<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s/nfei3FBQ1qINH79rupcNUw" target="_blank" rel="noopener noreferrer">H264/AVC基本结构<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="h265"><a href="#h265" class="header-anchor">#</a> H265</h3> <ul><li>开源实现
<ul><li>libde265。</li> <li>x265。</li></ul></li></ul> <p>h264与h265区别，h265优势？</p> <p>HEVC 被认为不仅提升视频质量，同时也能达到 H.264/MPEG-4 AVC 两倍之压缩率（等同于同样画面质量下比特率减少了 50%），可支持 4K 分辨率甚至到超高清电视（UHDTV），最高分辨率可达到 8192×4320（8K 分辨率）。</p> <h3 id="vp8"><a href="#vp8" class="header-anchor">#</a> VP8</h3> <p>开源实现：libvpx。</p> <h3 id="vp9"><a href="#vp9" class="header-anchor">#</a> VP9</h3> <p>开源实现：libvpx。</p> <h2 id="opengl"><a href="#opengl" class="header-anchor">#</a> opengl</h2> <p>opengl如何绘制视频</p> <p>opengl的着色器在每个渲染步骤是怎样的</p> <p>opengl使用的过程</p> <p>yuv怎么传递到opengl</p> <p>opengl场见坐标系的变换顺序</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2/23/2022, 5:39:42 PM</span></div></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/docs/ready/5_stream_media.html#流媒体相关" class="sidebar-link reco-side-流媒体相关" data-v-70334359>流媒体相关</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#相关术语" class="sidebar-link reco-side-相关术语" data-v-70334359>相关术语</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#视频花屏的原因" class="sidebar-link reco-side-视频花屏的原因" data-v-70334359>视频花屏的原因？</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#播放黑屏" class="sidebar-link reco-side-播放黑屏" data-v-70334359>播放黑屏</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#播放花屏、绿屏" class="sidebar-link reco-side-播放花屏、绿屏" data-v-70334359>播放花屏、绿屏</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#播放闪屏" class="sidebar-link reco-side-播放闪屏" data-v-70334359>播放闪屏</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#播放卡顿" class="sidebar-link reco-side-播放卡顿" data-v-70334359>播放卡顿</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#首开慢" class="sidebar-link reco-side-首开慢" data-v-70334359>首开慢</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#延时高" class="sidebar-link reco-side-延时高" data-v-70334359>延时高</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#音画不同步" class="sidebar-link reco-side-音画不同步" data-v-70334359>音画不同步</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#马赛克严重" class="sidebar-link reco-side-马赛克严重" data-v-70334359>马赛克严重</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#播放杂音、噪声、回声" class="sidebar-link reco-side-播放杂音、噪声、回声" data-v-70334359>播放杂音、噪声、回声</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#点播拖动不准" class="sidebar-link reco-side-点播拖动不准" data-v-70334359>点播拖动不准</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#直播关键性能指标" class="sidebar-link reco-side-直播关键性能指标" data-v-70334359>直播关键性能指标</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#播放性能优化" class="sidebar-link reco-side-播放性能优化" data-v-70334359>播放性能优化</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/5_stream_media.html#传输网络" class="sidebar-link reco-side-传输网络" data-v-70334359>传输网络</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#弱网模拟测试工具" class="sidebar-link reco-side-弱网模拟测试工具" data-v-70334359>弱网模拟测试工具</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#传统cdn架构" class="sidebar-link reco-side-传统cdn架构" data-v-70334359>传统CDN架构</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#直播传输网络" class="sidebar-link reco-side-直播传输网络" data-v-70334359>直播传输网络</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/5_stream_media.html#网络协议" class="sidebar-link reco-side-网络协议" data-v-70334359>网络协议</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#webrtc" class="sidebar-link reco-side-webrtc" data-v-70334359>webrtc</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#rtsp" class="sidebar-link reco-side-rtsp" data-v-70334359>rtsp</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#rtmp" class="sidebar-link reco-side-rtmp" data-v-70334359>rtmp</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#rtcp" class="sidebar-link reco-side-rtcp" data-v-70334359>rtcp</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/5_stream_media.html#封装格式" class="sidebar-link reco-side-封装格式" data-v-70334359>封装格式</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#rtp" class="sidebar-link reco-side-rtp" data-v-70334359>rtp</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#mp4" class="sidebar-link reco-side-mp4" data-v-70334359>mp4</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#flv" class="sidebar-link reco-side-flv" data-v-70334359>flv</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#aac" class="sidebar-link reco-side-aac" data-v-70334359>aac</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#wav" class="sidebar-link reco-side-wav" data-v-70334359>wav</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/5_stream_media.html#编码格式" class="sidebar-link reco-side-编码格式" data-v-70334359>编码格式</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#h264" class="sidebar-link reco-side-h264" data-v-70334359>H264</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#h265" class="sidebar-link reco-side-h265" data-v-70334359>H265</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#vp8" class="sidebar-link reco-side-vp8" data-v-70334359>VP8</a></li><li class="level-3" data-v-70334359><a href="/docs/ready/5_stream_media.html#vp9" class="sidebar-link reco-side-vp9" data-v-70334359>VP9</a></li><li class="level-2" data-v-70334359><a href="/docs/ready/5_stream_media.html#opengl" class="sidebar-link reco-side-opengl" data-v-70334359>opengl</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.4a086806.js" defer></script><script src="/assets/js/6.bd5416f2.js" defer></script><script src="/assets/js/1.01911418.js" defer></script><script src="/assets/js/5.61258adc.js" defer></script>
  </body>
</html>
