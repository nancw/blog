(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{696:function(r,t,e){r.exports=e.p+"assets/img/image-20210928171508258.c8c960af.png"},697:function(r,t,e){r.exports=e.p+"assets/img/image-20210930100004280.73c9ef6d.png"},698:function(r,t,e){r.exports=e.p+"assets/img/image-20210930101826985.4b552a18.png"},699:function(r,t,e){r.exports=e.p+"assets/img/image-20210930110136180.99a47701.png"},700:function(r,t,e){r.exports=e.p+"assets/img/image-20210927114451908.780c8ec6.png"},701:function(r,t,e){r.exports=e.p+"assets/img/image-20210930115916805.cc2ddfc0.png"},702:function(r,t,e){r.exports=e.p+"assets/img/image-20210930112019896.5c810a43.png"},853:function(r,t,e){"use strict";e.r(t);var a=e(12),n=Object(a.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#工厂模式"}},[r._v("工厂模式")])]),a("li",[a("a",{attrs:{href:"#生成器-建造者模式"}},[r._v("生成器 -- 建造者模式")])]),a("li",[a("a",{attrs:{href:"#建造者模式"}},[r._v("建造者模式")])]),a("li",[a("a",{attrs:{href:"#单例模式"}},[r._v("单例模式")])]),a("li",[a("a",{attrs:{href:"#原型模式"}},[r._v("原型模式")])])])]),a("p"),r._v(" "),a("h1",{attrs:{id:"创建型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[r._v("#")]),r._v(" 创建型模式")]),r._v(" "),a("h2",{attrs:{id:"工厂模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[r._v("#")]),r._v(" 工厂模式")]),r._v(" "),a("h3",{attrs:{id:"_1-简单工厂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-简单工厂"}},[r._v("#")]),r._v(" "),a("strong",[r._v("① 简单工厂")])]),r._v(" "),a("p",[a("img",{attrs:{src:e(696),alt:"image-20210928171508258"}})]),r._v(" "),a("h3",{attrs:{id:"_2-工厂方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-工厂方法"}},[r._v("#")]),r._v(" "),a("strong",[r._v("② 工厂方法")])]),r._v(" "),a("p",[a("strong",[r._v("工厂方法模式")]),r._v("是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。")]),r._v(" "),a("p",[a("img",{attrs:{src:e(697),alt:"image-20210930100004280"}})]),r._v(" "),a("h4",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[r._v("#")]),r._v(" "),a("strong",[r._v("优点")])]),r._v(" "),a("ul",[a("li",[r._v("你可以避免创建者和具体产品之间的紧密耦合。")]),r._v(" "),a("li",[a("em",[r._v("单一职责原则")]),r._v("。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。")]),r._v(" "),a("li",[a("em",[r._v("开闭原则")]),r._v("。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。")])]),r._v(" "),a("h4",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[r._v("#")]),r._v(" "),a("strong",[r._v("缺点")])]),r._v(" "),a("ul",[a("li",[r._v("应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。")])]),r._v(" "),a("h4",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[r._v("#")]),r._v(" "),a("strong",[r._v("应用场景")])]),r._v(" "),a("ul",[a("li",[r._v("当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。")]),r._v(" "),a("li",[r._v("如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。")]),r._v(" "),a("li",[r._v("如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。")])]),r._v(" "),a("h4",{attrs:{id:"与其他模式的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与其他模式的关系"}},[r._v("#")]),r._v(" "),a("strong",[r._v("与其他模式的关系")])]),r._v(" "),a("ul",[a("li",[a("p",[r._v("在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。")])]),r._v(" "),a("li",[a("p",[r._v("抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。")])]),r._v(" "),a("li",[a("p",[r._v("你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。")])]),r._v(" "),a("li",[a("p",[r._v("原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。")])]),r._v(" "),a("li",[a("p",[r._v("工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。")])])]),r._v(" "),a("h3",{attrs:{id:"_3-抽象工厂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-抽象工厂"}},[r._v("#")]),r._v(" "),a("strong",[r._v("③ 抽象工厂")])]),r._v(" "),a("p",[a("strong",[r._v("抽象工厂模式")]),r._v("是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。")]),r._v(" "),a("p",[a("img",{attrs:{src:e(698),alt:"image-20210930101826985"}})]),r._v(" "),a("h4",{attrs:{id:"应用场景-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-2"}},[r._v("#")]),r._v(" "),a("strong",[r._v("应用场景")])]),r._v(" "),a("ul",[a("li",[a("p",[r._v("如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。")])]),r._v(" "),a("li",[a("p",[r._v("如果你有一个基于一组"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象方法"),a("OutboundLink")],1),r._v("的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。")])])]),r._v(" "),a("h4",{attrs:{id:"优点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[r._v("#")]),r._v(" "),a("strong",[r._v("优点")])]),r._v(" "),a("ul",[a("li",[r._v("你可以确保同一工厂生成的产品相互匹配。")]),r._v(" "),a("li",[r._v("你可以避免客户端和具体产品代码的耦合。")]),r._v(" "),a("li",[a("em",[r._v("单一职责原则")]),r._v("。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。")]),r._v(" "),a("li",[a("em",[r._v("开闭原则")]),r._v("。 向应用程序中引入新产品变体时， 你无需修改客户端代码。")])]),r._v(" "),a("h4",{attrs:{id:"缺点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[r._v("#")]),r._v(" "),a("strong",[r._v("缺点")])]),r._v(" "),a("ul",[a("li",[r._v("由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。")])]),r._v(" "),a("h4",{attrs:{id:"与其他模式的关系-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与其他模式的关系-2"}},[r._v("#")]),r._v(" "),a("strong",[r._v("与其他模式的关系")])]),r._v(" "),a("ul",[a("li",[r._v("在许多设计工作的初期都会使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"}},[r._v("工厂方法模式"),a("OutboundLink")],1),r._v(" （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂模式"),a("OutboundLink")],1),r._v("、 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型模式"),a("OutboundLink")],1),r._v("或"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器模式"),a("OutboundLink")],1),r._v(" （更灵活但更加复杂）。")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器"),a("OutboundLink")],1),r._v("重点关注如何分步生成复杂对象。 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂"),a("OutboundLink")],1),r._v("专门用于生产一系列相关对象。 "),a("em",[r._v("抽象工厂")]),r._v("会马上返回产品， "),a("em",[r._v("生成器")]),r._v("则允许你在获取产品前执行一些额外构造步骤。")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂模式"),a("OutboundLink")],1),r._v("通常基于一组"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"}},[r._v("工厂方法"),a("OutboundLink")],1),r._v("， 但你也可以使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型模式"),a("OutboundLink")],1),r._v("来生成这些类的方法。")]),r._v(" "),a("li",[r._v("当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂"),a("OutboundLink")],1),r._v("来代替"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/facade",target:"_blank",rel:"noopener noreferrer"}},[r._v("外观模式"),a("OutboundLink")],1),r._v("。")]),r._v(" "),a("li",[r._v("你可以将"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂"),a("OutboundLink")],1),r._v("和"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/bridge",target:"_blank",rel:"noopener noreferrer"}},[r._v("桥接模式"),a("OutboundLink")],1),r._v("搭配使用。 如果由"),a("em",[r._v("桥接")]),r._v("定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， "),a("em",[r._v("抽象工厂")]),r._v("可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂"),a("OutboundLink")],1),r._v("、 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器"),a("OutboundLink")],1),r._v("和"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型"),a("OutboundLink")],1),r._v("都可以用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[r._v("单例模式"),a("OutboundLink")],1),r._v("来实现。")])]),r._v(" "),a("h4",{attrs:{id:"说出工厂模式概念和优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说出工厂模式概念和优点"}},[r._v("#")]),r._v(" 说出工厂模式概念和优点？")]),r._v(" "),a("h4",{attrs:{id:"_3种工厂模式的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3种工厂模式的区别是什么"}},[r._v("#")]),r._v(" 3种工厂模式的区别是什么？")]),r._v(" "),a("p",[a("strong",[r._v("三者的共同点是：")])]),r._v(" "),a("p",[r._v("①都有两种作用不同的类：产品类和工厂类。其中，工厂类在自己的方法中实例化产品类（即使用 new 命令生成产品类的对象），并将生成的产品类的对象提供给外部使用。")]),r._v(" "),a("p",[r._v("② 创建的过程，都是类似的：工厂类得到一个标志（可以由程序输入，也可以读取配置文件中的内容），返回一个产品对象。")]),r._v(" "),a("p",[a("strong",[r._v("三种模式的区别：")])]),r._v(" "),a("p",[r._v("**简单工厂模式：**主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。\n**工厂方法模式：**修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。\n**抽象工厂模式：**定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。")]),r._v(" "),a("h4",{attrs:{id:"_3种模式的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3种模式的优缺点"}},[r._v("#")]),r._v(" 3种模式的优缺点")]),r._v(" "),a("p",[a("strong",[r._v("简单工厂")]),r._v("："),a("strong",[r._v("用来生产同一等级结构中的任意产品")]),r._v("，比如香蕉、苹果、梨就是同一等级结构中的三种商品。简单工厂通过一个含参的工厂方法，我们可以实例化任何产品类。\n从开闭原则的角度来看，"),a("strong",[r._v("简单工厂模式不符合开闭原则")]),r._v("，每次增加新的产品，都需要修改简单工厂类来适应新的产品。\n优点：简答工厂的有点是实现简单，\n缺点：(1) 在遵循开闭原则的前提下，扩展产品很困难。(2) 任何产品都通过简单工厂来实现，产品很多的情况下，简单工厂代码太重。\n**总结：**如果对象的创建逻辑都比较简单的时候，直接用new 来创建对象就可以了，推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。\n虽然也会有if逻辑判断，如果不是太复杂，也是可以接受的，也可以通过map来消除if判断。")]),r._v(" "),a("p",[a("strong",[r._v("工厂模式")]),r._v("："),a("strong",[r._v("用来生成同一等级结构中的固定产品")]),r._v("。工厂模式相当于将产品生产的操作提前，不由工厂来进行，工厂和产品呈现 1 对 1 的关系，所以，选择生产产品的变成了客户端，而不是工厂，客户端选择了工厂，意味着就选择了产品。增加新的产品，需要增加对应的工厂。\n优点：（1）允许系统在不修改工厂角色的情况下引进新产品。(2) "),a("strong",[r._v("符合开闭原则")]),r._v("，工厂和产品一旦建立，不会在进行代码的修改。如果有新的产品，属于扩展行为。\n缺点：(1) 每个新的产品对象的创建都需要创建专门的工厂类,实现复杂。\n**总结：**如果每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。\n同时，创建代码抽离到独立的工厂类之后可以方便复用。")]),r._v(" "),a("p",[a("strong",[r._v("抽象工厂")]),r._v("："),a("strong",[r._v("用来生成不同产品族的全部产品")]),r._v("，如果每个产品族只有一个产品，其实抽象工厂就类似工厂模式了。抽象工厂模式里边生成一系列产品利用的是类的组合。每个从工厂里都可以实例化一系列的产品，实现一个产品族的生产。\n**总结：**如果需要随时切换不同的系列产品，推荐使用抽象工厂模式，实现不同系列之间的隔离，快速切换工厂。")]),r._v(" "),a("h2",{attrs:{id:"生成器-建造者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成器-建造者模式"}},[r._v("#")]),r._v(" 生成器 -- 建造者模式")]),r._v(" "),a("p",[a("strong",[r._v("生成器模式")]),r._v("是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。")]),r._v(" "),a("p",[a("strong",[r._v("本质就是建造者模式；")])]),r._v(" "),a("p",[a("img",{attrs:{src:e(699),alt:"image-20210930110136180"}})]),r._v(" "),a("h3",{attrs:{id:"优点-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[r._v("#")]),r._v(" 优点")]),r._v(" "),a("ul",[a("li",[r._v("你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。")]),r._v(" "),a("li",[r._v("生成不同形式的产品时， 你可以复用相同的制造代码。")]),r._v(" "),a("li",[a("em",[r._v("单一职责原则")]),r._v("。 你可以将复杂构造代码从产品的业务逻辑中分离出来。")])]),r._v(" "),a("h3",{attrs:{id:"与其他模式关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与其他模式关系"}},[r._v("#")]),r._v(" 与其他模式关系")]),r._v(" "),a("ul",[a("li",[r._v("在许多设计工作的初期都会使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"}},[r._v("工厂方法模式"),a("OutboundLink")],1),r._v(" （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂模式"),a("OutboundLink")],1),r._v("、 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型模式"),a("OutboundLink")],1),r._v("或"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器模式"),a("OutboundLink")],1),r._v(" （更灵活但更加复杂）。")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器"),a("OutboundLink")],1),r._v("重点关注如何分步生成复杂对象。 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂"),a("OutboundLink")],1),r._v("专门用于生产一系列相关对象。 "),a("em",[r._v("抽象工厂")]),r._v("会马上返回产品， "),a("em",[r._v("生成器")]),r._v("则允许你在获取产品前执行一些额外构造步骤。")]),r._v(" "),a("li",[r._v("你可以在创建复杂"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/composite",target:"_blank",rel:"noopener noreferrer"}},[r._v("组合模式"),a("OutboundLink")],1),r._v("树时使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器"),a("OutboundLink")],1),r._v("， 因为这可使其构造步骤以递归的方式运行。")]),r._v(" "),a("li",[r._v("你可以结合使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器"),a("OutboundLink")],1),r._v("和"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/bridge",target:"_blank",rel:"noopener noreferrer"}},[r._v("桥接模式"),a("OutboundLink")],1),r._v("： "),a("em",[r._v("主管")]),r._v("类负责抽象工作， 各种不同的"),a("em",[r._v("生成器")]),r._v("负责"),a("em",[r._v("实现")]),r._v("工作。")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂"),a("OutboundLink")],1),r._v("、 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器"),a("OutboundLink")],1),r._v("和"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型"),a("OutboundLink")],1),r._v("都可以用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[r._v("单例模式"),a("OutboundLink")],1),r._v("来实现。")])]),r._v(" "),a("h2",{attrs:{id:"建造者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式"}},[r._v("#")]),r._v(" 建造者模式")]),r._v(" "),a("p",[a("img",{attrs:{src:e(700),alt:"image-20210927114451908"}})]),r._v(" "),a("h3",{attrs:{id:"应用场景-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-3"}},[r._v("#")]),r._v(" 应用场景？")]),r._v(" "),a("p",[r._v("相同的方法，不同的执行顺序，产生不同的结果。\n多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。\n产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。\n初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。")]),r._v(" "),a("h3",{attrs:{id:"建造者模式与工厂模式的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式与工厂模式的区别"}},[r._v("#")]),r._v(" 建造者模式与工厂模式的区别？")]),r._v(" "),a("p",[r._v("工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象，工厂模式会马上返回创建的对象。")]),r._v(" "),a("p",[r._v("建造者模式重点关注如何分步生成复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象，允许你在获取对象前执行一些额外构造步骤。")]),r._v(" "),a("h3",{attrs:{id:"优点-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点-4"}},[r._v("#")]),r._v(" 优点？")]),r._v(" "),a("p",[r._v("封装性好，构建和表示分离；\n符合"),a("strong",[r._v("单一职责原则")]),r._v("，你可以将复杂构造代码从产品的业务逻辑中分离出来；\n便于控制细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响；")]),r._v(" "),a("h3",{attrs:{id:"缺点-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[r._v("#")]),r._v(" 缺点？")]),r._v(" "),a("p",[r._v("需要新增多个类， 因此代码整体复杂程度会有所增加；\n如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大；")]),r._v(" "),a("h2",{attrs:{id:"单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[r._v("#")]),r._v(" 单例模式")]),r._v(" "),a("p",[a("img",{attrs:{src:e(701),alt:"image-20210930115916805"}})]),r._v(" "),a("h3",{attrs:{id:"单例模式有几种创建方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式有几种创建方式"}},[r._v("#")]),r._v(" 单例模式有几种创建方式？")]),r._v(" "),a("p",[r._v("普通单例模式、饿汉单例模式、懒汉单例模式、双重检测（java）。")]),r._v(" "),a("p",[a("strong",[r._v("饿汉式")]),r._v("\n饿汉式的实现方式，在类加载的期间，就已经将静态实例初始化好了，所以，实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。")]),r._v(" "),a("p",[a("strong",[r._v("懒汉式")]),r._v("\n懒汉式相对于饿汉式的优势是支持延迟加载。但是，这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。")]),r._v(" "),a("p",[a("strong",[r._v("双重检测")]),r._v("\n双重检测的实现方式是既支持延迟加载、又支持高并发的单例实现方式。只要实例被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。")]),r._v(" "),a("h4",{attrs:{id:"分别写出饿汉和懒汉线程安全的单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分别写出饿汉和懒汉线程安全的单例模式"}},[r._v("#")]),r._v(" 分别写出饿汉和懒汉线程安全的单例模式？")]),r._v(" "),a("h4",{attrs:{id:"单例模式的线程安全问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式的线程安全问题"}},[r._v("#")]),r._v(" 单例模式的线程安全问题？")]),r._v(" "),a("h4",{attrs:{id:"单例模式怎么处理多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式怎么处理多线程"}},[r._v("#")]),r._v(" 单例模式怎么处理多线程？")]),r._v(" "),a("p",[r._v("懒汉式，加锁；饿汉式，初始化时静态实例已创建好；")]),r._v(" "),a("h3",{attrs:{id:"优点-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点-5"}},[r._v("#")]),r._v(" 优点")]),r._v(" "),a("ul",[a("li",[r._v("你可以保证一个类只有一个实例。")]),r._v(" "),a("li",[r._v("你获得了一个指向该实例的全局访问节点。")]),r._v(" "),a("li",[r._v("仅在首次请求单例对象时对其进行初始化。")])]),r._v(" "),a("h3",{attrs:{id:"缺点-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-4"}},[r._v("#")]),r._v(" 缺点")]),r._v(" "),a("ul",[a("li",[r._v("违反了_单一职责原则_。 该模式同时解决了两个问题。")]),r._v(" "),a("li",[r._v("单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。")]),r._v(" "),a("li",[r._v("该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。")]),r._v(" "),a("li",[r._v("单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。")])]),r._v(" "),a("h3",{attrs:{id:"应用场景-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-4"}},[r._v("#")]),r._v(" 应用场景")]),r._v(" "),a("ul",[a("li",[r._v("如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。")]),r._v(" "),a("li",[r._v("如果你需要更加严格地控制全局变量，可以使用单例模式。")])]),r._v(" "),a("h3",{attrs:{id:"与其他模式关系-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与其他模式关系-2"}},[r._v("#")]),r._v(" 与其他模式关系")]),r._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/facade",target:"_blank",rel:"noopener noreferrer"}},[r._v("外观模式"),a("OutboundLink")],1),r._v("类通常可以转换为"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[r._v("单例模式"),a("OutboundLink")],1),r._v("类， 因为在大部分情况下一个外观对象就足够了。")]),r._v(" "),a("li",[r._v("如果你能将对象的所有共享状态简化为一个享元对象， 那么"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/flyweight",target:"_blank",rel:"noopener noreferrer"}},[r._v("享元模式"),a("OutboundLink")],1),r._v("就和"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[r._v("单例"),a("OutboundLink")],1),r._v("类似了。 但这两个模式有两个根本性的不同。\n"),a("ol",[a("li",[r._v("只会有一个单例实体， 但是"),a("em",[r._v("享元")]),r._v("类可以有多个实体， 各实体的内在状态也可以不同。")]),r._v(" "),a("li",[a("em",[r._v("单例")]),r._v("对象可以是可变的。 享元对象是不可变的。")])])]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂模式"),a("OutboundLink")],1),r._v("、 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器模式"),a("OutboundLink")],1),r._v("和"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型模式"),a("OutboundLink")],1),r._v("都可以用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[r._v("单例"),a("OutboundLink")],1),r._v("来实现。")])]),r._v(" "),a("h2",{attrs:{id:"原型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[r._v("#")]),r._v(" 原型模式")]),r._v(" "),a("p",[a("strong",[r._v("原型模式")]),r._v("是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。")]),r._v(" "),a("h3",{attrs:{id:"模式结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模式结构"}},[r._v("#")]),r._v(" 模式结构")]),r._v(" "),a("p",[a("img",{attrs:{src:e(702),alt:"image-20210930112019896"}})]),r._v(" "),a("h3",{attrs:{id:"浅拷贝和深拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝和深拷贝"}},[r._v("#")]),r._v(" 浅拷贝和深拷贝？")]),r._v(" "),a("h3",{attrs:{id:"优点-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点-6"}},[r._v("#")]),r._v(" 优点？")]),r._v(" "),a("p",[r._v("可以克隆对象， 而无需与它们所属的具体类相耦合；\n可以克隆预生成原型， 避免反复运行初始化代码；\n可以更方便地生成复杂对象；\n可以用继承以外的方式来处理复杂对象的不同配置；")]),r._v(" "),a("h3",{attrs:{id:"缺点-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-5"}},[r._v("#")]),r._v(" 缺点？")]),r._v(" "),a("p",[r._v("克隆包含循环引用的复杂对象可能会非常麻烦；\n每一个类都得配备一个clone方法，且该方法位于类的内部，修改时违背开闭原则；")]),r._v(" "),a("h3",{attrs:{id:"适用环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用环境"}},[r._v("#")]),r._v(" 适用环境？")]),r._v(" "),a("p",[r._v("当创建新的对象实例较为复杂时，原型模式可以简化创建过程；\n结合优点第3条，需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少几个的组合状态，通过复制原型对象得到新实例，比通过使用构造函数创建一个新实例会更加方便。")]),r._v(" "),a("h3",{attrs:{id:"与其他模式的关系-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与其他模式的关系-3"}},[r._v("#")]),r._v(" 与其他模式的关系")]),r._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂模式"),a("OutboundLink")],1),r._v("通常基于一组"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"}},[r._v("工厂方法"),a("OutboundLink")],1),r._v("， 但你也可以使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型模式"),a("OutboundLink")],1),r._v("来生成这些类的方法。")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型"),a("OutboundLink")],1),r._v("可用于保存"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/command",target:"_blank",rel:"noopener noreferrer"}},[r._v("命令模式"),a("OutboundLink")],1),r._v("的历史记录。")]),r._v(" "),a("li",[r._v("大量使用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/composite",target:"_blank",rel:"noopener noreferrer"}},[r._v("组合模式"),a("OutboundLink")],1),r._v("和"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/decorator",target:"_blank",rel:"noopener noreferrer"}},[r._v("装饰模式"),a("OutboundLink")],1),r._v("的设计通常可从对于"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型"),a("OutboundLink")],1),r._v("的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型"),a("OutboundLink")],1),r._v("并不基于继承， 因此没有继承的缺点。 另一方面， "),a("em",[r._v("原型")]),r._v("需要对被复制对象进行复杂的初始化。 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"}},[r._v("工厂方法"),a("OutboundLink")],1),r._v("基于继承， 但是它不需要初始化步骤。")]),r._v(" "),a("li",[r._v("有时候"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型"),a("OutboundLink")],1),r._v("可以作为"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/memento",target:"_blank",rel:"noopener noreferrer"}},[r._v("备忘录模式"),a("OutboundLink")],1),r._v("的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[r._v("抽象工厂"),a("OutboundLink")],1),r._v("、 "),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[r._v("生成器"),a("OutboundLink")],1),r._v("和"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[r._v("原型"),a("OutboundLink")],1),r._v("都可以用"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[r._v("单例模式"),a("OutboundLink")],1),r._v("来实现。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);