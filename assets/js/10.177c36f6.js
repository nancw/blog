(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{703:function(t,r,a){t.exports=a.p+"assets/img/image-20210929112042772-16372148519301.18efc560.png"},704:function(t,r,a){t.exports=a.p+"assets/img/image-20210930143537147-16372148519312.7bd4fbff.png"},705:function(t,r,a){t.exports=a.p+"assets/img/image-20210929112027432-16372148519313.c5ac037a.png"},706:function(t,r,a){t.exports=a.p+"assets/img/image-20210930143524284-16372148519314.14d37318.png"},707:function(t,r,a){t.exports=a.p+"assets/img/image-20210929134330608-16372148519315.98119322.png"},708:function(t,r,a){t.exports=a.p+"assets/img/image-20210930150616501-16372148519316.d8325bc0.png"},709:function(t,r,a){t.exports=a.p+"assets/img/image-20210929140727413-16372148519317.5dbafb39.png"},710:function(t,r,a){t.exports=a.p+"assets/img/image-20210929145148242-16372148519318.8f861fe9.png"},711:function(t,r,a){t.exports=a.p+"assets/img/image-20210930150744899-16372148519319.e092b605.png"},712:function(t,r,a){t.exports=a.p+"assets/img/image-20210929160319588-163721485193110.cee671c8.png"},713:function(t,r,a){t.exports=a.p+"assets/img/image-20210930150848347-163721485193111.9c9a8715.png"},714:function(t,r,a){t.exports=a.p+"assets/img/image-20210929163129888-163721485193112.82b9edfb.png"},715:function(t,r,a){t.exports=a.p+"assets/img/image-20210930150945129-163721485193113.9aebdc11.png"},716:function(t,r,a){t.exports=a.p+"assets/img/image-20210929162450038-163721485193114.d25dee4f.png"},717:function(t,r,a){t.exports=a.p+"assets/img/image-20210930135634441-163721485193115.46ee89ad.png"},854:function(t,r,a){"use strict";a.r(r);var e=a(12),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#适配器模式"}},[t._v("适配器模式")])]),e("li",[e("a",{attrs:{href:"#桥接模式"}},[t._v("桥接模式")])]),e("li",[e("a",{attrs:{href:"#组合模式"}},[t._v("组合模式")])]),e("li",[e("a",{attrs:{href:"#装饰模式"}},[t._v("装饰模式")])]),e("li",[e("a",{attrs:{href:"#外观模式"}},[t._v("外观模式")])]),e("li",[e("a",{attrs:{href:"#代理模式"}},[t._v("代理模式")])]),e("li",[e("a",{attrs:{href:"#享元模式"}},[t._v("享元模式")])])])]),e("p"),t._v(" "),e("h1",{attrs:{id:"结构型模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[t._v("#")]),t._v(" 结构型模式")]),t._v(" "),e("h2",{attrs:{id:"适配器模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[t._v("#")]),t._v(" 适配器模式")]),t._v(" "),e("p",[t._v("适配器模式，将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。")]),t._v(" "),e("h3",{attrs:{id:"模式结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模式结构"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),e("p",[t._v("适配器类（Adapter）：适配器与适配者之间是继承或实现关系；\n适配者类（Adaptee）：适配器与适配者之间是关联关系；\n目标抽象类（Target）：定义客户所需要的接口；")]),t._v(" "),e("h4",{attrs:{id:"_1-类适配器模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-类适配器模式"}},[t._v("#")]),t._v(" "),e("strong",[t._v("① 类适配器模式")])]),t._v(" "),e("p",[e("img",{attrs:{src:a(703),alt:"image-20210929112042772"}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(704),alt:"image-20210930143537147"}})]),t._v(" "),e("h4",{attrs:{id:"_2-对象适配器模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-对象适配器模式"}},[t._v("#")]),t._v(" "),e("strong",[t._v("② 对象适配器模式")])]),t._v(" "),e("p",[e("img",{attrs:{src:a(705),alt:"image-20210929112027432"}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(706),alt:"image-20210930143524284"}})]),t._v(" "),e("h3",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("p",[t._v("将目标类和适配者类解耦，引入一个适配器类实现代码重用，无需修改原有结构；\n增加类的透明和复用，对于客户端而言，适配者类是透明的；\n对象适配器可以把不同适配者适配到同一个目标（对象适配器）；\n单一职责原则_你可以将接口或数据转换代码从程序主要业务逻辑中分离。\n"),e("em",[t._v("开闭原则")]),t._v("。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。")]),t._v(" "),e("h3",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("p",[t._v("对编程语言的限制：Java不支持多重继承，一次最多只能适配一个适配者类，不能同时适配多个适配者类；")]),t._v(" "),e("h3",{attrs:{id:"适用环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用环境"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),e("p",[t._v("系统需要使用一些现有的类，但这些类的接口不符合系统需要，或者没有这些类的源代码；\n想创建一个重复使用的类，用于和一些彼此没有太大关联的类一起工作。")]),t._v(" "),e("h3",{attrs:{id:"与其他模式的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与其他模式的关系"}},[t._v("#")]),t._v(" 与其他模式的关系")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/bridge",target:"_blank",rel:"noopener noreferrer"}},[t._v("桥接模式"),e("OutboundLink")],1),t._v("通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， "),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/adapter",target:"_blank",rel:"noopener noreferrer"}},[t._v("适配器模式"),e("OutboundLink")],1),t._v("通常在已有程序中使用， 让相互不兼容的类能很好地合作。")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/adapter",target:"_blank",rel:"noopener noreferrer"}},[t._v("适配器"),e("OutboundLink")],1),t._v("可以对已有对象的接口进行修改， "),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/decorator",target:"_blank",rel:"noopener noreferrer"}},[t._v("装饰模式"),e("OutboundLink")],1),t._v("则能在不改变对象接口的前提下强化对象功能。 此外， "),e("em",[t._v("装饰")]),t._v("还支持递归组合， "),e("em",[t._v("适配器")]),t._v("则无法实现。")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/adapter",target:"_blank",rel:"noopener noreferrer"}},[t._v("适配器"),e("OutboundLink")],1),t._v("能为被封装对象提供不同的接口， "),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/proxy",target:"_blank",rel:"noopener noreferrer"}},[t._v("代理模式"),e("OutboundLink")],1),t._v("能为对象提供相同的接口， "),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/decorator",target:"_blank",rel:"noopener noreferrer"}},[t._v("装饰"),e("OutboundLink")],1),t._v("则能为对象提供加强的接口。")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/facade",target:"_blank",rel:"noopener noreferrer"}},[t._v("外观模式"),e("OutboundLink")],1),t._v("为现有对象定义了一个新接口， "),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/adapter",target:"_blank",rel:"noopener noreferrer"}},[t._v("适配器"),e("OutboundLink")],1),t._v("则会试图运用已有的接口。 "),e("em",[t._v("适配器")]),t._v("通常只封装一个对象， "),e("em",[t._v("外观")]),t._v("通常会作用于整个对象子系统上。")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/bridge",target:"_blank",rel:"noopener noreferrer"}},[t._v("桥接"),e("OutboundLink")],1),t._v("、 "),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/state",target:"_blank",rel:"noopener noreferrer"}},[t._v("状态模式"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/strategy",target:"_blank",rel:"noopener noreferrer"}},[t._v("策略模式"),e("OutboundLink")],1),t._v(" （在某种程度上包括"),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/adapter",target:"_blank",rel:"noopener noreferrer"}},[t._v("适配器"),e("OutboundLink")],1),t._v("） 模式的接口非常相似。 实际上， 它们都基于"),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/composite",target:"_blank",rel:"noopener noreferrer"}},[t._v("组合模式"),e("OutboundLink")],1),t._v("——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。")])]),t._v(" "),e("h2",{attrs:{id:"桥接模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#桥接模式"}},[t._v("#")]),t._v(" 桥接模式")]),t._v(" "),e("p",[e("strong",[t._v("桥接模式")]),t._v("是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。")]),t._v(" "),e("p",[t._v("定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。")]),t._v(" "),e("p",[t._v("而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。")]),t._v(" "),e("h3",{attrs:{id:"模式结构-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-2"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),e("p",[e("strong",[t._v("Abstraction（抽象类）")]),t._v("：定义抽象类的接口（抽象接口），由聚合关系可知，抽象类中包含一个Implementor类型的对象，它与Implementor之间有关联关系，既可以包含抽象业务方法，也可以包含具体业务方法；\n"),e("strong",[t._v("Implementor（实现类接口）")]),t._v("：定义实现类的接口，这个接口可以与Abstraction类的接口不同。一般而言，实现类接口只定义基本操作，而抽象类的接口还可能会做更多复杂的操作。\n"),e("strong",[t._v("RefinedAbstraction（扩充抽象类）")]),t._v("：具体类，实现在抽象类中定义的接口，可以调用在Implementor中定义的方法；\n"),e("strong",[t._v("ConcreteImplementor（具体实现类）")]),t._v("：具体实现了Implementor接口，在不同的具体实现类中实现不同的具体操作。运行时ConcreteImplementor将替换父类。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(707),alt:"image-20210929134330608"}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(708),alt:"image-20210930150616501"}})]),t._v(" "),e("h3",{attrs:{id:"桥接模式和策略模式的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#桥接模式和策略模式的区别"}},[t._v("#")]),t._v(" 桥接模式和策略模式的区别？")]),t._v(" "),e("p",[t._v("策略模式（Strategy）的与桥接模式（Bridge）看起来很像，其实它们之间有很大的区别：策略模式改变对象的行为，而桥接模式改变类的结构。")]),t._v(" "),e("p",[t._v("策略模式是行为型的动态模式，解决对象和对象间的调用问题（研究如何在程序运行中改变对象的行为）。")]),t._v(" "),e("p",[t._v("桥接模式是一种结构型的模式，解决类和类之间的结构问题（研究如何重新构建类的结构）。")]),t._v(" "),e("p",[t._v("这两种设计模式的意图是不相同的。")]),t._v(" "),e("h3",{attrs:{id:"优点-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("p",[t._v("分离抽象接口与实现部分，使用对象间的关联关系使抽象与实现解耦；\n桥接模式可以取代多层继承关系，多层继承违背单一职责原则，不利于代码复用；\n桥接模式提高了系统可扩展性，某个维度需要扩展只需增加实现类接口或者具体实现类，而且不影响另一个维度，符合开闭原则。")]),t._v(" "),e("h3",{attrs:{id:"缺点-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("p",[t._v("桥接模式难以理解，因为关联关系建立在抽象层，需要一开始就设计抽象层；\n如何准确识别系统中的两个维度是应用桥接模式的难点。")]),t._v(" "),e("h3",{attrs:{id:"适用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),e("p",[t._v("如果一个系统需要在抽象化和具体化之间增加灵活性，避免在两个层次之间增加继承关系，可以使用桥接模式在抽象层建立关联关系；\n抽象部分和实现部分可以各自扩展而互不影响；\n一个类存在多个独立变化的维度，可采用桥接模式。")]),t._v(" "),e("h2",{attrs:{id:"组合模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组合模式"}},[t._v("#")]),t._v(" 组合模式")]),t._v(" "),e("p",[t._v("组合模式，组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。")]),t._v(" "),e("h3",{attrs:{id:"模式结构-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-3"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),e("p",[e("strong",[t._v("Component（抽象构件）")]),t._v("：Component是一个抽象类，定义了构件的一些公共接口，这些接口是管理或者访问它的子构件的方法（如果有子构件），具体的实现在叶子构件和容器构件中进行。")]),t._v(" "),e("p",[t._v("Leaf（叶子构件）：它代表树形结构中的叶子节点对象，叶子构件没有子节点，它实现了在抽象构件中定义的行为。对于抽象构件定义的管理子构件的方法，叶子构件可以通过抛出异常、提示错误等方式进行处理。")]),t._v(" "),e("p",[e("strong",[t._v("Composite（容器构件）")]),t._v(" ：容器构件一方面具体实现公共接口，另一方面通过聚合关系包含子构件，子构件可以是容器构件，也可以是叶子构件。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(709),alt:"image-20210929140727413"}})]),t._v(" "),e("h4",{attrs:{id:"透明组合模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#透明组合模式"}},[t._v("#")]),t._v(" "),e("strong",[t._v("透明组合模式")])]),t._v(" "),e("p",[t._v("如UML图所示，组合模式分为透明组合模式和安全组合模式。在透明组合模式中，抽象构件Component声明了add、remove、getChild等所有管理和访问子构件的方法，不论是叶子构件还容器构件都具有相同的接口。客户端在使用时可以一致地对待所有对象，即具体是叶子构件还是容器构件，对客户端而言是透明的，因为它们都暴露相同的接口。\n但是，叶子构件是没有子构件的，所有就没有add、remove和getChild方法的，所以必须在叶子构件的实现中提供相应的错误处理代码，否则代码会出错。")]),t._v(" "),e("h4",{attrs:{id:"安全组合模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安全组合模式"}},[t._v("#")]),t._v(" "),e("strong",[t._v("安全组合模式")])]),t._v(" "),e("p",[t._v("在安全组合模式中，抽象构件Component没有声明任何管理和访问子构件的方法，在具体的实现类中才去定义这些行为。之所以叫“安全”，是因为叶子构件没有子构件，也就不必定义管理访问子构件的方法，对客户端而言，当它处理子构件时，不可能调用到类似透明组合模式中的子构件的add、remove等方法，因此也就不会出错。\n安全模式的不足在于不够透明，客户端使用时必须有区别的对待叶子构件和容器构件；")]),t._v(" "),e("h3",{attrs:{id:"优点-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("p",[t._v("清楚地定义分层次的复杂对象，表示出复杂对象的层次结构，让客户端忽略层次的差异；\n客户端可以一致地使用层次结构中各个层次的对象，而不必关心其具体构件的行为如何实现；\n在组合模式中增加新的叶子构件和容器构件非常方便，易于扩展，符合开闭原则；\n为树形结构的案例提供了解决方案。")]),t._v(" "),e("h3",{attrs:{id:"缺点-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("p",[t._v("子构件或容器构件的行为受限制，因为它们来自相同的抽象层。如果要定义某个容器或者某个叶子节点特有的方法，那么要求在运行时判断对象类型，增加了代码的复杂度。")]),t._v(" "),e("h3",{attrs:{id:"适用场景-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-2"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),e("p",[t._v("系统中需要用到树形结构；\n系统中能够分离出容器节点和叶子节点；\n具有整体和部门的层次结构中，能够通过某种方式忽略层次差异，使得客户端可以一致对待。")]),t._v(" "),e("h2",{attrs:{id:"装饰模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#装饰模式"}},[t._v("#")]),t._v(" 装饰模式")]),t._v(" "),e("p",[e("strong",[t._v("装饰模式")]),t._v("是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。")]),t._v(" "),e("h3",{attrs:{id:"模式结构-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-4"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),e("p",[e("strong",[t._v("Component（抽象构件）")]),t._v("：是具体构件类和装饰类的共同基类，声明了在具体构件中定义的方法，客户端可以一致的对待使用装饰前后的对象；")]),t._v(" "),e("p",[e("strong",[t._v("ConcreteComponent（具体构件）")]),t._v("：具体构件定义了构件具体的方法，装饰类可以给它增加更多的功能；")]),t._v(" "),e("p",[e("strong",[t._v("Decorator（抽象装饰类）")]),t._v("：用于给具体构件增加职责，但具体职责在其子类中实现。抽象装饰类通过聚合关系定义一个抽象构件的对象，通过该对象可以调用装饰之前构件的方法，并通过其子类扩展该方法，达到装饰的目的；")]),t._v(" "),e("p",[e("strong",[t._v("ConcreteDecorator（具体装饰类）")]),t._v("：向构件增加新的功能。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(710),alt:"image-20210929145148242"}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(711),alt:"image-20210930150744899"}})]),t._v(" "),e("h3",{attrs:{id:"优点-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-4"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("p",[t._v("对于扩展一个类的新功能，装饰模式比继承更加灵活；\n动态扩展一个对象的功能；\n可以对一个对象进行多次装饰（如上述例子第二个手机和第三个手机）；\n具体构件类和具体装饰类可以独立变化和扩展，符合开闭原则。")]),t._v(" "),e("h3",{attrs:{id:"缺点-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点-4"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("p",[t._v("装饰模式中会增加很多小的对象，对象的区别主要在于各种装饰的连接方式不同，而并不是职责不同，大量小对象的产生会占用较多的系统资源；\n装饰模式比继承模式更灵活，但也更容易出错，更难于排错。")]),t._v(" "),e("h3",{attrs:{id:"适用场景-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-3"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),e("p",[t._v("在不影响其他对象的情况下，给单个对象动态扩展职责；\n不适宜采用继承的方式进行扩展的时候，可以考虑使用装饰模式；")]),t._v(" "),e("h2",{attrs:{id:"外观模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#外观模式"}},[t._v("#")]),t._v(" 外观模式")]),t._v(" "),e("p",[e("strong",[t._v("外观模式")]),t._v("是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。")]),t._v(" "),e("h3",{attrs:{id:"模式结构-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-5"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),e("p",[e("strong",[t._v("Facade（外观角色）")]),t._v("：外观角色可以知道多个相关子系统的功能，它将所有从客户端发来的请求委派给相应的子系统，传递给相应的子系统处理。")]),t._v(" "),e("p",[e("strong",[t._v("SubSystem（子系统角色）")]),t._v("：子系统是一个类，或者由多个类组成的类的集合，它实现子系统具体的功能。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(712),alt:"image-20210929160319588"}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(713),alt:"image-20210930150848347"}})]),t._v(" "),e("h3",{attrs:{id:"优点-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-5"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("p",[t._v("外观模式使得客户端不必关心子系统组件，减少了与客户端交互的对象的数量，简化了客户端的编程；\n外观模式可以大大降低系统的耦合度；\n子系统的变化并不需要修改客户端，只需要适当修改外观类即可；\n子系统之间不会相互影响。")]),t._v(" "),e("h3",{attrs:{id:"缺点-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点-5"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("p",[t._v("如果需要增加或者减少子系统，需要修改外观类，违反开闭原则；\n并不能限制客户端直接与子系统交互，但如果加强限制，又使得系统灵活度降低。")]),t._v(" "),e("h3",{attrs:{id:"适用场景-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-4"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),e("p",[t._v("为访问一系列复杂的子系统提供一个统一的、简单的入口，可以使用外观模式；\n客户端与多个子系统之间存在很大依赖，但在客户端编程，又会增加系统耦合度，且使客户端编程复杂，可以使用外观模式。")]),t._v(" "),e("h2",{attrs:{id:"代理模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[t._v("#")]),t._v(" 代理模式")]),t._v(" "),e("p",[e("strong",[t._v("代理模式")]),t._v("是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。")]),t._v(" "),e("h3",{attrs:{id:"模式结构-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-6"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),e("p",[e("strong",[t._v("抽象主题角色（Subject）")]),t._v("：声明了代理主题角色和真实主题角色共同的一些接口，因此在任何可以使用真实主题对象的地方都可以使用代理主题角色（想一想代购是不是也是这样？），客户端通常针对抽象主题编程；")]),t._v(" "),e("p",[e("strong",[t._v("代理主题角色（Proxy）")]),t._v("：代理主题角色通过关联关系引用真实主题角色，因此可以控制和操纵真实主题对象；代理主题角色中提供一个与真实主题角色相同的接口（以在需要时代替真实主题角色），同时还可以在调用对真实主题对象的操作之前或之后增加新的服务和功能；")]),t._v(" "),e("p",[e("strong",[t._v("真实主题角色（RealSubject）")]),t._v("：真实主题角色是代理角色所代表的真实对象，提供真正的业务操作，客户端可以通过代理主题角色间接地调用真实主题角色中定义的操作。")]),t._v(" "),e("p",[t._v("在实际开发过程中，代理模式产生了很多类型：\n远程代理（Remote Proxy）：为一个位于不同地址空间的对象提供一个本地的代理对象。不同的地址空间可以在相同或不同的主机中。\n虚拟代理（Virtual Proxy）：当创建一个对象需要消耗大量资源时，可以先创建一个消耗较少资源的虚拟代理来表示，当真正需要时再创建。\n保护代理（Protect Proxy）：给不同的用户提供不同的对象访问权限。\n缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时存储空间，以使更多用户可以共享这些结果。\n智能引用代理（Smart Reference Proxy）：当一个对象被引用时提供一些额外的操作，比如将对象被调用的次数记录下来等。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(714),alt:"image-20210929163129888"}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(715),alt:"image-20210930150945129"}})]),t._v(" "),e("h3",{attrs:{id:"优点-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-6"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("p",[t._v("代理模式能够协调调用者和被调用者，降低系统耦合度；\n客户端针对抽象主题角色编程，如果要增加或替换代理类，无需修改源代码，符合开闭原则，系统扩展性好；\n远程代理优点：为两个位于不同地址空间的对象的访问提供解决方案，可以将一些资源消耗较多的对象移至性能较好的计算机上，提高系统整体性能；\n虚拟代理优点：通过一个资源消耗较少的对象来代表一个消耗资源较多的对象，节省系统运行开销；\n缓冲代理优点：为某一个操作结果提供临时的存储空间，可以在后续操作中使用这些结果，缩短了执行时间；\n保护代理优点：:控制对一个对象的访问权限，为不同客户提供不同的访问权限。")]),t._v(" "),e("h3",{attrs:{id:"缺点-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点-6"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("p",[t._v("增加了代理类和代理对象，增加了代理对象中的某些处理流程，可能会使得系统响应变慢；\n有的代理模式（如远程代理）实现代码较为复杂。")]),t._v(" "),e("h3",{attrs:{id:"适用环境-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-2"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),e("p",[t._v("当客户端对象需要访问远程主机中的对象——可以使用远程代理；\n当需要用一个资源消耗较少的对象来代表一个资源消耗较多的对象——虚拟代理；\n当需要限制不同用户对一个独享的访问权限——保护代理；\n当需要为一个频繁访问的操作结果提供临时存储空间——缓冲代理；\n当需要为一个对象的访问提供一些额外的操作——智能引用代理。")]),t._v(" "),e("h2",{attrs:{id:"享元模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#享元模式"}},[t._v("#")]),t._v(" 享元模式")]),t._v(" "),e("p",[t._v("享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。 系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。")]),t._v(" "),e("h3",{attrs:{id:"模式结构-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-7"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),e("p",[e("code",[t._v("Flyweight")]),t._v(": 抽象享元类；\n"),e("code",[t._v("ConcreteFlyweight")]),t._v(": 具体享元类；\n"),e("code",[t._v("UnsharedConcreteFlyweight")]),t._v(": 非共享具体享元类；\n"),e("code",[t._v("FlyweightFactory")]),t._v(": 享元工厂类；")]),t._v(" "),e("p",[e("img",{attrs:{src:a(716),alt:"image-20210929162450038"}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(717),alt:"image-20210930135634441"}})]),t._v(" "),e("h3",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),e("p",[t._v("意义：运用共享技术有效支持大量细粒度对象的复用。内部状态可以共享。")]),t._v(" "),e("p",[t._v("内部状态：包含不变的、 可在许多对象中重复使用的成员变量。")]),t._v(" "),e("p",[t._v("外部状态：包含每个对象各自不同的场景的成员变量。")]),t._v(" "),e("p",[t._v("抽象享元类、具体享元类、非共享具体享元类、享元工厂类。")]),t._v(" "),e("h3",{attrs:{id:"优点-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-7"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("p",[t._v("享元模式通过享元池存储已经创建好的享元对象，实现相同或相似的细粒度对象的复用，大大减少了系统中的对象数量，节约了内存空间，提升了系统性能；\n享元模式通过内部状态和外部状态的区分，外部状态相互独立，客户端可以根据需求任意使用。")]),t._v(" "),e("h3",{attrs:{id:"缺点-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点-7"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("p",[t._v("享元模式需要增加逻辑来取分出内部状态和外部状态，增加了编程的复杂度；")]),t._v(" "),e("h3",{attrs:{id:"适用环境-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-3"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),e("p",[t._v("当一个系统中有大量重复使用的相同或相似对象时，使用享元模式可以节约系统资源；\n对象的大部分状态都可以外部化，可以将这些状态传入对象中；")]),t._v(" "),e("h3",{attrs:{id:"享元模式和单例模式的不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#享元模式和单例模式的不同"}},[t._v("#")]),t._v(" 享元模式和单例模式的不同？")]),t._v(" "),e("p",[t._v("在享元模式中，一个类可以创建多个对象；而在单例模式中，一个类只能创建一个对象；\n享元模式的意图是为了复用对象，节省内存；单例模式的意图是为了控制对象的个数；")]),t._v(" "),e("h3",{attrs:{id:"与其他模式的关系-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与其他模式的关系-2"}},[t._v("#")]),t._v(" 与其他模式的关系")]),t._v(" "),e("ul",[e("li",[t._v("你可以使用"),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/flyweight",target:"_blank",rel:"noopener noreferrer"}},[t._v("享元模式"),e("OutboundLink")],1),t._v("实现"),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/composite",target:"_blank",rel:"noopener noreferrer"}},[t._v("组合模式"),e("OutboundLink")],1),t._v("树的共享叶节点以节省内存。")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/flyweight",target:"_blank",rel:"noopener noreferrer"}},[t._v("享元"),e("OutboundLink")],1),t._v("展示了如何生成大量的小型对象， "),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/facade",target:"_blank",rel:"noopener noreferrer"}},[t._v("外观模式"),e("OutboundLink")],1),t._v("则展示了如何用一个对象来代表整个子系统。")]),t._v(" "),e("li",[t._v("如果你能将对象的所有共享状态简化为一个享元对象， 那么"),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/flyweight",target:"_blank",rel:"noopener noreferrer"}},[t._v("享元"),e("OutboundLink")],1),t._v("就和"),e("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[t._v("单例模式"),e("OutboundLink")],1),t._v("类似了。 但这两个模式有两个根本性的不同。\n"),e("ol",[e("li",[t._v("只会有一个单例实体， 但是"),e("em",[t._v("享元")]),t._v("类可以有多个实体， 各实体的内在状态也可以不同。")]),t._v(" "),e("li",[e("em",[t._v("单例")]),t._v("对象可以是可变的。 享元对象是不可变的。")])])])]),t._v(" "),e("h3",{attrs:{id:"参考链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[t._v("#")]),t._v(" 参考链接")]),t._v(" "),e("p",[t._v("[享元模式-大量飞龙](")])])}),[],!1,null,null,null);r.default=s.exports}}]);