(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{718:function(t,a,s){t.exports=s.p+"assets/img/image-20210927153531314.db9c0328.png"},719:function(t,a,s){t.exports=s.p+"assets/img/image-20210928092351227.47100c03.png"},720:function(t,a,s){t.exports=s.p+"assets/img/image-20210928094625604.78ef5b7e.png"},721:function(t,a,s){t.exports=s.p+"assets/img/image-20210928095720592.6517be2d.png"},722:function(t,a,s){t.exports=s.p+"assets/img/image-20210928105153620.34955bca.png"},723:function(t,a,s){t.exports=s.p+"assets/img/image-20210928115729951.e6c43046.png"},724:function(t,a,s){t.exports=s.p+"assets/img/image-20210928141704234.0e94836c.png"},725:function(t,a,s){t.exports=s.p+"assets/img/image-20210930151035082.3e26c60e.png"},726:function(t,a,s){t.exports=s.p+"assets/img/640.d5407ba1.png"},727:function(t,a,s){t.exports=s.p+"assets/img/image-20210930151955188.1a9398a1.png"},728:function(t,a,s){t.exports=s.p+"assets/img/image-20210928154657103.af592b55.png"},729:function(t,a,s){t.exports=s.p+"assets/img/image-20210928160130671.7fd2f53d.png"},730:function(t,a,s){t.exports=s.p+"assets/img/image-20210928162005183.aa5506c2.png"},855:function(t,a,s){"use strict";s.r(a);var r=s(12),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#职责链模式"}},[t._v("职责链模式")])]),r("li",[r("a",{attrs:{href:"#策略模式"}},[t._v("策略模式")])]),r("li",[r("a",{attrs:{href:"#观察者模式"}},[t._v("观察者模式")])]),r("li",[r("a",{attrs:{href:"#模板方法模式"}},[t._v("模板方法模式")])]),r("li",[r("a",{attrs:{href:"#状态模式"}},[t._v("状态模式")])]),r("li",[r("a",{attrs:{href:"#命令模式"}},[t._v("命令模式")])]),r("li",[r("a",{attrs:{href:"#中介者模式"}},[t._v("中介者模式")])]),r("li",[r("a",{attrs:{href:"#访问者模式"}},[t._v("访问者模式")])]),r("li",[r("a",{attrs:{href:"#解释器模式"}},[t._v("解释器模式")])]),r("li",[r("a",{attrs:{href:"#迭代器模式"}},[t._v("迭代器模式")])]),r("li",[r("a",{attrs:{href:"#备忘录模式"}},[t._v("备忘录模式")])])])]),r("p"),t._v(" "),r("h1",{attrs:{id:"行为型模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[t._v("#")]),t._v(" 行为型模式")]),t._v(" "),r("h2",{attrs:{id:"职责链模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#职责链模式"}},[t._v("#")]),t._v(" 职责链模式")]),t._v(" "),r("h3",{attrs:{id:"模式结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("img",{attrs:{src:s(718),alt:"image-20210927153531314"}})]),t._v(" "),r("h3",{attrs:{id:"优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("可以灵活控制请求处理的顺序和处理的对象；\n符合单一职责原则，使得客户端和处理者类解耦；\n符合开闭原则，可以方便地新增处理者；")]),t._v(" "),r("h3",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("部分请求可能无法被处理；\n增加了代码的复杂度，可能会出现很多处理者类；")]),t._v(" "),r("h3",{attrs:{id:"适用环境"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("有多个对象处理同一个请求，具体由谁来处理是在运行时决定，客户端只需发出请求到职责链上，而无需关心具体是谁来处理；\n可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变职责链中各个处理者之间的上下级关系")]),t._v(" "),r("h2",{attrs:{id:"策略模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[t._v("#")]),t._v(" 策略模式")]),t._v(" "),r("h3",{attrs:{id:"模式结构-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-2"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("img",{attrs:{src:s(719),alt:"image-20210928092351227"}})]),t._v(" "),r("h4",{attrs:{id:"策略模式与建造者模式的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#策略模式与建造者模式的区别"}},[t._v("#")]),t._v(" 策略模式与建造者模式的区别？")]),t._v(" "),r("h3",{attrs:{id:"优点-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("符合开闭原则，策略模式易于扩展，增加新的算法时只需继承抽象策略类，新设计实现一个具体策略类即可；\n客户端可以无差别地通过公共接口调用，利用里式替换原则，灵活使用不同的算法策略；\n提供了一个算法族管理机制和维护机制。")]),t._v(" "),r("h3",{attrs:{id:"缺点-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("客户端必须要知道所有的策略，以便在使用时按需实例化具体策略；\n系统会产生很多单独的类，增加系统中类的数量；\n客户端在同一时间只能使用一种策略。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-2"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("系统需要在一个算法族中动态选择一种算法，可以将这些算法封装到多个具体算法类中，这些算法类都有共同的基类，即可以通过一个统一的接口调用任意一个算法，客户端可以使用任意一个算法；\n不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装与算法相关的数据结构，可以提高算法的安全性。")]),t._v(" "),r("h2",{attrs:{id:"观察者模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[t._v("#")]),t._v(" 观察者模式")]),t._v(" "),r("p",[r("strong",[t._v("观察者模式(Observer Pattern)")]),t._v("：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-3"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("img",{attrs:{src:s(720),alt:"image-20210928094625604"}})]),t._v(" "),r("h3",{attrs:{id:"优点-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("观察者模式实现了"),r("strong",[t._v("稳定的消息更新和传递的机制")]),t._v("，通过引入抽象层可以扩展不同的具体观察者角色；\n支持广播通信，所有已注册的观察者（添加到目标列表中的对象）都会得到消息更新的通知，"),r("strong",[t._v("简化了一对多")]),t._v("设计的难度；\n"),r("strong",[t._v("符合开闭原则")]),t._v("，增加新的观察者无需修改已有代码，在具体观察者与观察目标之间不存在关联关系的情况下增加新的观察目标也很方便。")]),t._v(" "),r("h3",{attrs:{id:"缺点-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("代码中观察者和观察目标相互引用，"),r("strong",[t._v("存在循环依赖")]),t._v("，观察目标会触发二者循环调用，有引起系统崩溃的风险；\n如果一个观察目标对象有很多直接和简介观察者，将所有的观察者都通知到会耗费大量时间。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-3"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("一个对象的改变会引起其他对象的联动改变，但并不知道是哪些对象会产生改变以及产生什么样的改变；\n如果需要设计一个链式触发的系统，可是使用观察者模式；\n广播通信、消息更新通知等场景。")]),t._v(" "),r("h2",{attrs:{id:"模板方法模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式"}},[t._v("#")]),t._v(" 模板方法模式")]),t._v(" "),r("p",[t._v("基于"),r("strong",[t._v("类的继承的一种代码复用技术")]),t._v("，其结构只存在基类和派生类之间的继承关系。模板方法是一个具体的方法，给出了一个顶层逻辑流程框架。")]),t._v(" "),r("p",[t._v("模板模式有两大作用："),r("strong",[t._v("复用和扩展")]),t._v("。\n复用指的是，所有的子类可以复用父类中提供的模板方法的代码。\n扩展指的是，框架通过模板模式提供功能扩展点，也就是钩子hook()，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-4"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("img",{attrs:{src:s(721),alt:"image-20210928095720592"}})]),t._v(" "),r("h3",{attrs:{id:"优点-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-4"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("在基类中定义算法的框架，并声明一些流程方法，由具体派生类实现细节，派生类中的实现并不会影响基类定义的算法的框架流程；\n公共行为在基类中提供实现，有利于代码复用；\n派生类可以覆盖基类的方法，重新实现某些方法，具有灵活性；\n可以很方便的扩展和更换派生类而不影响基类和其他派生类，"),r("strong",[t._v("符合开闭原则和单一职责原则")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"缺点-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-4"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("模板方法模式要为每一个不同的基本方法提供一个派生类，如果基类中基本方法很多，那系统中会定义很多个派生类，导致类的个数很多，系统更加庞大。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-4"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("分割复杂算法，可以将算法的框架流程定义在基类中，设计为模板方法；而具体的细节由派生类设计实现；\n各个派生类的公共部分提取到基类中，以实现代码复用；\n派生类需要覆盖基类的某些方法。")]),t._v(" "),r("h2",{attrs:{id:"状态模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#状态模式"}},[t._v("#")]),t._v(" 状态模式")]),t._v(" "),r("p",[t._v("状态模式一般用来实现有限状态机。")]),t._v(" "),r("p",[t._v("有限状态机简称为状态机。状态机有 3 个组成部分："),r("strong",[t._v("状态（State）、事件（Event）、动作（Action）")]),t._v("。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。状态机的状态随着某种事件的发生而改变，事"),r("strong",[t._v("件就是状态转移的条件")]),t._v("，状态转移时可能会有相应的操作要同时进行。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-5"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("img",{attrs:{src:s(722),alt:"image-20210928105153620"}})]),t._v(" "),r("h3",{attrs:{id:"优点-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-5"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("状态模式封装了状态转换的规则，只给外界暴露了统一的接口，客户端可以无差别地调用该接口；\n把每个状态和动作提取出来，封装到一个类中，就把着眼点从执行状态提高到整个对象的状态，这将使代码更加结构化，整体意图更加清晰；\n以后对状态的修改之需要修改一个子类，新增一个新的状态，只需要新增一个状态类，对原有代码的修改少")]),t._v(" "),r("h3",{attrs:{id:"缺点-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-5"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("状态模式增加了系统中类的个数（不同的具体状态类）\n结构相对复杂（如前述实例的UML图），代码逻辑也较复杂\n一个State的子类至少拥有一个其他子类的信息，各个子类之间产生了依赖")]),t._v(" "),r("h3",{attrs:{id:"适用环境-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-5"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("对象的行为根据它的状态的改变而不同；\n代码中含有大量与对象状态有关的判断逻辑（if……else……或switch……case……）；")]),t._v(" "),r("h2",{attrs:{id:"命令模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#命令模式"}},[t._v("#")]),t._v(" 命令模式")]),t._v(" "),r("p",[t._v("命令模式是对操作的解耦，操作的发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道接收者是谁，以及接受者是如何完成请求的。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-6"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("img",{attrs:{src:s(723),alt:"image-20210928115729951"}})]),t._v(" "),r("h3",{attrs:{id:"命令模式与策略模式的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#命令模式与策略模式的区别"}},[t._v("#")]),t._v(" 命令模式与策略模式的区别？")]),t._v(" "),r("p",[t._v("在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，FightWithSword 、FightWithSpear 都是攻击方式，一个是用剑攻击，另一个是用长枪攻击，它们相当于不同的算法，是可以相互替换的。\n而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，它们之间可能千差万别，并且互相之间不可替换。")]),t._v(" "),r("h5",{attrs:{id:"二者的关注点不同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二者的关注点不同"}},[t._v("#")]),t._v(" "),r("strong",[t._v("二者的关注点不同")]),t._v("：")]),t._v(" "),r("p",[t._v("策略模式提供多种行为由调用者自己选用，算法的自由选用是其关注点。\n命令模式关注解耦，将请求的内容封装成命令由接受者执行。")]),t._v(" "),r("h5",{attrs:{id:"二者使用场景不同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二者使用场景不同"}},[t._v("#")]),t._v(" "),r("strong",[t._v("二者使用场景不同：")])]),t._v(" "),r("p",[t._v("策略模式适用于有多种行为可以相互替换的场景。\n命令模式适用于解耦两个紧耦合关系的对象或多命令对象撤销的场景。")]),t._v(" "),r("h3",{attrs:{id:"优点-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-6"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("降低系统耦合度，将命令的请求者与接收者分离解耦，请求者和发送者不存在直接关联，各自独立互不影响。\n便于扩展：新的命令很容易加入到系统中，且符合开闭原则。\n较容易实现命令队列或宏命令。\n为请求的撤销和回复操作提供了一种设计实现方案。")]),t._v(" "),r("h3",{attrs:{id:"缺点-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-6"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("命令模式可能导致系统中有过多的具体命令类，增加了系统中对象的数量。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-6"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("系统需要将请求发送者和接收者解耦，使得发送者和接收者互不影响。\n系统需要在不同时间指定请求、将请求排队和执行请求。\n系统需要支持命令的撤销和恢复操作。\n系统需要将一组操作组合在一起形成宏命令。")]),t._v(" "),r("h2",{attrs:{id:"中介者模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中介者模式"}},[t._v("#")]),t._v(" 中介者模式")]),t._v(" "),r("p",[r("strong",[t._v("中介者模式")]),t._v("是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-7"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("img",{attrs:{src:s(724),alt:"image-20210928141704234"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(725),alt:"image-20210930151035082"}})]),t._v(" "),r("h3",{attrs:{id:"中介者和观察者模式的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中介者和观察者模式的区别"}},[t._v("#")]),t._v(" 中介者和观察者模式的区别")]),t._v(" "),r("p",[t._v("中介者的主要目标是"),r("strong",[t._v("消除一系列对象之间的相互依赖")]),t._v("，这些对象将依赖于同一个中介者对象。")]),t._v(" "),r("p",[t._v("观察者的目标是在对象之间"),r("strong",[t._v("建立动态的单向连接")]),t._v("，它们之间的交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。")]),t._v(" "),r("p",[t._v("最重要的是它们的意图是不一样的，中介者主要是为了消除对象之间的依赖；而观察者模式是一种订阅机制，它主要是为了发通知给订阅对象。")]),t._v(" "),r("p",[t._v("我们要区分不同的设计模式，最好还是从他们的意图出发，不同的设计模式可能很相似，但是它们要解决的问题是不一样的。")]),t._v(" "),r("h3",{attrs:{id:"优点-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-7"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("简化了对象之间的交互，通过中介者，对象之间的多对多关系就简化了相对更简单的一对多关系；\n可将各个同事对象解耦，利于各个同事之间的松散耦合，可独立地改变和复用每一个同事对象，增加新的中介者和同事都比较方便，符合开闭原则；\n可减少子类生成，将原本分布于多个对象之间的行为封装在一起，只需生成新的具体中介者类就可以改变这些行为。")]),t._v(" "),r("h3",{attrs:{id:"缺点-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-7"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("具体中介者类中包含了大量与同事之间交互的细节和逻辑，可能使得中介者类很复杂以至于难以管理维护。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-7"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("系统中的对象之间存在复杂的交互关系，使得系统内逻辑错综复杂，难以管理；\n一个对象引用了其他很多对象，并直接和这些对象交互，导致该对象难以复用。")]),t._v(" "),r("h2",{attrs:{id:"访问者模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#访问者模式"}},[t._v("#")]),t._v(" 访问者模式")]),t._v(" "),r("p",[r("strong",[t._v("访问者模式")]),t._v("是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。")]),t._v(" "),r("p",[r("strong",[t._v("访问者模式：提供一个作用于某种对象结构中的各元素的操作，可以在不改变元素类的前提下，定义作用于元素的新操作。")])]),t._v(" "),r("p",[t._v("所谓单分派，指的是"),r("strong",[t._v("执行哪个对象的方法")]),t._v("，根据对象的"),r("strong",[t._v("运行时类型来决定")]),t._v("；"),r("strong",[t._v("执行对象的哪个方法")]),t._v("，根据方法参数的"),r("strong",[t._v("编译时类型来决定")]),t._v("。")]),t._v(" "),r("p",[t._v("所谓双分派，指的是"),r("strong",[t._v("执行哪个对象的方法")]),t._v("，根据对象的"),r("strong",[t._v("运行时类型来决定")]),t._v("；"),r("strong",[t._v("执行对象的哪个方法")]),t._v("，根据方法参数的"),r("strong",[t._v("运行时类型来决定")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-8"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("strong",[t._v("Visitor（抽象访问者）")]),t._v("：抽象类，声明了访问对象结构中不同具体元素的方法，由方法名称可知该方法将访问对象结构中的某个具体元素；\n"),r("strong",[t._v("ConcreteVisitor（具体访问者）")]),t._v("：访问某个具体元素的访问者，实现具体的访问方法；\n"),r("strong",[t._v("Element（抽象元素）")]),t._v("：抽象类，一般声明一个accept()的方法，用于接受访问者的访问，accept()方法常常以一个抽象访问者的指针作为参数；\n"),r("strong",[t._v("ConcreteElement（具体元素）")]),t._v("：针对具体被访问的元素，实现accept()方法；\n"),r("strong",[t._v("ObjectStructure（对象结构）")]),t._v("：元素的集合，提供了遍历对象结构中所有元素的方法。对象结构存储了不同类型的元素对象，以供不同的访问者访问；")]),t._v(" "),r("p",[r("img",{attrs:{src:s(726),alt:"img"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(727),alt:"image-20210930151955188"}})]),t._v(" "),r("h3",{attrs:{id:"优点-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-8"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("增加新的访问者很方便，即增加一个新的具体访问者类，定义新的访问方式，无需修改原有代码，符合开闭原则；\n被访问元素集中在一个对象结构中，类的职责更清晰，利于对象结构中元素对象的复用；")]),t._v(" "),r("h3",{attrs:{id:"缺点-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-8"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("增加新的元素类很困难，增加新的元素时，在抽象访问者类中需要增加一个对新增的元素方法的声明，即要修改抽象访问者代码；此外还要增加新的具体访问者以实现对新增元素的访问，不符合开闭原则；\n破坏了对象的封装性，访问者模式要求访问者对象访问并调用每一个元素对象的操作，那么元素对象必须暴露自己的内部操作和状态，否则访问者无法访问。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-8"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("访问者模式的结构相对较复杂，在实际应用中使用频率较低。如果系统中存在一个复杂的对象结构，且不同的访问者对其具有不同的操作，那么可以考虑使用访问者模式。")]),t._v(" "),r("h2",{attrs:{id:"解释器模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解释器模式"}},[t._v("#")]),t._v(" 解释器模式")]),t._v(" "),r("p",[t._v("**解释器模式：**为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。我们可以自己定义一些符号，然后我们给这些符号设定规则，解释权在我们自己手里。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-9"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("strong",[t._v("AbstractExpression（抽象表达式）")]),t._v("：声明了抽象的解释操作interpret()，是所有终结符表达式和非终结符表达式的基类；\n"),r("strong",[t._v("TerminalExpression（终结符表达式）")]),t._v("：终结符是文法规则的组成元素中最基本的语言单位，不能再分解。终结符表达式实现了与文法规则中终结符相关的解释操作，句子中的每一个终结符都是该类的一个实例。就是对应“a”，“b”，“c”。\n"),r("strong",[t._v("NonterminalExpression（非终结符表达式）")]),t._v("：实现了文法规则中非终结符的解释操作，因为非终结符表达式同样可以包含终结符表达式，所以终结符表达式可以是非终结符表达式的成员。就是对应“+”，“-”符号。\n"),r("strong",[t._v("Context（环境类）")]),t._v("：即上下文类，用于存储解释器之外的一些全局信息，通常临时存储需要解释的语句。")]),t._v(" "),r("p",[r("img",{attrs:{src:s(728),alt:"image-20210928154657103"}})]),t._v(" "),r("h3",{attrs:{id:"优点-9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-9"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("易于改变和扩展文法，在解释器中使用类表示语言的文法规则，可以通过继承等机制类改变或扩展文法；\n每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言；\n如果要增加新的解释表达式，只需增加一个新的终结符表达式或非终结符表达式类，无需修改原有代码，符合开闭原则。")]),t._v(" "),r("h3",{attrs:{id:"缺点-9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-9"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("对于复杂文法难以维护。在解释器模式中每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会大量增加，导致系统难以管理和维护；\n执行效率低，因为解释器模式中有大量循环和递归调用。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-9"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("一些重复出现的问题可以用一种简单的语言进行表达；\n一个语言的文法较为简单；\n不考虑执行效率的问题时可以使用解释器模式")]),t._v(" "),r("h2",{attrs:{id:"迭代器模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式"}},[t._v("#")]),t._v(" 迭代器模式")]),t._v(" "),r("p",[t._v("迭代器模式（Iterator Design Pattern）：提供一种方法顺序访问一个集合对象中的各个元素，而又不需暴露该对象的内部表示。")]),t._v(" "),r("p",[t._v("通过引入迭代器，可以将数据的遍历功能从聚合对象中分离出来，这样一来，聚合对象只需负责存储数据，而迭代器对象负责遍历数据，使得聚合对象的职责更加单一，符合单一职责原则。")]),t._v(" "),r("p",[t._v("注意：迭代器类和聚合类存在相互包含相互引用的关系，因此代码里需要前向声明某个类。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-10"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[t._v("迭代器模式常常和工厂方法模式结合。")]),t._v(" "),r("p",[r("strong",[t._v("Iterator（抽象迭代器）")]),t._v("：声明了访问和遍历聚合对象元素的接口，如first()方法用于访问聚合对象中第一个元素，next()方法用于访问下一个元素，hasNext()判断是否还有下一个元素，currentItem()方法用于获取当前元素。\n"),r("strong",[t._v("ConcreteIterator（具体迭代器）")]),t._v("：实现抽象迭代器声明的方法，通常具体迭代器中会专门用一个变量（称为游标）来记录迭代器在聚合对象中所处的位置。\n"),r("strong",[t._v("Aggregate（抽象聚合类）")]),t._v("：用于存储和管理元素对象，声明一个创建迭代器的接口，其实是一个抽象迭代器工厂的角色。\n"),r("strong",[t._v("ConcreteAggregate（具体聚合类）")]),t._v("：实现了方法createIterator()，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator的实例。")]),t._v(" "),r("p",[r("img",{attrs:{src:s(729),alt:"image-20210928160130671"}})]),t._v(" "),r("h3",{attrs:{id:"优点-10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-10"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多个遍历方式。\n简化了聚合类，使得聚合类的职责更加单一；\n迭代器模式中引入抽象层，易于增加新的迭代器类，便于扩展，符合开闭原则。")]),t._v(" "),r("h3",{attrs:{id:"缺点-10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-10"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("将聚合类中存储对象和管理对象的职责分离，增加新的聚合类时同样需要考虑增加对应的新的迭代器类，类的个数成对增加，不利于系统管理和维护；\n设计难度较大，需要充分考虑将来系统的扩展。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-10"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("以下场景可以考虑使用迭代器模式：\n访问一个聚合对象而无需暴露它的内部结构；\n需要为一个聚合对象提供多种遍历方法。")]),t._v(" "),r("h2",{attrs:{id:"备忘录模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#备忘录模式"}},[t._v("#")]),t._v(" 备忘录模式")]),t._v(" "),r("p",[t._v("备忘录模式：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。")]),t._v(" "),r("h3",{attrs:{id:"模式结构-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式结构-11"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),r("p",[r("img",{attrs:{src:s(730),alt:"image-20210928162005183"}})]),t._v(" "),r("h3",{attrs:{id:"优点-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-11"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("p",[t._v("实现状态恢复、撤销操作的功能，用户可以恢复到指定的历史状态，让软件系统更加人性化；\n备忘录封装了信息，除了原生器以外，其他对象访问不了备忘录的代码；")]),t._v(" "),r("h3",{attrs:{id:"缺点-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-11"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[t._v("资源消耗大。如果需要保存原生器对象的多个历史状态，那么将创建多个备忘录对象；\n或者如果原生器对象的很多状态都需要保存，也将消耗大量存储资源。")]),t._v(" "),r("h3",{attrs:{id:"适用环境-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用环境-11"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),r("p",[t._v("保存一个对象的历史状态，系统需要设计回退或者撤销功能；\n备忘录类可以封装一个对象的历史状态，避免对象的历史状态被外界修改；")])])}),[],!1,null,null,null);a.default=v.exports}}]);