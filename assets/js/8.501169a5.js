(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{679:function(v,_,a){v.exports=a.p+"assets/img/image-20211011101419583.4b0493bb.png"},680:function(v,_,a){v.exports=a.p+"assets/img/image-20211011101506862.d9c51583.png"},681:function(v,_,a){v.exports=a.p+"assets/img/image-20211011101622099.2feb0c7d.png"},682:function(v,_,a){v.exports=a.p+"assets/img/image-20211011101617509.1585b0b0.png"},683:function(v,_,a){v.exports=a.p+"assets/img/image-20211012145700951.0d95f73a.png"},684:function(v,_,a){v.exports=a.p+"assets/img/image-20211011101559871.73c7646a.png"},685:function(v,_,a){v.exports=a.p+"assets/img/image-20211012151039918.ebbeeaa7.png"},686:function(v,_,a){v.exports=a.p+"assets/img/image-20211011101525312.95199c02.png"},687:function(v,_,a){v.exports=a.p+"assets/img/image-20211011101545079.cc754588.png"},688:function(v,_,a){v.exports=a.p+"assets/img/image-20211012151744316.15d8b3ba.png"},689:function(v,_,a){v.exports=a.p+"assets/img/image-20211012152146908.c1ea5914.png"},690:function(v,_,a){v.exports=a.p+"assets/img/image-20211012152258939.e79a47aa.png"},691:function(v,_,a){v.exports=a.p+"assets/img/image-20211012152443659.081c3eb6.png"},692:function(v,_,a){v.exports=a.p+"assets/img/image-20211012154619219.e68534ce.png"},693:function(v,_,a){v.exports=a.p+"assets/img/image-20211012101929067.e61bb145.png"},694:function(v,_,a){v.exports=a.p+"assets/img/image-20211012154847134.8c6d214a.png"},695:function(v,_,a){v.exports=a.p+"assets/img/image-20211012155454613.6628156a.png"},848:function(v,_,a){"use strict";a.r(_);var t=a(12),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"程序设计语言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序设计语言"}},[v._v("#")]),v._v(" 程序设计语言")]),v._v(" "),t("h2",{attrs:{id:"程序设计语言概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序设计语言概述"}},[v._v("#")]),v._v(" 程序设计语言概述")]),v._v(" "),t("h3",{attrs:{id:"特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("低级语言")]),v._v(" "),t("ul",[t("li",[v._v("机器语言，识别0和1，如汇编语言")])])]),v._v(" "),t("li",[t("p",[v._v("高级语言")]),v._v(" "),t("ul",[t("li",[v._v("抽象级别更高")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("函数式程序设计语言")]),v._v("，的控制结构取决于函数，以及函数的定义和调用。函数式语言主要用于符号数据处理，如微分和积分演算、数理逻辑、游戏推演及人工智能等其他领域；")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("逻辑式程序设计语言")]),v._v("，编写程序不需要描述具体的解题过程，只需要给出一些必要的事实和规则。这些规则是解决问题的方法的规范说明，根据这些事实和规则，计算机利用谓词逻辑，通过演绎得到求解问题的执行序列。这种语言主要用在人工智能领域，也应用在自然语言处理、数据库查询、算法描述等方面，尤其适合于作为专家系统的开发工具。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("过程式语言")]),v._v("，也叫做命令式语言或强制式语言，是通过指明一列可执行的运算及运算的次序来描述计算过程的语言。例如：FORTRAN,ALGOL 60,COBOL,PASCAL,C等都是过程式语言。")])])]),v._v(" "),t("h3",{attrs:{id:"解释和编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释和编译"}},[v._v("#")]),v._v(" 解释和编译")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("将高级语言翻译成机器语言")])]),v._v(" "),t("li",[t("p",[v._v("编译")]),v._v(" "),t("ul",[t("li",[v._v("生成独立可执行文件，直接运行，效率高")])])]),v._v(" "),t("li",[t("p",[v._v("解释")]),v._v(" "),t("ul",[t("li",[v._v("不生产可执行文件，逐条解释执行，用于调试模式，执行速度慢")])])])]),v._v(" "),t("h3",{attrs:{id:"组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组成"}},[v._v("#")]),v._v(" 组成")]),v._v(" "),t("ul",[t("li",[v._v("语法（一组规则）、语义（语法成分含义）、语用（构成语言的各个记号和使用者关系）")]),v._v(" "),t("li",[t("strong",[v._v("语句")]),v._v("用于描述程序中的运算步骤、控制结构及数据传输。")]),v._v(" "),t("li",[t("strong",[v._v("语法")]),v._v("是语言的外观，给出语言的语法意味着给出语句、声明和其他语言结构的书写规则。")]),v._v(" "),t("li",[t("strong",[v._v("语义")]),v._v("则表示不同的语法结构的含义。")]),v._v(" "),t("li",[t("strong",[v._v("语用")]),v._v("是关于程序与使用者之间的关系。")]),v._v(" "),t("li",[t("strong",[v._v("语境")]),v._v("是理解和实现程序设计语言的环境，包括编译环境和运行环境。")])]),v._v(" "),t("h2",{attrs:{id:"程序设计语言基本成分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序设计语言基本成分"}},[v._v("#")]),v._v(" 程序设计语言基本成分")]),v._v(" "),t("h3",{attrs:{id:"数据成分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据成分"}},[v._v("#")]),v._v(" 数据成分")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("分类")]),v._v(" "),t("ul",[t("li",[v._v("常量、变量、全局量、局部量")])])]),v._v(" "),t("li",[t("p",[v._v("数据类型")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("整型、字符型、双精度、单精度浮点型、布尔型等")])]),v._v(" "),t("li",[t("p",[v._v("数据必须具有类型")]),v._v(" "),t("ul",[t("li",[v._v("有利于在翻译程序的过程中为数据合理分配存储单元")]),v._v(" "),t("li",[v._v("有利于对参与表达式计算的数据对象进行检查")]),v._v(" "),t("li",[v._v("有利于规定数据对象的取值范围及能够进行的运算")])])])])])]),v._v(" "),t("h3",{attrs:{id:"运算成分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运算成分"}},[v._v("#")]),v._v(" 运算成分")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("允许使用的运算符即运算规则")]),v._v(" "),t("ul",[t("li",[v._v("算数、逻辑、关系、位运算等")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("逆波兰式")])]),v._v(" "),t("ul",[t("li",[v._v("也叫后缀表达式，即将运算符写在操作数之后的表达式，它不需使用括号，在将算术表达式转换为逆波兰式表示时，需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈）")]),v._v(" "),t("li",[v._v("逆波兰式ab-cd+"),t("em",[v._v("转换为中缀表达式的过程为：ab-cd+")]),v._v(" = （ab-）*（cd+） = （a-b）\n"),t("em",[v._v("（cd+） = （a-b）")]),v._v("（c+d）")])])]),v._v(" "),t("li",[t("p",[v._v("表达式")]),v._v(" "),t("ul",[t("li",[v._v("前缀表达式对应于二叉树的前序遍历")]),v._v(" "),t("li",[v._v("中缀表达式对应于二叉树的中序遍历")]),v._v(" "),t("li",[v._v("后缀表达式对应于二叉树的后序遍历")])])])]),v._v(" "),t("h3",{attrs:{id:"控制成分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制成分"}},[v._v("#")]),v._v(" 控制成分")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("结构")]),v._v(" "),t("ul",[t("li",[v._v("顺序结构")]),v._v(" "),t("li",[v._v("选择结构")]),v._v(" "),t("li",[v._v("循环结构\n"),t("ul",[t("li",[v._v("while先判断再执行，所以循环体的执行次数要比判断次数少1；")]),v._v(" "),t("li",[v._v("do-while先执行再判断，进行判断的次数和执行循环体的次数刚好相等；")])])])])]),v._v(" "),t("li",[t("p",[v._v("语句")]),v._v(" "),t("ul",[t("li",[v._v("复合语句")]),v._v(" "),t("li",[v._v("if和switch语句")]),v._v(" "),t("li",[v._v("循环语句")])])])]),v._v(" "),t("h3",{attrs:{id:"传输成分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传输成分"}},[v._v("#")]),v._v(" 传输成分")]),v._v(" "),t("ul",[t("li",[v._v("指明语言允许的数据传输方式。如：赋值处理、数据的输入输出等")])]),v._v(" "),t("h3",{attrs:{id:"函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[v._v("#")]),v._v(" 函数")]),v._v(" "),t("ul",[t("li",[v._v("函数使用涉及三个概念：函数定义、函数声明（先声明后使用）、函数调用")])]),v._v(" "),t("h3",{attrs:{id:"调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调用"}},[v._v("#")]),v._v(" 调用")]),v._v(" "),t("ul",[t("li",[v._v("传值调用：将实参的值传递给形参，形参的改变不会导致调用点所传的实参的值改变。实参可是是合法的变量、常量、表达式")]),v._v(" "),t("li",[v._v("传址调用：即引用调用，将实参的地址传值给形参，即相当于实参存储单元的地址引用，因此其值改变的同时就改变了实参的值，实参不能为常-量，只能是合法的变量和表达式")])]),v._v(" "),t("h2",{attrs:{id:"汇编"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#汇编"}},[v._v("#")]),v._v(" 汇编")]),v._v(" "),t("h3",{attrs:{id:"三类语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三类语句"}},[v._v("#")]),v._v(" 三类语句")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("指令语句")]),v._v(" "),t("ul",[t("li",[v._v("将其汇编后能产生相应机器代码。这些代码能被CPU识别并执行相应操作")]),v._v(" "),t("li",[v._v("产生机器代码，操作必须在程序运行时完成")]),v._v(" "),t("li",[v._v("必须具有操作码字段，可以没有操作数字段")])])]),v._v(" "),t("li",[t("p",[v._v("伪指令语句")]),v._v(" "),t("ul",[t("li",[v._v("指示汇编程序在汇编源程序时完成某些工作，如变量分配存储单元地址，给某符号赋值")]),v._v(" "),t("li",[v._v("不产生机器代码，在源程序汇编时完成")])])]),v._v(" "),t("li",[t("p",[v._v("宏指令语句")]),v._v(" "),t("ul",[t("li",[v._v("允许用户将多次重复使用的程序段定义为宏，宏的引用")])])])]),v._v(" "),t("h3",{attrs:{id:"汇编程序需要两次扫描源程序才能完成翻译过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#汇编程序需要两次扫描源程序才能完成翻译过程"}},[v._v("#")]),v._v(" 汇编程序需要两次扫描源程序才能完成翻译过程")]),v._v(" "),t("h2",{attrs:{id:"解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释"}},[v._v("#")]),v._v(" 解释")]),v._v(" "),t("h3",{attrs:{id:"示意图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示意图"}},[v._v("#")]),v._v(" 示意图")]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:a(679),alt:"image-20211011101419583"}})])]),v._v(" "),t("h2",{attrs:{id:"编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译"}},[v._v("#")]),v._v(" 编译")]),v._v(" "),t("h3",{attrs:{id:"工作过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工作过程"}},[v._v("#")]),v._v(" 工作过程")]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:a(680),alt:"image-20211011101506862"}})])]),v._v(" "),t("h3",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("词法分析")]),v._v(" "),t("ul",[t("li",[v._v("对源程序字符进行扫描根据构词规则识别单词（也称单词符号或符号）")])])]),v._v(" "),t("li",[t("p",[v._v("语法分析")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("逻辑阶段，根据识别的单词组合成各类语法短语，如：程序，语句，表达式等，分析判断源程序在结构是否正确")])]),v._v(" "),t("li",[t("p",[v._v("分析方法")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("自上而下分析")]),v._v(" "),t("ul",[t("li",[v._v("最左推导，从左到右")])])]),v._v(" "),t("li",[t("p",[v._v("递归下降思想")]),v._v(" "),t("ul",[t("li",[v._v("是一种自上而下的方法")])])]),v._v(" "),t("li",[t("p",[v._v("自下而上分析")]),v._v(" "),t("ul",[t("li",[v._v("最右推导，从右至左")])])]),v._v(" "),t("li",[t("p",[v._v("移到-规约思想")]),v._v(" "),t("ul",[t("li",[v._v("自下而上的方法")])])])])])])]),v._v(" "),t("li",[t("p",[v._v("语义分析")]),v._v(" "),t("ul",[t("li",[v._v("逻辑阶段，对结构上正确的源程序进行上下文有关性质的审查。如：类型匹配、除法除数不为0等。分为静态语义错误（编译阶段能够发现）、动态语义错误（运行时能发现）")])])]),v._v(" "),t("li",[t("p",[v._v("中间代码和目标代码")]),v._v(" "),t("ul",[t("li",[v._v("中间代码是语义分析产生的需要经过优化链接，最终生成可执行的目标代码。")]),v._v(" "),t("li",[v._v("引入中间代码的目的是进行与机器无关的代码优化处理。")]),v._v(" "),t("li",[v._v("常用的中间代码有"),t("strong",[v._v("后缀式（逆波兰式）、三元式（三地址码）、四元式和树等形式")])])])]),v._v(" "),t("li",[t("p",[v._v("中间代码优化和目标代码生成")]),v._v(" "),t("ul",[t("li",[v._v("代码生成需考虑的问题\n"),t("ul",[t("li",[v._v("中间代码形式、目标代码形式、寄存器分配、计算次序选择")])])])])]),v._v(" "),t("li",[t("p",[v._v("源程序中可能出现的错误两类："),t("strong",[v._v("语法错误和语义错误")]),v._v("。")]),v._v(" "),t("ul",[t("li",[v._v("词法错误如非法字符或拼写错关键字、标识符等；\n语法错误是指语法结构出错，如少分号、begin/end不配对等；")]),v._v(" "),t("li",[v._v("静态语义错误：如类型不一致、参数不匹配等；\n动态语义错误（逻辑错误）：如无穷递归、变量为零时作除数等 ；")])])])]),v._v(" "),t("h3",{attrs:{id:"语言及文法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语言及文法"}},[v._v("#")]),v._v(" 语言及文法")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("语言")]),v._v(" "),t("ul",[t("li",[v._v("语言是按照一定规则排列的符号和集合。要形式化地描述一个语言，就需要借助文法的概念。")])])]),v._v(" "),t("li",[t("p",[v._v("文法")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("文法就是用来描述语言的语法结构的形式规则")])]),v._v(" "),t("li",[t("p",[v._v("四元组")]),v._v(" "),t("ul",[t("li",[v._v("G=（V,T,S,P）\nV: 不是语言组成部分，可理解为占位符；非终结符：能够推导出其他元素\nT: 终结符，语言组成部分，是最终结果；不能推导出其他元素\nS: 七十符，文法开始符号\nP：产生式，用终结符替代非终结符的规则；即非终结符推导出终结符的公式")])])]),v._v(" "),t("li",[t("p",[v._v("闭包")]),v._v(" "),t("ul",[t("li",[v._v("一般考察闭包可以为0个的代入运算")]),v._v(" "),t("li",[t("img",{attrs:{src:a(681),alt:"image-20211011101622099"}})])])]),v._v(" "),t("li",[t("p",[v._v("类型")]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:a(682),alt:"image-20211011101617509"}})]),v._v(" "),t("li",[v._v("程序设计语言中的大部分都是上下文无关文法，当然语义是相关的")])])])])]),v._v(" "),t("li",[t("p",[v._v("文法和语言的形式描述")]),v._v(" "),t("ul",[t("li",[v._v("字母表、字符串、字符串集合及运算\n"),t("ul",[t("li",[t("img",{attrs:{src:a(683),alt:"image-20211012145700951"}})])])])])])]),v._v(" "),t("h3",{attrs:{id:"词法分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#词法分析"}},[v._v("#")]),v._v(" 词法分析")]),v._v(" "),t("h4",{attrs:{id:"正规式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正规式"}},[v._v("#")]),v._v(" 正规式")]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:a(684),alt:"image-20211011101559871"}})]),v._v(" "),t("li",[t("em",[t("em",[v._v("（R1|R2）")]),v._v(" = （R1*R2*）")]),v._v("**  ，"),t("strong",[v._v("b(ab)*=(ba)*b")])]),v._v(" "),t("li",[t("img",{attrs:{src:a(685),alt:"image-20211012151039918"}})])]),v._v(" "),t("h4",{attrs:{id:"有限自动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有限自动机"}},[v._v("#")]),v._v(" 有限自动机")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("词法分析工具")])]),v._v(" "),t("li",[t("p",[v._v("定义")]),v._v(" "),t("ul",[t("li",[t("p",[t("img",{attrs:{src:a(686),alt:"image-20211011101525312"}})]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:a(687),alt:"image-20211011101545079"}})]),v._v(" "),t("li",[v._v("S输入1，得到A输入0，得到F\nS输入1，得到A输入1，得到C输入0、1，得到F\nS输入0，得到B输入0，得到F\nS输入0，得到B输入1，得到C输入0、1，得到F\n每一条线路都是唯一的，得出此图为确定有限自动机")])])])])]),v._v(" "),t("li",[t("p",[v._v("分类")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("确定有限自动机"),t("code",[v._v("DFA")])])]),v._v(" "),t("ul",[t("li",[v._v("输入同一个值，得出的后继是唯一的")]),v._v(" "),t("li",[t("img",{attrs:{src:a(688),alt:"image-20211012151744316"}})]),v._v(" "),t("li",[t("img",{attrs:{src:a(689),alt:"image-20211012152146908"}})]),v._v(" "),t("li",[t("img",{attrs:{src:a(690),alt:"image-20211012152258939"}})])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("不确定的有限自动机"),t("code",[v._v("NFA")])])]),v._v(" "),t("ul",[t("li",[v._v("输入同一个值，得出多个后继,下面例子是不确定的")]),v._v(" "),t("li",[t("img",{attrs:{src:a(691),alt:"image-20211012152443659"}})])])])])]),v._v(" "),t("li",[t("h2",{attrs:{id:"nfa到dfa的转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nfa到dfa的转换"}},[v._v("#")]),v._v(" "),t("code",[v._v("NFA")]),v._v("到"),t("code",[v._v("DFA")]),v._v("的转换")])]),v._v(" "),t("li",[t("p",[v._v("总结")]),v._v(" "),t("ul",[t("li",[v._v("用正规式来定义一些简单的语言，但是很多复杂一些的语言不能用正规式表达。例如，正规式不能用于描述配对或嵌套的结构，具体的例子有：由配对括号构成的串的集合不能用正规式描述，语句的嵌套结构也不能用正规式描述。还有，重复串也不能用正规式表示，例如，集合{wcw|w是a和b的串}不能用正规式描述。")]),v._v(" "),t("li",[v._v("正规式只能表示给定结构的固定次数的重复或者没有指定次数的重复。")]),v._v(" "),t("li",[v._v("有限状态自动机识别的语言是正规语言。对于每个非确定的有限自动机，都有一个与其等价的正规式。")]),v._v(" "),t("li",[v._v("上下文无关文法的描述功能比正规式更强，正规式可以描述的每种结构都可以用上下语言无关文法来描述，但反之不然。上下文无关文法能表示次数不固定的重复。")])])])]),v._v(" "),t("h4",{attrs:{id:"正规式和有限自动机之间的转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正规式和有限自动机之间的转换"}},[v._v("#")]),v._v(" 正规式和有限自动机之间的转换")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("有限自动机转为正规式")])]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:a(692),alt:"image-20211012154619219"}})]),v._v(" "),t("li",[t("img",{attrs:{src:a(693),alt:"image-20211012101929067"}})])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("正规式转为有限自动机")])]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:a(694),alt:"image-20211012154847134"}})])])])]),v._v(" "),t("h4",{attrs:{id:"词法分析构造"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#词法分析构造"}},[v._v("#")]),v._v(" 词法分析构造")]),v._v(" "),t("p",[t("img",{attrs:{src:a(695),alt:"image-20211012155454613"}})]),v._v(" "),t("h3",{attrs:{id:"语法分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法分析"}},[v._v("#")]),v._v(" 语法分析")]),v._v(" "),t("h4",{attrs:{id:"上下文无关文法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上下文无关文法"}},[v._v("#")]),v._v(" 上下文无关文法")]),v._v(" "),t("p",[v._v("程序设计语言规则绝大多数采用上下文无关文法进行描述。根据产生语法树方向，分为自底向上，自顶向下。")])])}),[],!1,null,null,null);_.default=i.exports}}]);