(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{852:function(t,v,_){"use strict";_.r(v);var a=_(12),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"软件设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#软件设计模式"}},[t._v("#")]),t._v(" 软件设计模式")]),t._v(" "),_("h2",{attrs:{id:"一些问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一些问题"}},[t._v("#")]),t._v(" 一些问题")]),t._v(" "),_("h3",{attrs:{id:"观察者模式类关系和优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式类关系和优点"}},[t._v("#")]),t._v(" 观察者模式类关系和优点？")]),t._v(" "),_("h3",{attrs:{id:"代理模式类关系和优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代理模式类关系和优点"}},[t._v("#")]),t._v(" 代理模式类关系和优点？")]),t._v(" "),_("h2",{attrs:{id:"需要重点清楚的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#需要重点清楚的"}},[t._v("#")]),t._v(" 需要重点清楚的")]),t._v(" "),_("ul",[_("li",[t._v("它由哪些类组成？")]),t._v(" "),_("li",[t._v("这些类扮演了哪些角色？")]),t._v(" "),_("li",[t._v("模式中的各个元素会以何种方式相互关联？")]),t._v(" "),_("li",[t._v("设计模式解决的问题？")])]),t._v(" "),_("h2",{attrs:{id:"设计模式分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式分类"}},[t._v("#")]),t._v(" 设计模式分类?")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("创建型模式")]),t._v("，简单工厂、工厂方法、抽象工厂、建造者、单例、原型；")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("结构型模式")]),t._v("，适配器、桥接、组合、装饰、外观、享元、代理；")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("行为型模式")]),t._v("，观察者、模板方法、命令、状态、职责链、解释器、访问者、策略、备忘录、迭代器；")])])]),t._v(" "),_("h2",{attrs:{id:"设计模式六大原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式六大原则"}},[t._v("#")]),t._v(" 设计模式六大原则？")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("① "),_("strong",[t._v("单一职责原则")]),t._v("，就一个类而言，应该仅有一个引起它变化的原因；")])]),t._v(" "),_("li",[_("p",[t._v("② "),_("strong",[t._v("里式替换原则")]),t._v("，派生类一定适用于基类。即在软件中，基类替换成派生类，程序的行为没有变化；")])]),t._v(" "),_("li",[_("p",[t._v("③ "),_("strong",[t._v("依赖倒转原则")]),t._v("，要依赖抽象，不要依赖具体类；")])]),t._v(" "),_("li",[_("p",[t._v("④ "),_("strong",[t._v("接口隔离原则")]),t._v("，每个接口中不存在派生类用不到却必须实现的方法，如果不然，应将接口拆分，使用多个隔离的接口。")])]),t._v(" "),_("li",[_("p",[t._v("⑤ "),_("strong",[t._v("开闭原则")]),t._v("，对修改关闭，对扩展开放；")])]),t._v(" "),_("li",[_("p",[t._v("⑥ "),_("strong",[t._v("迪米特原则")]),t._v("，如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);