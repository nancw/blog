(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{567:function(a,t,_){a.exports=_.p+"assets/img/image-20211026171343796.2d0107c7.png"},568:function(a,t,_){a.exports=_.p+"assets/img/image-20211026171412327.3efae9e0.png"},569:function(a,t,_){a.exports=_.p+"assets/img/image-20211026171508785.ba94a928.png"},570:function(a,t,_){a.exports=_.p+"assets/img/image-20211026155622683.330b010b.png"},839:function(a,t,_){"use strict";_.r(t);var v=_(12),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"算法设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法设计"}},[a._v("#")]),a._v(" 算法设计")]),a._v(" "),v("h2",{attrs:{id:"_5个重要特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5个重要特性"}},[a._v("#")]),a._v(" 5个重要特性")]),a._v(" "),v("ul",[v("li",[a._v("有穷性、确定性、可行性、输入、输出")])]),a._v(" "),v("h2",{attrs:{id:"排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[a._v("#")]),a._v(" 排序")]),a._v(" "),v("ul",[v("li",[a._v("来自："),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"}},[a._v("wikipedia . 排序算法"),v("OutboundLink")],1)])]),a._v(" "),v("p",[v("img",{attrs:{src:_(567),alt:"image-20211026171343796"}})]),a._v(" "),v("h2",{attrs:{id:"查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#查找"}},[a._v("#")]),a._v(" 查找")]),a._v(" "),v("p",[v("img",{attrs:{src:_(568),alt:"image-20211026171412327"}})]),a._v(" "),v("h2",{attrs:{id:"算法设计-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法设计-2"}},[a._v("#")]),a._v(" 算法设计")]),a._v(" "),v("h3",{attrs:{id:"主要选择标准"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要选择标准"}},[a._v("#")]),a._v(" 主要选择标准")]),a._v(" "),v("ul",[v("li",[a._v("算法的正确性、可靠性、简单性、易理解性、所需的存储空间、执行速度")])]),a._v(" "),v("h3",{attrs:{id:"算法设计技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法设计技术"}},[a._v("#")]),a._v(" 算法设计技术")]),a._v(" "),v("h3",{attrs:{id:"主要方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要方法"}},[a._v("#")]),a._v(" 主要方法")]),a._v(" "),v("ul",[v("li",[a._v("迭代法、穷举搜索法、递推法、贪心法、回溯法、分治法、动态规划法")]),a._v(" "),v("li",[v("img",{attrs:{src:_(569),alt:"image-20211026171508785"}})])]),a._v(" "),v("h4",{attrs:{id:"分治法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分治法"}},[a._v("#")]),a._v(" 分治法")]),a._v(" "),v("ul",[v("li",[a._v("设计思想\n"),v("ul",[v("li",[a._v("将难以解决的大问题分解成规模较小的相同问题，各个击破，分而治之；")])])]),a._v(" "),v("li",[a._v("步骤\n"),v("ul",[v("li",[a._v("分解、求解、合并")])])]),a._v(" "),v("li",[a._v("典型应用\n"),v("ul",[v("li",[a._v("Hanoi塔问题")])])])]),a._v(" "),v("h4",{attrs:{id:"动态规划法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态规划法"}},[a._v("#")]),a._v(" 动态规划法")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("设计思想")]),a._v(" "),v("ul",[v("li",[a._v("与分治法相同，但区别是分解得到的子问题往往不是独立的")]),a._v(" "),v("li",[a._v("求解某种具有最优性质的问题")])])]),a._v(" "),v("li",[v("p",[a._v("步骤")]),a._v(" "),v("ul",[v("li",[a._v("找出最优解的性质，并刻画其结构特征。")]),a._v(" "),v("li",[a._v("递归地定义最优解的值。")]),a._v(" "),v("li",[a._v("以自底向上的方式计算出最优值。")]),a._v(" "),v("li",[a._v("根据计算最优值时得到的信息，构造一个最优解。")])])]),a._v(" "),v("li",[v("p",[a._v("求解问题具有两个重要性质")]),a._v(" "),v("ul",[v("li",[a._v("最优子结构")]),a._v(" "),v("li",[a._v("重叠子问题")])])])]),a._v(" "),v("h4",{attrs:{id:"贪心法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#贪心法"}},[a._v("#")]),a._v(" 贪心法")]),a._v(" "),v("ul",[v("li",[a._v("设计思想\n"),v("ul",[v("li",[a._v("和动态规划一样，用于解决最优化问题，但解决的是局部最优，不从整体最优考虑")])])]),a._v(" "),v("li",[a._v("求解问题具有两个重要性质\n"),v("ul",[v("li",[a._v("最优子结构")]),a._v(" "),v("li",[a._v("贪心选择性质")])])]),a._v(" "),v("li",[a._v("典型应用\n"),v("ul",[v("li",[a._v("装箱问题")])])])]),a._v(" "),v("h4",{attrs:{id:"回溯法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回溯法"}},[a._v("#")]),a._v(" 回溯法")]),a._v(" "),v("ul",[v("li",[a._v("设计思想\n"),v("ul",[v("li",[a._v("暂时放弃关于问题规模大小的限制，并将问题的候选解按某种顺序逐一枚举和检验。当发现当前候选解不可能是解时，就选择下一个候选解。")]),a._v(" "),v("li",[a._v("倘若当前候选解除了不满足问题规模要求外，满足所有其他要求时，继续扩大当前候选解的规模，并继续试探。如果当前候选解满足包括问题规模在内的所有要求时，该候选解就是问题的一个解。")]),a._v(" "),v("li",[a._v("在回溯法中，放弃当前候选解、寻找下一个候选解的过程称为回溯;扩大当前候选解的规模并继续试探的过程称为向前试探。")]),a._v(" "),v("li",[a._v("深度优先方式搜索；")])])]),a._v(" "),v("li",[a._v("典型应用\n"),v("ul",[v("li",[a._v("n后问题")])])])]),a._v(" "),v("h2",{attrs:{id:"算法分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法分析"}},[a._v("#")]),a._v(" 算法分析")]),a._v(" "),v("p",[a._v("对算法所需资源的估算，如，通信带宽、计算机硬件、时间。资源越多，复杂度越高。")]),a._v(" "),v("h3",{attrs:{id:"复杂性分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复杂性分析"}},[a._v("#")]),a._v(" 复杂性分析")]),a._v(" "),v("ul",[v("li",[a._v("时间复杂性、空间复杂性")])]),a._v(" "),v("h2",{attrs:{id:"算法的表示"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法的表示"}},[a._v("#")]),a._v(" 算法的表示")]),a._v(" "),v("ul",[v("li",[a._v("自然语言")]),a._v(" "),v("li",[a._v("流程图")]),a._v(" "),v("li",[a._v("程序设计语言")]),a._v(" "),v("li",[a._v("伪代码")])]),a._v(" "),v("h2",{attrs:{id:"时间复杂性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂性"}},[a._v("#")]),a._v(" 时间复杂性")]),a._v(" "),v("ul",[v("li",[a._v("最佳情况")]),a._v(" "),v("li",[a._v("最坏情况")]),a._v(" "),v("li",[a._v("平均情况\n"),v("ul",[v("li",[v("img",{attrs:{src:_(570),alt:"image-20211026155622683"}})])])])]),a._v(" "),v("h2",{attrs:{id:"递归式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#递归式"}},[a._v("#")]),a._v(" 递归式")]),a._v(" "),v("h3",{attrs:{id:"递归算法的时间复杂度分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#递归算法的时间复杂度分析"}},[a._v("#")]),a._v(" 递归算法的时间复杂度分析")]),a._v(" "),v("ul",[v("li",[a._v("展开法")]),a._v(" "),v("li",[a._v("代换法")]),a._v(" "),v("li",[a._v("递归树法")]),a._v(" "),v("li",[a._v("主方法")])])])}),[],!1,null,null,null);t.default=s.exports}}]);