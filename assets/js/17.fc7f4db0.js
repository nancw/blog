(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{635:function(v,_,l){v.exports=l.p+"assets/img/831031-20151110145149650-1876180802.aa6cab5f.png"},636:function(v,_,l){v.exports=l.p+"assets/img/image-20211021151813805.b32f1f6b.png"},637:function(v,_,l){v.exports=l.p+"assets/img/image-20211021152151101.ea5a51a9.png"},638:function(v,_,l){v.exports=l.p+"assets/img/image-20211021152507873.46af7550.png"},639:function(v,_,l){v.exports=l.p+"assets/img/image-20211021152424920.680109a5.png"},640:function(v,_,l){v.exports=l.p+"assets/img/image-20211021155246617.348476d0.png"},641:function(v,_,l){v.exports=l.p+"assets/img/image-20211021160749514.5711ba5f.png"},642:function(v,_,l){v.exports=l.p+"assets/img/image-20211011101126967.4f9d8996.png"},643:function(v,_,l){v.exports=l.p+"assets/img/image-20211026152812757.793ae868.png"},644:function(v,_,l){v.exports=l.p+"assets/img/image-20211011101120184.8635e258.png"},846:function(v,_,l){"use strict";l.r(_);var a=l(12),t=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"软件工程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件工程"}},[v._v("#")]),v._v(" 软件工程")]),v._v(" "),a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),a("h3",{attrs:{id:"基本原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本原理"}},[v._v("#")]),v._v(" 基本原理")]),v._v(" "),a("ul",[a("li",[v._v("分阶段的生命周期计划严格管理\n坚持进行阶段评审\n严格进行产品控制\n采用现代程序设计技术\n结果应能清楚的审查\n开发小组的人员少而精\n承认不断改进软件工程实践的必要性")])]),v._v(" "),a("h3",{attrs:{id:"基本要素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本要素"}},[v._v("#")]),v._v(" 基本要素")]),v._v(" "),a("ul",[a("li",[v._v("方法、工具、过程")])]),v._v(" "),a("h3",{attrs:{id:"软件生存周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件生存周期"}},[v._v("#")]),v._v(" 软件生存周期")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("可行性分析与项目开发计划")]),v._v("(可行性分析报告和项目开发计划)、\n"),a("strong",[v._v("需求分析")]),v._v("(软件需求说明书)、"),a("strong",[v._v("概要设计")]),v._v("(概要设计说明书)、\n"),a("strong",[v._v("详细设计")]),v._v("(详细设计文档)、"),a("strong",[v._v("编码")]),v._v("(源程序清单)、\n"),a("strong",[v._v("测试")]),v._v("(软件测试计划、测试用例、软件测试报告)、"),a("strong",[v._v("维护")])])]),v._v(" "),a("h3",{attrs:{id:"软件过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件过程"}},[v._v("#")]),v._v(" 软件过程")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("意义")]),v._v(" "),a("ul",[a("li",[v._v("改进软件过程和降低风险")])])]),v._v(" "),a("li",[a("p",[v._v("能力成熟模型（CNM）")]),v._v(" "),a("ul",[a("li",[v._v("对软件组织化阶段的描述，随着软件组织定义、实施、测量、控制和改进软件过程，软件组织能力经过这些阶段提高")]),v._v(" "),a("li",[v._v("初始级、可重复级、已定义级、已管理级、优化级")])])]),v._v(" "),a("li",[a("p",[v._v("能力成熟模型集成（CMMI）")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("阶段式模型")]),v._v(" "),a("ul",[a("li",[v._v("类似CNM，初始的、已管理的、已定义的、定量管理的、优化的")])])]),v._v(" "),a("li",[a("p",[v._v("连续式模型")]),v._v(" "),a("ul",[a("li",[v._v("关注每个过程域的能力，一个组织对不同过程域可以达到不同过程域能力")]),v._v(" "),a("li",[v._v("6个过程域的能力等级，未完成的、已执行的、已管理的、已定义级的、定量管理的、优化的")])])])])]),v._v(" "),a("li",[a("p",[v._v("统一过程(UP)模型")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("特点")]),v._v(" "),a("ul",[a("li",[v._v("用例和风险驱动、以架构为中心、迭代并且增量")])])]),v._v(" "),a("li",[a("p",[v._v("阶段")]),v._v(" "),a("ul",[a("li",[v._v("起始（确认需求和风险评估）、\n精化（完成架构设计）、\n构建（开发剩余构件，组装构件）\n移交（进行测试，交付系统）")])])]),v._v(" "),a("li",[a("p",[v._v("核心工作流")]),v._v(" "),a("ul",[a("li",[v._v("需求、分析、设计、实现、测试")])])])])])]),v._v(" "),a("h2",{attrs:{id:"软件开发方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件开发方法"}},[v._v("#")]),v._v(" 软件开发方法")]),v._v(" "),a("h3",{attrs:{id:"结构化开发方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构化开发方法"}},[v._v("#")]),v._v(" 结构化开发方法")]),v._v(" "),a("ul",[a("li",[v._v("面向数据流的开发方法，用数据流图建立系统功能模型，完成需求分析工作")]),v._v(" "),a("li",[v._v("自底向下，逐层分解。基本原则功能的分解和抽象")]),v._v(" "),a("li",[v._v("适用于数据处理领域，不适用于大规模特别复杂的项目，难以适应需求变化")])]),v._v(" "),a("h3",{attrs:{id:"jackson方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jackson方法"}},[v._v("#")]),v._v(" Jackson方法")]),v._v(" "),a("ul",[a("li",[v._v("以数据结构为驱动，适合小规模项目，适用于时序特点较强的系统")])]),v._v(" "),a("h3",{attrs:{id:"原型方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型方法"}},[v._v("#")]),v._v(" 原型方法")]),v._v(" "),a("ul",[a("li",[v._v("仅适用于需求分析阶段")]),v._v(" "),a("li",[v._v("适用于需求不明确，规模不大也不太复杂")])]),v._v(" "),a("h3",{attrs:{id:"面向对象方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象方法"}},[v._v("#")]),v._v(" 面向对象方法")]),v._v(" "),a("ul",[a("li",[v._v("可用于需求经常变化，规模复杂的项目")])]),v._v(" "),a("h3",{attrs:{id:"敏捷开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#敏捷开发"}},[v._v("#")]),v._v(" 敏捷开发")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("针对中小型项目，给程序员减负，去掉不必要会议和文档")])]),v._v(" "),a("li",[a("p",[v._v("开发宣言")]),v._v(" "),a("ul",[a("li",[v._v("个体和交互胜过过程和工具、可以工作的软件胜过面面俱到的文档、客户合作胜过合同谈判、先用变化胜过遵循计划")])])]),v._v(" "),a("li",[a("p",[v._v("模型")]),v._v(" "),a("ul",[a("li",[a("p",[a("strong",[v._v("极限编程（XP）")])])]),v._v(" "),a("li",[a("p",[v._v("核心（价值观）")]),v._v(" "),a("ul",[a("li",[v._v("沟通、简明、反馈、勇气")])])]),v._v(" "),a("li",[a("p",[v._v("原则")]),v._v(" "),a("ul",[a("li",[v._v("快速反馈、简单性假设、逐步修改、提倡更改、优质工作")])])]),v._v(" "),a("li",[a("p",[v._v("最佳实践")]),v._v(" "),a("ul",[a("li",[v._v("计划游戏、小型发布、隐喻、简单设计、测试先行、重构、结对编程、集成代码所有制、持续集成、每周工作40小时、现场客户、编码标准")]),v._v(" "),a("li",[v._v("目的\n"),a("ul",[a("li",[v._v("降低需求变化成本")])])])])])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("水晶法（Crystal）")])]),v._v(" "),a("ul",[a("li",[a("p",[v._v("不同项目不同策略、约定和方法论")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("并列争求法（Scrum）")])])]),v._v(" "),a("li",[a("p",[v._v("迭代增量化过程，每段时间一次迭代，按需求优化级别实现产品，多组织和小组并行递增实现产品")])])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("自适应软件开发（ASD）")])]),v._v(" "),a("ul",[a("li",[a("p",[v._v("6个原则")]),v._v(" "),a("ul",[a("li",[v._v("使命作为指导，特征被视为客户价值的关键点；过程种等待很重要，因此重做和做同等关键；变化不被视为改正，而是对软件开发实际情况的调整；确定的交付时间迫使开发人员认真考虑每个生产版本的关键需求；风险也包含其中")])])])])]),v._v(" "),a("li",[a("p",[v._v("敏捷统一过程（AUP）")]),v._v(" "),a("ul",[a("li",[v._v("采用大型上连续，小型上迭代的原理构建软件系统")]),v._v(" "),a("li",[v._v("建模、实现、测试、部署、配置及项目管理、环境管理")])])])]),v._v(" "),a("h2",{attrs:{id:"软件过程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件过程模型"}},[v._v("#")]),v._v(" 软件过程模型")]),v._v(" "),a("h3",{attrs:{id:"瀑布模型-sdlc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#瀑布模型-sdlc"}},[v._v("#")]),v._v(" 瀑布模型（SDLC）")]),v._v(" "),a("ul",[a("li",[v._v("开发一步一步的走下去，面向过程")]),v._v(" "),a("li",[v._v("结构化开发，适用于需求明确或二次开发")])]),v._v(" "),a("h3",{attrs:{id:"增量模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量模型"}},[v._v("#")]),v._v(" 增量模型")]),v._v(" "),a("ul",[a("li",[v._v("开发核心功能，用户确认，之后再开发再确认，直至项目完成，优先级最高服务最先交付")]),v._v(" "),a("li",[v._v("不利于模块划分，每个增量版本都是可独立可操作作品")]),v._v(" "),a("li",[v._v("适合软件需求不明确，模型较灵活")])]),v._v(" "),a("h3",{attrs:{id:"原型模型-演化模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型模型-演化模型"}},[v._v("#")]),v._v(" 原型模型（演化模型）")]),v._v(" "),a("ul",[a("li",[v._v("不断演示和用户沟通，采用迭代思想")]),v._v(" "),a("li",[v._v("针对需求不明确情况，不适合超大项目开发")])]),v._v(" "),a("h3",{attrs:{id:"螺旋模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#螺旋模型"}},[v._v("#")]),v._v(" 螺旋模型")]),v._v(" "),a("ul",[a("li",[v._v("瀑布和演化模型相结合，与原型类似，增加风险分析")]),v._v(" "),a("li",[v._v("针对需求不明确的项目，适合大型项目开发")]),v._v(" "),a("li",[v._v("包含四方面活动，制订计划、风险分析、实施工程、客户评估")])]),v._v(" "),a("h3",{attrs:{id:"喷泉模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#喷泉模型"}},[v._v("#")]),v._v(" 喷泉模型")]),v._v(" "),a("ul",[a("li",[v._v("面向对象的模型，采用迭代思想和无间隙开发")]),v._v(" "),a("li",[v._v("克服瀑布模型不支持软件重用、多项开发活动集成的局限性。需大量开发人员，严格管理文档，审核难度加大")])]),v._v(" "),a("h3",{attrs:{id:"v模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v模型"}},[v._v("#")]),v._v(" V模型")]),v._v(" "),a("ul",[a("li",[v._v("增加多轮测试(验收测试、系统测试、集成测试、单元测试)，并且贯穿于软件开发各个阶段")]),v._v(" "),a("li",[v._v("保证了项目的准确性")])]),v._v(" "),a("h3",{attrs:{id:"基于构件的开发模型-cbsd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于构件的开发模型-cbsd"}},[v._v("#")]),v._v(" 基于构件的开发模型（CBSD）")]),v._v(" "),a("ul",[a("li",[v._v("增强复用性，节省时间和成本")])]),v._v(" "),a("h3",{attrs:{id:"形式化方法模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#形式化方法模型"}},[v._v("#")]),v._v(" 形式化方法模型")]),v._v(" "),a("ul",[a("li",[v._v("建立严格数学基础的一种软件开发方法")]),v._v(" "),a("li",[v._v("主要活动是生成计算机软件形式的数学规格说明")])]),v._v(" "),a("h3",{attrs:{id:"变更控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变更控制"}},[v._v("#")]),v._v(" 变更控制")]),v._v(" "),a("ul",[a("li",[v._v("借助于配置数据库和基线的概念。分为开发库、产品库、受控库")])]),v._v(" "),a("h2",{attrs:{id:"需求分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求分析"}},[v._v("#")]),v._v(" 需求分析")]),v._v(" "),a("h3",{attrs:{id:"需求分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求分类"}},[v._v("#")]),v._v(" 需求分类")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("需求内容")]),v._v(" "),a("ul",[a("li",[v._v("业务需求、用户需求、系统需求")])])]),v._v(" "),a("li",[a("p",[v._v("客户角度")]),v._v(" "),a("ul",[a("li",[v._v("基本需求、期望需求、兴奋需求")])])]),v._v(" "),a("li",[a("p",[v._v("软件需求")]),v._v(" "),a("ul",[a("li",[v._v("功能需求、性能需求、设计约束、属性、外部结构需求")])])])]),v._v(" "),a("h3",{attrs:{id:"需求工程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求工程"}},[v._v("#")]),v._v(" 需求工程")]),v._v(" "),a("ul",[a("li",[v._v("需求获取、分析与协商、规约、验证、管理")])]),v._v(" "),a("h3",{attrs:{id:"需求管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求管理"}},[v._v("#")]),v._v(" 需求管理")]),v._v(" "),a("ul",[a("li",[v._v("定义需求基线、处理需求变更、需求跟踪")])]),v._v(" "),a("h2",{attrs:{id:"系统设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统设计"}},[v._v("#")]),v._v(" 系统设计")]),v._v(" "),a("h3",{attrs:{id:"系统设计阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统设计阶段"}},[v._v("#")]),v._v(" 系统设计阶段")]),v._v(" "),a("ul",[a("li",[v._v("需求规格说明书，做什么逻辑模型转换成怎么做物理模型")])]),v._v(" "),a("h3",{attrs:{id:"主要目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要目的"}},[v._v("#")]),v._v(" 主要目的")]),v._v(" "),a("ul",[a("li",[v._v("技术与实施权衡利弊，精心设计合理利用资源")])]),v._v(" "),a("h3",{attrs:{id:"设计方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计方法"}},[v._v("#")]),v._v(" 设计方法")]),v._v(" "),a("ul",[a("li",[v._v("面向数据流的结构化设计方法")]),v._v(" "),a("li",[v._v("面向对象的分析方法")])]),v._v(" "),a("h3",{attrs:{id:"设计步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计步骤"}},[v._v("#")]),v._v(" 设计步骤")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("概要设计")]),v._v(" "),a("ul",[a("li",[v._v("设系统的总体结构、数据结构、数据库设计、编写概要设计文档，评审")])])]),v._v(" "),a("li",[a("p",[v._v("详细设计")]),v._v(" "),a("ul",[a("li",[v._v("模块内详细算法设计、模块内数据结构设计、数据库物理设计、其他设计（代码、输入/输出、用户界面）、详细设计说明书、评审")])])])]),v._v(" "),a("h2",{attrs:{id:"软件测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件测试"}},[v._v("#")]),v._v(" 软件测试")]),v._v(" "),a("h3",{attrs:{id:"测试阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试阶段"}},[v._v("#")]),v._v(" 测试阶段")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("单元测试")]),v._v(" "),a("ul",[a("li",[v._v("测试依据，软件详细说明书，白盒法")])])]),v._v(" "),a("li",[a("p",[v._v("集成测试")]),v._v(" "),a("ul",[a("li",[v._v("模块组合起来测试、增量式组装")])])]),v._v(" "),a("li",[a("p",[v._v("确认测试")]),v._v(" "),a("ul",[a("li",[v._v("已完成软件功能测试、内部确认测试、Alpha测试、B而他测试、验收测试")])])]),v._v(" "),a("li",[a("p",[v._v("系统测试")]),v._v(" "),a("ul",[a("li",[v._v("性能测试、负载测试、强度测试、容量测试、可靠性等性能测试")]),v._v(" "),a("li",[v._v("采用黑盒测试方法")])])]),v._v(" "),a("li",[a("p",[v._v("回归测试")]),v._v(" "),a("ul",[a("li",[v._v("软件修改错误或变更后的验证测试")])])])]),v._v(" "),a("h3",{attrs:{id:"测试方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试方法"}},[v._v("#")]),v._v(" 测试方法")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("动态测试")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("定义")]),v._v(" "),a("ul",[a("li",[v._v("程序运行时测试")])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("黑盒测试")])]),v._v(" "),a("ul",[a("li",[a("p",[v._v("功能性测试，不了解软件代码结构")])]),v._v(" "),a("li",[a("p",[v._v("设计的测试用例分类")]),v._v(" "),a("ul",[a("li",[v._v("等价类划分、边界值划分、错误推测、因果图")])])])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("白盒测试")])]),v._v(" "),a("ul",[a("li",[a("p",[v._v("结构性测试，明确代码流程，根据代码逻辑设计，进行用例覆盖")])]),v._v(" "),a("li",[a("p",[v._v("设计的测试用例分类")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("语句覆盖（最弱的覆盖准则）：使所有的判断语句都能执行一次的条件案例，例如有两个if语句，那么就至少需要两个测试用例；")])]),v._v(" "),a("li",[a("p",[v._v("判定覆盖（分支覆盖）")]),v._v(" "),a("ul",[a("li",[v._v("针对判断语句，在设定案例的时候，要设定True和False的两种案例；")]),v._v(" "),a("li",[a("img",{attrs:{src:l(635),alt:"img"}})])])]),v._v(" "),a("li",[a("p",[v._v("条件覆盖")]),v._v(" "),a("ul",[a("li",[v._v("针对判断语句里面案例的取值都要去一次，不考虑条件的取值；")]),v._v(" "),a("li",[a("img",{attrs:{src:l(636),alt:"image-20211021151813805"}})])])]),v._v(" "),a("li",[a("p",[v._v("判定/条件覆盖")]),v._v(" "),a("ul",[a("li",[v._v("判定覆盖各条件覆盖交叉，针对于判定中的条件取值；")]),v._v(" "),a("li",[a("img",{attrs:{src:l(637),alt:"image-20211021152151101"}})])])]),v._v(" "),a("li",[a("p",[v._v("条件组合覆盖")]),v._v(" "),a("ul",[a("li",[v._v("判定-条件覆盖的加强版；")]),v._v(" "),a("li",[a("img",{attrs:{src:l(638),alt:"image-20211021152507873"}})])])]),v._v(" "),a("li",[a("p",[v._v("路径覆盖")]),v._v(" "),a("ul",[a("li",[a("img",{attrs:{src:l(639),alt:"image-20211021152424920"}})])])]),v._v(" "),a("li",[a("p",[v._v("清楚程序流程图中有几条路径，然后为每条路径设置一个测试用例")])]),v._v(" "),a("li",[a("p",[v._v("举例\nif A and B then Action1\nif C or D then Action2")]),v._v(" "),a("p",[v._v("语句覆盖最弱，只需要让程序中的语句都执行一遍即可 。上例中只需设计测试用例使得A=true B=true C=true 即可。")]),v._v(" "),a("p",[v._v("分支覆盖又称判定覆盖：使得程序中每个判断的取真分支和取假分支至少经历一次，即判断的真假均曾被满足。上例需要设计测试用例使其分别满足下列条件即可（1）A=true，B=true，C＝true，D=false（2）A=true，B=false，C＝false，D=false。")]),v._v(" "),a("p",[v._v("条件覆盖：要使得每个判断中的每个条件的可能取值至少满足一次。上例中第一个判断应考虑到A=true，A=false，B=true，B=false第二个判断应考虑到C＝true，C＝false，D=true，D=false，所以上例中可以设计测试用例满足下列条件（1）A=true，B=true，C＝true，D=true（2）A=false，B=false，C＝false，D=false。")]),v._v(" "),a("p",[v._v("路径覆盖：要求覆盖程序中所有可能的路径。所以可以设计测试用例满足下列条件（1）A=true，B=true，C＝true，D=true（2）A=false，B=false，C＝false，D=false（3）A=true，B=true，C＝false，D=false（4）A=false，B=false，C＝true，D=true。")]),v._v(" "),a("p",[v._v("不论那种覆盖方法，都不能保证程序的正确性。")])])])])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("灰盒测试")])]),v._v(" "),a("ul",[a("li",[v._v("既有黑又有白盒测试")])])])])]),v._v(" "),a("li",[a("p",[v._v("静态测试")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("程序静止时，对代码进行人工审查")])]),v._v(" "),a("li",[a("p",[v._v("桌签审查")]),v._v(" "),a("ul",[a("li",[v._v("程序员自己检查，程序编译后，单元测试前")])])]),v._v(" "),a("li",[a("p",[v._v("代码审查")]),v._v(" "),a("ul",[a("li",[v._v("若干程序员和测试人员组成评审小组，召开评审会议审查")])])]),v._v(" "),a("li",[a("p",[v._v("代码走查")]),v._v(" "),a("ul",[a("li",[v._v("开会审查，测试人员提供测试用例，程序与扮演计算机角色，手动运行测试用例，检查代码逻辑")])])])])]),v._v(" "),a("li",[a("p",[v._v("测试策略")]),v._v(" "),a("ul",[a("li",[v._v("自顶向上、自底向下、三明治")])])])]),v._v(" "),a("h3",{attrs:{id:"调试方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调试方法"}},[v._v("#")]),v._v(" 调试方法")]),v._v(" "),a("ul",[a("li",[v._v("蛮力法、回溯法（从出错的地方开始向回找）、原因排错法（找出所有可能的原因，逐一进行排除，具体包括演绎法、归纳法、二分法）")])]),v._v(" "),a("h3",{attrs:{id:"成功测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#成功测试"}},[v._v("#")]),v._v(" 成功测试")]),v._v(" "),a("ul",[a("li",[v._v("发现至今为至尚未发现的错误；高效测试，少量测试用例发现最多的错误")])]),v._v(" "),a("h2",{attrs:{id:"软件系统转换、维护、评价"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件系统转换、维护、评价"}},[v._v("#")]),v._v(" 软件系统转换、维护、评价")]),v._v(" "),a("h3",{attrs:{id:"转换计划"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转换计划"}},[v._v("#")]),v._v(" 转换计划")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("直接转换")]),v._v(" "),a("ul",[a("li",[v._v("风险大，不适合复杂系统，节省成本")])])]),v._v(" "),a("li",[a("p",[v._v("并行转换")]),v._v(" "),a("ul",[a("li",[v._v("新旧系统一起工作，风险小，耗费人力时间")])])]),v._v(" "),a("li",[a("p",[v._v("分段转换")]),v._v(" "),a("ul",[a("li",[v._v("大型系统分为多个子系统，适合大型项目，耗时长，需协调好接口")])])])]),v._v(" "),a("h3",{attrs:{id:"系统维护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统维护"}},[v._v("#")]),v._v(" 系统维护")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("评价指标")]),v._v(" "),a("ul",[a("li",[v._v("易测试性、易分析性、易改变性、稳定性")])])]),v._v(" "),a("li",[a("p",[v._v("硬件维护、软件维护、数据维护")])]),v._v(" "),a("li",[a("p",[v._v("软件维护")]),v._v(" "),a("p",[v._v("预防性维护，是指为了提高软件的可维护性和可靠性、为未来的进一步改进打下基础而修改软件的活动。该类维护一般占总维护工作量的50%。\n改正性维护。是指在使用过程中发现了隐蔽的错误后，为了诊断和改正这些隐蔽错误而修改软件的活动。该类维护一般占总维护工作量的25%。\n适应性维护。是指为了适应变化了的环境而修改软件的活动。该类维护一般占总维护工作量的20%。\n完善性维护。是指为了扩充或完善原有软件的功能或性能而修改软件的活动。该类维护一般占总维护工作量的5%。")]),v._v(" "),a("ul",[a("li",[v._v("正确性、适应性、完善性、预防性维护")])])])]),v._v(" "),a("h3",{attrs:{id:"系统评价"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统评价"}},[v._v("#")]),v._v(" 系统评价")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("立项评价、中期评价、结项评价")])]),v._v(" "),a("li",[a("p",[v._v("评价指标")]),v._v(" "),a("ul",[a("li",[v._v("按信息系统组成部分出发。按照运行效果、用户需求、系统质量、技术条件构造指标")]),v._v(" "),a("li",[v._v("按信息系统的评价对象出发，对开发者，时系统质量和技术水平；对用户，用户需求和软件质量；系统外部环境则主要统一社会效益指标来反映")]),v._v(" "),a("li",[v._v("经济学角度，分系统成本、系统效益、和财务指标")])])])]),v._v(" "),a("h2",{attrs:{id:"项目管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目管理"}},[v._v("#")]),v._v(" 项目管理")]),v._v(" "),a("h3",{attrs:{id:"四要素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四要素"}},[v._v("#")]),v._v(" 四要素")]),v._v(" "),a("ul",[a("li",[v._v("人员、产品、过程、项目")])]),v._v(" "),a("h3",{attrs:{id:"项目估算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目估算"}},[v._v("#")]),v._v(" 项目估算")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("估算方法")]),v._v(" "),a("ul",[a("li",[v._v("成本估算\n"),a("ul",[a("li",[v._v("有自顶向下、自底向上、差别估算；")])])]),v._v(" "),a("li",[v._v("专家估算\n"),a("ul",[a("li",[v._v("专家估算容易受到专家经验和主观性的影响；")])])]),v._v(" "),a("li",[v._v("类推估算")]),v._v(" "),a("li",[v._v("算式估算")]),v._v(" "),a("li",[v._v("机器学习方法是一种基于人工智能与神经网络技术的估算方法，它难以描述训练数据的特征和确定其相似性。")])])]),v._v(" "),a("li",[a("p",[v._v("估算模型")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("Putnam模型")]),v._v(" "),a("ul",[a("li",[v._v("一种动态多变量模型，它是假设在软件开发的整个生存期中的工作量特定的分布；")])])]),v._v(" "),a("li",[a("p",[v._v("COCOMO模型（采用启发式方法）")])]),v._v(" "),a("li",[a("p",[v._v("以代码行数估算程序员工作量")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("按详细程度分类")])]),v._v(" "),a("li",[a("p",[v._v("基本、中间、详细COCOMO模型")])])])]),v._v(" "),a("li",[a("p",[v._v("特点")]),v._v(" "),a("ul",[a("li",[v._v("具有参数难以确定、精确度不高")])])]),v._v(" "),a("li",[a("p",[v._v("COCOMO II 模型")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("以软件规模作为成本的主要因素")])]),v._v(" "),a("li",[a("p",[v._v("考虑多个成本驱动因子")]),v._v(" "),a("ul",[a("li",[v._v("应用组装、早期设计阶段、体系结构阶段模型")])])]),v._v(" "),a("li",[a("p",[v._v("估算选择")]),v._v(" "),a("ul",[a("li",[v._v("对象点、功能点、代码行")])])])])])])])]),v._v(" "),a("h3",{attrs:{id:"进度管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进度管理"}},[v._v("#")]),v._v(" 进度管理")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("基本原则")]),v._v(" "),a("ul",[a("li",[v._v("划分、相互依赖、时间分配、工作量确认、确认责任、明确输出结果、确定里程牌")])])]),v._v(" "),a("li",[a("p",[v._v("Grantt图（甘特图、横道图）")]),v._v(" "),a("ul",[a("li",[v._v("横轴标识时间、纵轴表示活动，以时间顺序标识活动，能反应活动间并行关系，但无法反应活动之间的依赖关系")]),v._v(" "),a("li",[v._v("难以清晰确定关键任务和关键路径")]),v._v(" "),a("li",[a("img",{attrs:{src:l(640),alt:"image-20211021155246617"}})])])]),v._v(" "),a("li",[a("p",[v._v("Pert图（前趋图、计划评审技术图）")]),v._v(" "),a("ul",[a("li",[v._v("是有向图，反应活动之间的依赖关系，有向边上标识活动运行时间，但无法反应活动之间并行关系；")]),v._v(" "),a("li",[a("img",{attrs:{src:l(641),alt:"image-20211021160749514"}})])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("关键路径")])]),v._v(" "),a("ul",[a("li",[v._v("项目耗时最长的一条线路，而松弛时间则反映了完成某些任务时可以推迟其开始时间或延长其所需完成的事件；")])])]),v._v(" "),a("li",[a("p",[v._v("特点")]),v._v(" "),a("ul",[a("li",[v._v("不仅给出每隔任务的开始时间、结束时间和完成所需要的时间，还给出任务时间的关系；")])])])]),v._v(" "),a("h3",{attrs:{id:"项目组织"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目组织"}},[v._v("#")]),v._v(" 项目组织")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("组织结构模式")]),v._v(" "),a("ul",[a("li",[v._v("项目型、只能型、矩阵型（二者结合，但权利分割不同）")])])]),v._v(" "),a("li",[a("p",[v._v("程序设计小组的组织方式")]),v._v(" "),a("ul",[a("li",[v._v("主程序员小组（大项目）；")]),v._v(" "),a("li",[v._v("民主制小组（规模小，开发少）；")]),v._v(" "),a("li",[v._v("层次式小组（一组长若干高级程序员，高级程序员下若干程序员）；")])])])]),v._v(" "),a("h3",{attrs:{id:"软件配置管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件配置管理"}},[v._v("#")]),v._v(" 软件配置管理")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("基线")]),v._v(" "),a("ul",[a("li",[v._v("软件过程种生存期各开发阶段末尾的特定点。又称里程碑，反映阶段性成果")])])]),v._v(" "),a("li",[a("p",[v._v("软件配置项")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("是软件工程中的产生的信息项，是配置管理的基本单位")])]),v._v(" "),a("li",[a("p",[v._v("文档、代码、工具作为配置项")])]),v._v(" "),a("li",[a("p",[v._v("六种类型")]),v._v(" "),a("ul",[a("li",[v._v("环境类（系统开发环境）、定义类（需求分析和系统定义阶段）、设计类（设计阶段）、编码类（编码及单元测试阶段）、测试类（系统测试完成后的工作）、维护类（维护阶段）")])])]),v._v(" "),a("li",[a("p",[v._v("产品组成部分的工作成功+项目管理和机构支撑过程域产生的文档")])])])]),v._v(" "),a("li",[a("p",[v._v("版本控制")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("三个状态")]),v._v(" "),a("ul",[a("li",[v._v("草稿、正式、修改")])])]),v._v(" "),a("li",[a("p",[v._v("变更控制")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("配置数据库分类")]),v._v(" "),a("ul",[a("li",[v._v("开发库、受控库、产品库")])])])])])])])]),v._v(" "),a("h3",{attrs:{id:"风险管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#风险管理"}},[v._v("#")]),v._v(" 风险管理")]),v._v(" "),a("p",[v._v("对风险排优先级是根据风险的曝光度来进行的，曝光度等于风险的产生后果乘以风险发生的概率")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("特性")]),v._v(" "),a("ul",[a("li",[v._v("不确定性和损失")])])]),v._v(" "),a("li",[a("p",[v._v("分类")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("项目风险")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("因素")]),v._v(" "),a("ul",[a("li",[v._v("威胁到项目计划，可推迟项目进度和成本")]),v._v(" "),a("li",[v._v("项目预算、进度、人员、资源、利益相关者、需求等、项目复杂度（规模、难度、结构、复杂度）、规模及结构不确定性")])])])])]),v._v(" "),a("li",[a("p",[v._v("技术风险")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("威胁软件质量的交付时间，可使开发工作困难或不可能")])]),v._v(" "),a("li",[a("p",[v._v("因素")]),v._v(" "),a("ul",[a("li",[v._v("设计、实现、接口、验证维护等，规格说明的歧义性、技术的不确定性、技术陈旧以及前沿技术的风险")])])])])]),v._v(" "),a("li",[a("p",[v._v("商业风险")]),v._v(" "),a("ul",[a("li",[v._v("威胁开发软件的生存能力")]),v._v(" "),a("li",[v._v("开发、策略、销售、管理、预算风险")])])])])]),v._v(" "),a("li",[a("p",[v._v("管理过程")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("风险识别、风险预测、风险评估、风险控制")]),v._v(" "),a("p",[v._v("在进行风险分析时，风险控制的目的是辅助项目组建立处理风险的策略，有效的策略应考虑风险避免、风险监控、风险管理及意外事件计划")])])])])]),v._v(" "),a("h2",{attrs:{id:"软件质量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件质量"}},[v._v("#")]),v._v(" 软件质量")]),v._v(" "),a("h3",{attrs:{id:"质量模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#质量模型"}},[v._v("#")]),v._v(" 质量模型")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("ISO/IEC9126 质量模型及质量特性与子特性")]),v._v(" "),a("ul",[a("li",[a("img",{attrs:{src:l(642),alt:"image-20211011101126967"}})])])])]),v._v(" "),a("h3",{attrs:{id:"质量保证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#质量保证"}},[v._v("#")]),v._v(" 质量保证")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("3个要点")]),v._v(" "),a("ul",[a("li",[v._v("软件必须满足用户需求、软件应遵循规定的一系列开发标准、软件应满足某些隐含的需求")])])]),v._v(" "),a("li",[a("p",[v._v("7个任务")])]),v._v(" "),a("li",[a("p",[v._v("应用技术方法、正式的技术评审、测试软件、标准的实施、控制变更、度量、记录保存和报告")])])]),v._v(" "),a("h3",{attrs:{id:"评审内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#评审内容"}},[v._v("#")]),v._v(" 评审内容")]),v._v(" "),a("ul",[a("li",[v._v("① 评价软件的规格说明是否合乎用户的要求，即总体设计思想和设计方针是否正确;\n② 评审可靠性，即是否能避免输入异常(错误或超载等)、硬件失效及软件失效所产生的失效;\n③ 评审保密措施实现情况;\n④ 评审操作特性实施情况;\n⑤ 评审性能实现情况;\n⑥ 评审软件是否具有可修改性、可扩充性、可互换性和可移植性;\n⑦ 评审软件是否具有可测试性;⑧评审软件是否具有复用性。")])]),v._v(" "),a("h3",{attrs:{id:"质量评估"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#质量评估"}},[v._v("#")]),v._v(" 质量评估")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("设计质量")]),v._v(" "),a("ul",[a("li",[v._v("设计规格说明书符合用户标准")])])]),v._v(" "),a("li",[a("p",[v._v("程序质量")]),v._v(" "),a("ul",[a("li",[v._v("程序按照设计规格说明书所规定的情况正确执行")]),v._v(" "),a("li",[v._v("模块间结构主要有控制流结构、数据流结构、模块结构与功能结构之间的对应关系")])])])]),v._v(" "),a("h3",{attrs:{id:"容错技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#容错技术"}},[v._v("#")]),v._v(" 容错技术")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("主要手段")]),v._v(" "),a("ul",[a("li",[v._v("冗余")])])]),v._v(" "),a("li",[a("p",[v._v("四种冗余技术")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("结构冗余")]),v._v(" "),a("ul",[a("li",[v._v("分静态、动态、混合冗余")])])]),v._v(" "),a("li",[a("p",[v._v("信息冗余")]),v._v(" "),a("ul",[a("li",[v._v("校验码原理，为检错和纠错在数据上加额外信息")])])]),v._v(" "),a("li",[a("p",[v._v("时间冗余")]),v._v(" "),a("ul",[a("li",[v._v("遇错误回滚、转入错误处理逻辑")])])]),v._v(" "),a("li",[a("p",[v._v("冗余附加技术")]),v._v(" "),a("p",[v._v("为实现：结构、信息、时间的冗余技术所需的资源和技术。包括程序、指令、数据、存放和调动他们的空间和通道等")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("屏蔽硬件错误")]),v._v(" "),a("ul",[a("li",[v._v("关键程序、数据的冗余及调用；检测、表决、切换、重构和复算的实现")])])]),v._v(" "),a("li",[a("p",[v._v("屏蔽软件错误")]),v._v(" "),a("ul",[a("li",[v._v("冗余备份程序的存储及调用、实现错误检测和错误恢复的程序、实现容错软件所需的固化程序")])])])])])])])]),v._v(" "),a("h2",{attrs:{id:"软件度量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件度量"}},[v._v("#")]),v._v(" 软件度量")]),v._v(" "),a("h3",{attrs:{id:"属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[v._v("#")]),v._v(" 属性")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("外部属性")]),v._v(" "),a("ul",[a("li",[v._v("面向管理的属性，一般为性能指标，可直接测量")])])]),v._v(" "),a("li",[a("p",[v._v("内部属性")]),v._v(" "),a("ul",[a("li",[v._v("指软件产品本身的属性，如可靠性，间接测量")])])]),v._v(" "),a("li",[a("p",[a("img",{attrs:{src:l(643),alt:"image-20211026152812757"}})])])]),v._v(" "),a("h3",{attrs:{id:"mccabe度量法-环路复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mccabe度量法-环路复杂度"}},[v._v("#")]),v._v(" McCabe度量法（环路复杂度）")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("假设有向图有向变数为m，节点数为n，则"),a("strong",[v._v("环路复杂度为m-n+2")])])]),v._v(" "),a("li",[a("p",[v._v("程序流程图，每一个连线就是一条有向边，每条语句框就是一个顶点，并且流程图的边必须要有起点和终点，一般最上面的没有起点的边不计数")])]),v._v(" "),a("li",[a("p",[v._v("McCall质量模型")]),v._v(" "),a("ul",[a("li",[a("img",{attrs:{src:l(644),alt:"image-20211011101120184"}})])])])]),v._v(" "),a("h2",{attrs:{id:"软件工具和开发环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件工具和开发环境"}},[v._v("#")]),v._v(" 软件工具和开发环境")]),v._v(" "),a("h3",{attrs:{id:"软件工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件工具"}},[v._v("#")]),v._v(" 软件工具")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("软件开发工具")]),v._v(" "),a("ul",[a("li",[v._v("需求分析工具、设计工具、编码和排错工具、测试工具")])])]),v._v(" "),a("li",[a("p",[v._v("软件维护工具")]),v._v(" "),a("ul",[a("li",[v._v("版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具")])])]),v._v(" "),a("li",[a("p",[v._v("管理和软件支持工具")]),v._v(" "),a("ul",[a("li",[v._v("项目管理、配置管理、软件评测工具")])])])]),v._v(" "),a("h3",{attrs:{id:"开发环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发环境"}},[v._v("#")]),v._v(" 开发环境")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("软件工具集")]),v._v(" "),a("ul",[a("li",[v._v("支持软件开发相关过程、活动和任务")])])]),v._v(" "),a("li",[a("p",[v._v("环境集成机制")]),v._v(" "),a("ul",[a("li",[v._v("为工具集成和软件开发、维护和管理提供统一支持")]),v._v(" "),a("li",[v._v("主要有数据集成、界面集成、控制集成和其他方面，如平台、方法与过程集成")])])]),v._v(" "),a("li",[a("p",[v._v("特征")]),v._v(" "),a("ul",[a("li",[v._v("环境的服务是集成的、环境应支持小组工作方式、环境的服务可用于支持各种软件开发活动")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);